<!DOCTYPE html>
<!-- Decis√£o: L-10 usa o PRIMEIRO conjunto (sobrevida). O segundo conjunto (troca de posi√ß√£o + b√™bado) foi ignorado por conflito de numera√ß√£o. -->
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Etheria: Card Battle TCG - Visual Update</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500;700&family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-dark: #121214;
            --bg-panel: #202024;
            --primary: #8257e6;
            --secondary: #04d361;
            --neon-green: #39ff14;
            --neon-cyan: #00ffff;
            --neon-red: #ff4444;
            --danger: #e83f5b;
            --text: #ffffff;
            --gold: #ffaa00;
            --blue: #4da6ff;
            --gray: #a8a8b3;
            --util: #d633d6;

            /* Cores de Raridade */
            --r-common: #000000;
            --r-rare: #000000;
            --r-legendary: #000000;
            --r-utility: #000000;
            --r-epic: #000000;

            /* Dimens√µes do Tabuleiro (Inalteradas) */
            --board-card-h: 16vh; 
            --board-card-w: 12vh; 

            --hand-card-h: 20vh; 
            --hand-card-w: 13.5vh;

            /* Fontes */
            --font-title: 'Oswald', sans-serif;
            --font-body: 'Roboto Condensed', sans-serif;

            --ui-glow: rgba(130, 87, 230, 0.35);
            --ui-glow-strong: rgba(130, 87, 230, 0.6);
            --shadow-deep: 0 18px 35px rgba(0,0,0,0.65);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: var(--font-body); user-select: none; }

        body {
            background-color: var(--bg-dark);
            color: var(--text);
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        /* --- TELAS E NAVEGA√á√ÉO --- */
        .screen-section {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: none; flex-direction: column;
        }

        /* --- MENU PRINCIPAL --- */
        #main-menu {
            background: linear-gradient(rgba(0,0,0,0.8), rgba(0,0,0,0.8)), url('https://i.postimg.cc/4NZ7SBT2/z-Fundo.png'); 
            background-size: cover; background-position: center; justify-content: center; align-items: center; z-index: 10;
        }
        .menu-container {
            display: flex; flex-direction: column; gap: 2vh; width: 40vh; background: rgba(32, 32, 36, 0.9); padding: 4vh; border: 1px solid #444; border-radius: 1vh; box-shadow: 0 0 50px rgba(0,0,0,0.8); backdrop-filter: blur(10px);
        }
        .game-logo {
            font-family: var(--font-title); font-size: 6vh; color: var(--primary); text-align: center; margin-bottom: 2vh; text-shadow: 0 0 20px rgba(130, 87, 230, 0.6); letter-spacing: 2px;
        }
        .menu-btn {
            padding: 2vh; font-family: var(--font-title); font-size: 2vh; background: transparent; border: 1px solid #555; color: #fff; cursor: pointer; transition: all 0.3s; text-transform: uppercase; letter-spacing: 1px;
        }
        .menu-btn:hover:not(:disabled) {
            background: var(--primary); border-color: var(--primary); transform: scale(1.05); box-shadow: 0 0 15px rgba(130, 87, 230, 0.4);
        }
        .menu-btn:disabled { color: #555; border-color: #333; cursor: not-allowed; background: rgba(0,0,0,0.2); }

        /* --- DECK BUILDER --- */
        #deck-builder-screen { background: #121214; padding: 2vh; z-index: 20; position: relative; }
        .builder-header { display: flex; justify-content: space-between; align-items: center; height: 10vh; border-bottom: 1px solid #333; padding: 0 2vh; background: #202024; }
        .builder-title { font-family: var(--font-title); font-size: 3.5vh; color: #fff; }
        .builder-controls { display: flex; gap: 2vh; align-items: center; }
        .deck-counter { font-family: 'Courier New', monospace; font-size: 2.5vh; color: #fff; padding: 1vh 2vh; background: #000; border: 1px solid #444; border-radius: 4px; }

        /* --- BUILDER OVERLAY (NEW) --- */
        #builder-overlay {
            position: absolute; /* Relative to deck-builder-screen */
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); 
            z-index: 3000; 
            display: none; 
            justify-content: center; 
            align-items: center;
            backdrop-filter: blur(5px);
        }

        /* --- FILTER BAR --- */
        .filter-bar {
            display: flex;
            align-items: center;
            gap: 1.5vh;
            padding: 1vh 2vh;
            background: #202024;
            border-bottom: 1px solid #333;
            height: 8vh;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5vh;
        }
        .filter-label {
            font-family: var(--font-title);
            font-size: 1.2vh;
            color: var(--gray);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .filter-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }
        .filter-icon-search {
            position: absolute;
            left: 1vh;
            color: #666;
            font-size: 1.5vh;
            pointer-events: none;
        }
        .filter-input, .filter-select {
            background: #121214;
            border: 1px solid #444;
            color: #fff;
            padding: 0.8vh 1vh;
            padding-left: 3vh; /* space for icon in input */
            border-radius: 0.5vh;
            font-family: var(--font-body);
            font-size: 1.6vh;
            outline: none;
            min-width: 15vh;
            transition: border 0.2s;
        }
        .filter-select {
            padding-left: 1vh; /* reset for select */
            cursor: pointer;
        }
        .filter-input:focus, .filter-select:focus {
            border-color: var(--primary);
            box-shadow: 0 0 5px rgba(130, 87, 230, 0.3);
        }


        /* --- DECK BUILDER / INVENT√ÅRIO (UX VISUAL) --- */
        #deck-builder-screen #builder-grid{
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(16vh, 1fr));
            gap: 1.5vh;

            /* Espa√ßo extra no topo para a 1¬™ linha crescer (scale 1.5) sem ficar atr√°s da filter-bar */
            padding: 8vh 3vh 3vh 3vh;

            overflow-y: auto;
            overflow-x: visible; /* permite o grow sem cortar */
            align-content: flex-start;
            height: calc(100% - 18vh);
            position: relative;
        }

        #deck-builder-screen .builder-card-slot{
            position: relative;
            aspect-ratio: 0.75;
            cursor: default;
            transform-origin: center center;
            transition: transform 180ms ease, filter 180ms ease;
            will-change: transform;
            z-index: 1;
        }

        /* Grow no hover: 50% (somente Deck Builder) */
        @media (hover: hover) {
            #deck-builder-screen .builder-card-slot:hover{
                transform: scale(1.5);
                z-index: 60; /* acima das demais cartas */
                filter: drop-shadow(0 10px 18px rgba(0,0,0,0.65));
            }
        }

        #deck-builder-screen .builder-card-visual{
            width: 100%;
            height: 100%;
            transform-origin: center center;
            border-radius: 1vh;
            overflow: hidden; /* garante overlay alinhado √† carta */
        }

        #deck-builder-screen .builder-card-visual .card{
            width: 100% !important;
            height: 100% !important;
            transform: none !important;
            pointer-events: none;
            margin: 0;
        }

        #deck-builder-screen .card-quantity-badge{
            position: absolute;
            top: -1vh;
            right: -1vh;
            width: 3.5vh;
            height: 3.5vh;
            background: var(--secondary);
            color: #000;
            font-weight: bold;
            font-family: var(--font-title);
            font-size: 2vh;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid #fff;
            z-index: 70;
            box-shadow: 0 2px 5px rgba(0,0,0,0.8);
        }

        /* --- BOT√ïES SOBRE A CARTA (HOVER ACTIONS) --- */
        #deck-builder-screen .builder-hover-actions{
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.6vh;
            padding: 0.6vh;
            background: transparent;
            backdrop-filter: none;
            border-top-left-radius: 1vh;
            border-top-right-radius: 1vh;
            opacity: 0;
            pointer-events: none;
            transform: translateY(-0.3vh);
            transition: opacity 160ms ease, transform 160ms ease;
            z-index: 65; /* acima da carta */
        }

        @media (hover: hover) {
            #deck-builder-screen .builder-card-slot:hover .builder-hover-actions{
                opacity: 1;
                pointer-events: auto;
                transform: translateY(0);
            }
        }

        /* Mobile/Touch (sem hover): a√ß√µes sempre vis√≠veis no topo e compactas */
        @media (hover: none) {
            #deck-builder-screen .builder-hover-actions{
                opacity: 1;
                pointer-events: auto;
                transform: none;
                background: transparent;
            }
        }}

        #deck-builder-screen .builder-hover-actions .builder-action-btn{
            pointer-events: auto; /* reabilita clique apenas nos bot√µes */
        }

        /* Mobile/Touch (sem hover): a√ß√µes sempre vis√≠veis e sem grow agressivo */
        @media (hover: none) {
            #deck-builder-screen .builder-hover-actions{
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.6vh;
            padding: 0.6vh;
            background: rgba(0,0,0,0.55);
            backdrop-filter: blur(2px);
            border-top-left-radius: 1vh;
            border-top-right-radius: 1vh;
            opacity: 0;
            pointer-events: none;
            transform: translateY(-0.3vh);
            transition: opacity 160ms ease, transform 160ms ease;
            z-index: 65; /* acima da carta */
        }

        @media (hover: hover) {
            #deck-builder-screen .builder-card-slot:hover .builder-hover-actions{
                opacity: 1;
                pointer-events: auto;
                transform: translateY(0);
            }
        }

        /* Mobile/Touch (sem hover): a√ß√µes sempre vis√≠veis no topo e compactas */
        @media (hover: none) {
            #deck-builder-screen .builder-hover-actions{
                opacity: 1;
                pointer-events: auto;
                transform: none;
                background: rgba(0,0,0,0.28);
            }
        }#deck-builder-screen .builder-card-slot{
                transform: none; /* evita zoom/bug de layout em touch */
            }
        }

        #deck-builder-screen .builder-action-btn{
            width: 100%;
            min-width: 0;
            padding: 0.55vh 0.4vh;
            font-family: var(--font-title);
            font-size: 1.25vh;
            line-height: 1;
            border: 1px solid rgba(255,255,255,0.85);
            border-radius: 0.7vh;
            cursor: pointer;
            text-transform: uppercase;
            color: #fff;
            transition: transform 120ms ease, filter 120ms ease;
            font-weight: 700;
            box-shadow: 0 2px 8px rgba(0,0,0,0.45);
        }

        #deck-builder-screen .btn-b-select{
            background: var(--secondary);
            border-color: var(--secondary);
            color: #000;
        }

        #deck-builder-screen .btn-b-view{
            background: var(--primary);
            border-color: var(--primary);
        }

        @media (hover: hover) {
            #deck-builder-screen .btn-b-select:hover,
            #deck-builder-screen .btn-b-view:hover{
                filter: brightness(1.15);
                transform: translateY(-1px) scale(1.05);
            }
        }

/* --- GAME VIEW --- */
        #game-view { z-index: 5; }
        body.cursor-sword { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="%23ff4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 17.5L3 6V3h3l11.5 11.5"/><path d="M13 19l6-6"/><path d="M16 16l4 4"/><path d="M19 21l2-2"/></svg>') 16 16, crosshair !important; }
        #game-container { display: flex; flex-direction: column; height: 100vh; width: 100vw; position: relative; justify-content: space-between; transition: filter 0.3s ease; overflow: hidden; }
        .blur-background { filter: blur(8px) brightness(0.5); pointer-events: none; }

        /* Logs e Huds */
        .battle-log { position: absolute; top: 10vh; bottom: 30vh; width: min(36vw, 56vh); min-width: 24vw; background: rgba(0, 0, 0, 0.7); padding: 1vh; overflow-y: auto; font-size: 2vh; font-family: 'Courier New', monospace; z-index: 40; border-radius: 0.5vh; display: flex; flex-direction: column; pointer-events: auto; max-height: calc(100vh - 40vh); }
        #log-player { left: 2vh; border-left: 2px solid var(--secondary); }
        .info-panel {
            position: absolute;
            top: 1vh;
            bottom: 0vh;
            right: 2vh;
            width: min(36vw, 56vh);
            min-width: 24vw;
            background: rgba(20, 20, 24, 0.92);
            border: 1px solid #333;
            border-radius: 0.8vh;
            padding: 1.5vh;
            display: flex;
            flex-direction: column;
            gap: 1.5vh;
            z-index: 40;
            overflow-y: auto;
            pointer-events: auto;
            box-shadow: 0 10px 25px rgba(0,0,0,0.45);
        }
        .info-panel-placeholder {
            color: #888;
            font-size: 1.8vh;
            line-height: 1.4;
        }
        .info-panel-header {
            display: flex;
            gap: 1.5vh;
            align-items: flex-start;
        }
        .info-card-preview {
            flex: 0 0 auto;
            pointer-events: none;
        }
        .info-card-preview .card {
            width: calc(var(--hand-card-w) * 1.25);
            height: calc(var(--hand-card-h) * 1.25);
            transform: none;
            pointer-events: none;
        }
        .info-panel-details {
            display: flex;
            flex-direction: column;
            gap: 1.2vh;
            flex: 1;
        }
        .info-panel-title {
            font-family: var(--font-title);
            font-size: 2vh;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #fff;
        }
        .info-panel-title.ult {
            color: var(--util);
        }
        .info-panel-text {
            font-size: 1.7vh;
            color: #dcdce2;
            line-height: 1.35;
        }
        .info-panel-divider {
            border: none;
            border-top: 1px solid #333;
            margin: 0;
        }
        .info-status-title {
            font-family: var(--font-title);
            font-size: 1.8vh;
            text-transform: uppercase;
            color: #ccc;
        }
        .info-status-list {
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 0.8vh;
            margin-top: 0.6vh;
        }
        .info-status-item {
            font-size: 1.6vh;
            color: #e1e1e6;
            line-height: 1.3;
        }
        .log-entry { margin-bottom: 0.8vh; padding-bottom: 0.4vh; border-bottom: 1px solid rgba(255,255,255,0.1); opacity: 0; animation: fadeIn 0.3s forwards; line-height: 1.3; font-size: inherit; }
        .log-entry span { font-weight: bold; }
        @keyframes fadeIn { to { opacity: 1; } }

        /* M√£o Oponente */
        .opponent-hand { height: 10vh; flex-shrink: 0; background: rgba(0,0,0,0.3); display: flex; justify-content: center; align-items: center; position: relative; z-index: 50; width: 100%; }
        .opponent-hand .card { width: var(--board-card-w); height: var(--board-card-h); transform: scale(0.5); margin: 0 -2vh; background: #111 !important; border: 1px solid #000 !important; box-shadow: none !important; }
        .opponent-hand .card .card-inner { border: none !important; box-shadow: none !important; }
        .opponent-hand .card .card-inner.deck-visual { width: 100%; height: 100%; border-radius: 0.6vh; background: repeating-linear-gradient(45deg, #1a1a1a, #1a1a1a 10px, #222 10px, #222 20px) !important; }

        /* Tabuleiro */
        #battlefield { flex: 1; display: flex; justify-content: center; align-items: center; gap: 0.5vh; padding-top: 3vh; background:
            radial-gradient(circle at 50% 40%, rgba(80, 120, 255, 0.12), transparent 55%),
            radial-gradient(circle at 20% 80%, rgba(4, 211, 97, 0.12), transparent 60%),
            linear-gradient(135deg, rgba(255,255,255,0.04) 0%, rgba(255,255,255,0) 45%),
            radial-gradient(circle at center, #2a2a30 0%, #09090a 100%);
            position: relative; z-index: 10; overflow: hidden; }
        #battlefield::before {
            content: "";
            position: absolute;
            inset: 0;
            background:
                repeating-linear-gradient(45deg, rgba(255,255,255,0.02), rgba(255,255,255,0.02) 6px, rgba(255,255,255,0.01) 6px, rgba(255,255,255,0.01) 12px);
            opacity: 0.4;
            pointer-events: none;
        }
        #battlefield::after {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, rgba(0,0,0,0) 45%, rgba(0,0,0,0.75) 100%);
            pointer-events: none;
        }
        .side-panel { width: 10vh; height: 100%; display: flex; flex-direction: column; justify-content: center; padding-top: 0; gap: 2vh; margin-right: 2vh; margin-left: 0vh; transform: translateY(-1.5vh); }
        .deck, .graveyard { width: var(--board-card-w); height: var(--board-card-h); border: 1px solid #555; border-radius: 0.8vh; display: flex; justify-content: center; align-items: center; font-family: var(--font-title); font-size: var(--font-sm); background: rgba(255,255,255,0.05); color: #888; transform: scale(0.9); }
        .deck-visual { background: repeating-linear-gradient(45deg, #1a1a1a, #1a1a1a 10px, #222 10px, #222 20px), linear-gradient(to bottom, #333, #000); border: 1px solid #666; box-shadow: 1px 1px 0 #333, 2px 2px 0 #222, 3px 3px 0 #333, 4px 4px 0 #222, 0 0 15px rgba(0,0,0,0.8); cursor: pointer; }
        .deck-draw-mode { border: 2px solid var(--gold); box-shadow: 0 0 18px rgba(255, 170, 0, 0.7); animation: deckPulse 1.1s ease-in-out infinite; cursor: pointer; }
        @keyframes deckPulse {
            0%, 100% { transform: scale(0.9); filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.6)); }
            50% { transform: scale(0.98); filter: drop-shadow(0 0 14px rgba(255, 215, 0, 0.9)); }
        }
        .graveyard-filled { background: repeating-linear-gradient(45deg, #1a1a1a, #1a1a1a 10px, #222 10px, #222 20px), linear-gradient(to bottom, #333, #000); border: 1px solid #555; }
        .graveyard-filled::after { content: "X"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 8vh; color: rgba(255, 0, 0, 0.7); font-weight: bold; }
        .graveyard { cursor: pointer; }

        /* --- Graveyard Overlay --- */
        #graveyard-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(10, 10, 15, 0.55);
            backdrop-filter: blur(6px);
            z-index: 5000;
        }
        /* --- L-16 Overlays --- */
        #dice-overlay,
        #suit-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 6200;
        }
        #dice-overlay {
            pointer-events: none;
        }
        .dice-roll {
            width: 14vh;
            height: 14vh;
            border-radius: 2vh;
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 30px rgba(130, 87, 230, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.6vh;
            animation: dicePop 0.6s ease-out;
        }
        .dice-icon {
            font-size: 4vh;
        }
        .dice-number {
            font-family: var(--font-title);
            font-size: 4.4vh;
            color: var(--gold);
            text-shadow: 0 0 12px rgba(255, 215, 0, 0.6);
        }
        @keyframes dicePop {
            0% { transform: scale(0.6) rotate(-10deg); opacity: 0; }
            60% { transform: scale(1.1) rotate(6deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        #suit-overlay {
            background: rgba(10, 10, 15, 0.55);
            backdrop-filter: blur(6px);
            pointer-events: auto;
        }
        .suit-modal {
            background: rgba(18, 18, 24, 0.95);
            border: 1px solid #444;
            border-radius: 2vh;
            padding: 3vh 4vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2vh;
            box-shadow: 0 0 35px rgba(0,0,0,0.7);
        }
        .suit-title {
            font-family: var(--font-title);
            font-size: 2.2vh;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .suit-hand {
            display: flex;
            gap: 2vh;
            position: relative;
        }
        .suit-card {
            width: 10vh;
            height: 14vh;
            border-radius: 1.2vh;
            background: linear-gradient(135deg, #2a2a35, #1b1b24);
            border: 2px solid rgba(255,255,255,0.15);
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4vh;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .suit-card:hover {
            transform: translateY(-0.6vh) scale(1.05);
            box-shadow: 0 12px 24px rgba(0,0,0,0.7);
        }
        .suit-card.revealed {
            background: linear-gradient(135deg, #14141c, #2a2a35);
            border-color: rgba(255,255,255,0.35);
        }
        .suit-hand-icon {
            position: absolute;
            top: -2.5vh;
            right: -2vh;
            font-size: 2.6vh;
            animation: handWave 1.1s ease-in-out infinite;
        }
        @keyframes handWave {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-0.6vh); }
        }
        .graveyard-modal {
            width: min(120vh, 92vw);
            max-height: 82vh;
            background: rgba(20, 20, 26, 0.95);
            border: 1px solid #444;
            border-radius: 1.2vh;
            padding: 2vh;
            box-shadow: 0 0 40px rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            gap: 1.5vh;
        }
        .graveyard-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 2vh;
        }
        .graveyard-modal-title {
            font-family: var(--font-title);
            font-size: 2.4vh;
            text-transform: uppercase;
        }
        .graveyard-modal-actions {
            display: flex;
            gap: 1vh;
        }
        .graveyard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(var(--board-card-w), 1fr));
            gap: 1.5vh;
            overflow-y: auto;
            padding-right: 0.5vh;
        }
        .graveyard-grid .card {
            width: var(--board-card-w);
            height: var(--board-card-h);
            margin: 0;
            cursor: pointer;
        }
        .graveyard-card-disabled {
            opacity: 0.35;
            filter: grayscale(0.8);
            cursor: not-allowed;
        }
        .graveyard-card-eligible {
            outline: 2px solid #39ff14;
            box-shadow: 0 0 12px rgba(57, 255, 20, 0.4);
        }
        .graveyard-section-title {
            font-family: var(--font-title);
            font-size: 1.7vh;
            color: var(--gray);
            text-transform: uppercase;
            margin-bottom: 0.5vh;
        }
        #board-grid { display: grid; grid-template-rows: repeat(4, 1fr); gap: 0.8vh; width: auto; max-width: 95vw; max-height: 55vh; aspect-ratio: 5/4; margin: 0; transform: translateY(-8vh); }
        .row { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5vh; padding: 0.2vh; border-radius: 0.5vh; }
        .slot { display: flex; justify-content: center; align-items: center; transition: all 0.2s; position: relative; width: var(--board-card-w); height: var(--board-card-h); border-radius: 0.8vh; background: rgba(0,0,0,0.2); box-shadow: inset 0 0 10px #000, 0 6px 18px rgba(0,0,0,0.35); }
        #row-0 .slot { border: 1px solid rgba(255, 0, 0, 0.2); }
        #row-1 .slot { border: 1px solid rgba(255, 0, 0, 0.4); background: rgba(255,0,0,0.05); }
        #row-2 .slot { border: 1px solid rgba(0, 255, 255, 0.4); background: rgba(0,255,255,0.05); }
        #row-3 .slot { border: 1px solid rgba(0, 255, 255, 0.2); }
        .slot:hover { border-color: #fff; }
        .slot.valid-summon-zone,
        .slot.valid-target-zone {
            animation: slotPulse 1.2s ease-in-out infinite;
            background: rgba(0, 255, 255, 0.08);
        }
        @keyframes slotPulse {
            0%, 100% { box-shadow: inset 0 0 12px rgba(0,255,255,0.25), 0 0 12px rgba(0,255,255,0.25); }
            50% { box-shadow: inset 0 0 16px rgba(255,255,255,0.35), 0 0 16px rgba(0,255,255,0.45); }
        }

        /* M√£o Jogador */
        .player-hand { height: 21vh; flex-shrink: 0; background: linear-gradient(to top, #09090a 10%, transparent); display: flex; justify-content: center; align-items: flex-end; padding-bottom: 0.5vh; gap: -2vh; position: relative; z-index: 100; }
        .player-hand .card { width: var(--hand-card-w); height: var(--hand-card-h); margin: 0 -2.5vh; transform-origin: bottom center; transition: transform 0.25s cubic-bezier(0.2, 0.8, 0.2, 1), margin 0.2s, box-shadow 0.2s; position: relative; perspective: 900px; }
        .player-hand .card:nth-child(1) { z-index: 20; } .player-hand .card:nth-child(2) { z-index: 19; } .player-hand .card:nth-child(3) { z-index: 18; } .player-hand .card:nth-child(4) { z-index: 17; } .player-hand .card:nth-child(5) { z-index: 16; } .player-hand .card:nth-child(6) { z-index: 15; } .player-hand .card:nth-child(7) { z-index: 14; } .player-hand .card:nth-child(8) { z-index: 13; } .player-hand .card:nth-child(9) { z-index: 12; } .player-hand .card:nth-child(10) { z-index: 11; }
        .player-hand .card:hover {
            transform: scale(1.75);
            z-index: 100 !important;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }

        /* Visual da Carta Pequena (Normal) */
        .card { overflow: visible !important; border-radius: 1vh; position: relative; background: #1a1a1c !important; display: flex; flex-direction: column; cursor: pointer; transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, filter 0.2s ease-in-out; box-shadow: 0 4px 10px rgba(0,0,0,0.5) !important; padding: 0.4vh; border: none !important; transform-style: preserve-3d; }
        .card.fx-press .card-inner { transform: rotateX(var(--tilt-x, 0deg)) rotateY(var(--tilt-y, 0deg)) scale(0.97); }
        .slot .card { width: 100%; height: 100%; transform: scale(1); z-index: 10; }
        .slot .card:hover { transform: scale(1.55); z-index: 999 !important; box-shadow: 0 20px 40px rgba(0,0,0,0.95); }
        .card-inner { position: relative; width: 100%; height: 100%; background: #202024; border-radius: 0.6vh; overflow: hidden; display: flex; flex-direction: column; font-weight: 700; letter-spacing: 0.5px; transform-style: preserve-3d; transition: transform 0.15s ease; }
        .card.fx-tilt .card-inner {
            transform: rotateX(var(--tilt-x, 0deg)) rotateY(var(--tilt-y, 0deg)) translateZ(0);
        }
        /* Remover completamente qualquer overlay de brilho no hover */
        .card .fx-card-overlay {
            display: none !important;
        }
        .card::before,
        .card::after,
        .card-inner::before,
        .card-inner::after,
        .card-art-frame::before,
        .card-art-frame::after,
        .hand-card::before,
        .hand-card::after,
        .board-card::before,
        .board-card::after,
        .inventory-card::before,
        .inventory-card::after,
        .deck-card::before,
        .deck-card::after,
        .card-frame::before,
        .card-frame::after,
        .card-art::before,
        .card-art::after,
        .card-image::before,
        .card-image::after,
        .card-wrap::before,
        .card-wrap::after,
        .card-container::before,
        .card-container::after,
        .slot-card::before,
        .slot-card::after,
        .tcg-card::before,
        .tcg-card::after,
        .builder-card-visual::before,
        .builder-card-visual::after,
        .arena-card-display::before,
        .arena-card-display::after {
            content: none !important;
            display: none !important;
            background: transparent !important;
            opacity: 0 !important;
        }
        .card .overlay,
        .card .hover-overlay,
        .card .shine,
        .card .gloss,
        .card .rarity-layer,
        .card .fx-layer,
        .card .card-filter,
        .card .card-tint,
        .hand-card .overlay,
        .board-card .overlay,
        .inventory-card .overlay,
        .deck-card .overlay,
        .slot-card .overlay,
        .builder-card-visual .overlay,
        .arena-card-display .overlay {
            display: none !important;
        }
        .card-art-frame {
            z-index: 5;
        }
        .card-img {
            position: relative;
            z-index: 6;
        }
        .card.common { background: linear-gradient(to bottom, #444, #222) !important; }
        .card.common .card-inner { border: 3px solid var(--r-common); }
        .card.common .card-top-header, .card.common .card-info-box { background: linear-gradient(90deg, #333, #555, #333); color: #fff; border-bottom: 1px solid var(--r-common); }
        .card.common .card-info-box { border-bottom: none; border-top: 1px solid var(--r-common); }
        .card.rare { background: linear-gradient(to bottom, #966700, #4a3400) !important; }
        .card.rare .card-inner { border: 3px solid var(--r-rare); box-shadow: inset 0 0 10px rgba(255, 170, 0, 0.3); }
        .card.rare .card-top-header, .card.rare .card-info-box { background: linear-gradient(90deg, #b37700, #e69900, #b37700); color: #fff; border-bottom: 1px solid var(--r-rare); }
        .card.rare .card-info-box { border-bottom: none; border-top: 1px solid var(--r-rare); }
        .card.legendary { background: linear-gradient(to bottom, #FFD700, #FFD700) !important; }
        .card.legendary .card-inner { border: 3px solid var(--r-legendary); box-shadow: inset 0 0 15px rgba(0, 255, 255, 0.4); }
        .card.legendary .card-top-header, .card.legendary .card-info-box { background: linear-gradient(30deg, #FFD700, #EEE8AA, #FFD700); color: #000; font-weight: 900; border-bottom: 1px solid var(--r-legendary); }
        .card.legendary .card-info-box { border-bottom: none; border-top: 1px solid var(--r-legendary); }
        .card.utility { background: linear-gradient(to bottom, #800080, #3a003a) !important; }
        .card.utility .card-inner { border: 3px solid var(--r-utility); }
        .card.utility .card-top-header, .card.utility .card-info-box { background: linear-gradient(90deg, #990099, #d633d6, #990099); color: #fff; border-bottom: 1px solid var(--r-utility); }
        .card.utility .card-info-box { border-bottom: none; border-top: 1px solid var(--r-utility); }

        .card-top-header { position: absolute; top: 0; left: 0; width: 100%; height: 15%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .card-name { font-family: var(--font-title); font-size: 1.28vh; text-transform: uppercase; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 90%; text-align: center; line-height: 1.1; text-shadow: none; font-weight: 700; }
        /* Visual da Carta √âpica */
        .card.epic { background: linear-gradient(to bottom, #00FFFF, #00FFFF) !important; }
        .card.epic .card-inner { border: 3px solid var(--r-epic); box-shadow: 0 0 10px rgba(156, 39, 176, 0.4); }
        .card.epic .card-top-header, .card.epic .card-info-box { 
            background: linear-gradient(30deg, #00FFFF, #00CED1, #E0FFFF); 
            color: #000000; 
            border-bottom: 1px solid var(--r-epic); 
        }
        .card.epic .card-info-box { border-bottom: none; border-top: 1px solid var(--r-epic); }

        /* Container Lateral para Estrelas e PA */
        .card-side-indicators {
            position: absolute;
            top: 16%;
            right: 0vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5vh;
            z-index: 30;
            pointer-events: none;
        }

        /* Estrelas Verticais */
        .card-stars-vertical { 
            font-size: 0.75vh;
            color: #ffd700; 
            text-shadow: 1px 1px 0 #000; 
            margin-bottom: 0.5vh;
            letter-spacing: -2px;
            writing-mode: vertical-rl;
            text-orientation: upright;
            font-weight: bold;
        }

        /* PA Badge */
        .card-pa-badge { 
            position: static !important;
            width: 1.9vh;
            height: 1.9vh; 
            border-radius: 50%; 
            background: #000000; 
            border: 2px solid #707bf7; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            line-height: 0;
            font-family: var(--font-title); 
            font-weight: bold; 
            font-size: 1.1vh; 
            color: #FFD700 !important;
            text-shadow: none; 
            box-shadow: 0 0 5px rgba(0,0,0,0.8); 
        }
        .card-status-badges {
            position: absolute;
            top: 0.4vh;
            left: 0.4vh;
            display: flex;
            flex-direction: column;
            gap: 0.4vh;
            z-index: 40;
            pointer-events: none;
        }
        .card-badge {
            min-width: 2.2vh;
            height: 2.2vh;
            padding: 0 0.4vh;
            border-radius: 0.6vh;
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3vh;
            font-weight: 700;
            color: #fff;
            box-shadow: 0 0 8px rgba(0,0,0,0.5);
        }
        .card-badge.dice {
            color: var(--gold);
        }
        .card-badge.suit {
            color: var(--neon-cyan);
        }
        .card-badge.runa {
            background: rgba(214, 51, 214, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: #fff;
            font-size: 1.3vh;
        }
        .hand-steal-mode .card {
            box-shadow: 0 0 18px rgba(255, 215, 0, 0.6);
            animation: targetPulse 1.2s infinite;
            cursor: pointer;
        }
        .graveyard-select-mode {
            box-shadow: 0 0 18px rgba(255, 215, 0, 0.6);
            animation: targetPulse 1.2s infinite;
            cursor: pointer;
            border-color: #ffd700;
        }

        /* Ajuste para slot (tabuleiro) */
        .slot .card-pa-badge {
            width: 1.6vh;
            height: 1.6vh;
            font-size: 0.8vh;
        }

        /* --- NOVO: √çcone de Arqu√©tipo --- */
        .archetype-icon {
            position: absolute;
            top: 0.4vh;
            left: 0.2vh;
            width: 2.5vh; /* Tamanho base (M√£o) */
            height: 2.5vh;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 25; /* Acima da arte */
        }

        /* SVG interno do √≠cone */
        .archetype-icon img {
            width: 75%; 
            height: 75%;
            object-fit: contain;
            border-radius: 50%;
        }

        /* Escala no Tabuleiro (Slot): +25% */
        .slot .archetype-icon {
            transform: scale(1.25);
            transform-origin: top left;
        }

        /* Escala no Modal: +100% (Dobro) */
        .modal-visual-card .archetype-icon {
            transform: scale(3.0);
            transform-origin: top left;
            top: 12vh;
            left: 1.5vh;
        }
        /* ------------------------------- */

        .card-art-frame { position: absolute; top: 15%; left: 0; width: 100%; height: 70%; background: #000; overflow: hidden; }
        .card-img { width: 100%; height: 100%; object-fit: cover; transition: transform 0.5s; }
        .card:hover .card-img { transform: scale(1.1); }

        .card-info-box { position: absolute; top: 75%; left: 0; width: 100%; height: 12%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 77; }
        .card-tribe { font-size: 1.4vh; text-transform: uppercase; font-weight: 800; color: inherit; padding-left: 0vh; }
        .card-desc { display: none; }
        .card-footer-stats { position: absolute; bottom: 0; left: 0; width: 100%; height: 15%; background: #000; display: flex; justify-content: space-evenly; align-items: center; border-top: 0.5px solid #000000; z-index: 20; }
        .stat-item { display: flex; align-items: center; gap: 0.3vh; font-family: var(--font-title); font-size: 1.4vh; font-weight: 800; text-shadow: none; }
        .stat-icon { font-size: 1.2vh; }
        .stat-atk { color: #ffffff !important; } .stat-hp { color: #ff3333 !important; } .stat-def { color: #006400 !important; }
        .slot .card-name { font-size: 1.3vh; text-align: center; width: 100%; }

        .slot .card-art-frame { height: 62%; top: 15%; }
        .slot .card-footer-stats { height: 23%; bottom: 0; background: rgba(0,0,0,0.95); align-items: flex-end; padding-bottom: 0.5vh; }
        .slot .stat-item { flex-direction: column; font-size: 1.4vh; line-height: 0.9; }
        .slot .stat-icon { font-size: 1.2vh; margin-bottom: 0.2vh; }
        .slot .card-info-box { display: none; }

        .external-hp-bar { position: absolute; bottom: -0.6vh; left: 10%; width: 80%; height: 0.6vh; background: #333; border: 1px solid #000; border-radius: 2px; z-index: 25; box-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .external-hp-fill { height: 100%; background: var(--secondary); border-radius: 2px; transition: width 0.3s; }
        .external-shield-bar { position: absolute; bottom: -1.4vh; left: 12%; width: 76%; height: 0.4vh; background: rgba(20, 40, 60, 0.7); border: 1px solid #0b1b2a; border-radius: 2px; z-index: 24; box-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .external-shield-fill { height: 100%; background: #4da6ff; border-radius: 2px; }
        .shield-indicator {
            position: absolute;
            bottom: 3.8vh;
            right: 0.6vh;
            background: rgba(20, 30, 45, 0.85);
            color: #bfe1ff;
            font-size: 1.2vh;
            padding: 0.2vh 0.6vh;
            border-radius: 0.5vh;
            display: flex;
            align-items: center;
            gap: 0.3vh;
            border: 1px solid rgba(77, 166, 255, 0.6);
            z-index: 26;
        }
        .shield-indicator .shield-icon { font-size: 1.2vh; }
        .necro-label {
            position: absolute;
            top: 16%;
            left: 0.4vh;
            right: 0.4vh;
            text-align: center;
            font-size: 1.1vh;
            color: #d9cfff;
            background: rgba(40, 30, 60, 0.75);
            border: 1px solid rgba(130, 87, 230, 0.6);
            border-radius: 0.5vh;
            padding: 0.2vh 0.4vh;
            z-index: 30;
        }

        .hud-star {
            font-size: 1.25em; 
            vertical-align: middle;
            margin-right: 0.3vh;
        }

        /* --- ANIMA√á√ïES --- */
        @keyframes shake { 0% { transform: translate(0, 0); } 25% { transform: translate(-3px, 0); } 50% { transform: translate(3px, 0); } 75% { transform: translate(-3px, 0); } 100% { transform: translate(0, 0); } }
        .anim-shake { animation: shake 0.4s; }
        @keyframes screenShake { 0% { transform: translate(0, 0); } 10% { transform: translate(-15px, 10px); } 30% { transform: translate(15px, -10px); } 50% { transform: translate(-10px, 5px); } 70% { transform: translate(10px, -5px); } 100% { transform: translate(0, 0); } }
        .screen-shake { animation: screenShake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes fireProjectile { 0% { left: 25%; opacity: 0; transform: translate(-50%, -50%) scale(0.5); } 10% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 90% { opacity: 1; } 100% { left: 75%; opacity: 0; transform: translate(-50%, -50%) scale(1.5); } }
        .projectile-div { position: absolute; top: 50%; left: 25%; border-radius: 50%; pointer-events: none; z-index: 3005; transform: translate(-50%, -50%); }
        .projectile-basic { width: 5vh; height: 5vh; background: radial-gradient(circle, #ffaa00 30%, #ff4400 100%); box-shadow: 0 0 20px #ffaa00; animation: fireProjectile 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards; }
        .projectile-skill { width: 8vh; height: 8vh; background: radial-gradient(circle, #00ffff 20%, #0055ff 100%); box-shadow: 0 0 30px #00ffff; animation: fireProjectile 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards; }
        .projectile-ult { width: 12vh; height: 12vh; background: radial-gradient(circle, #fff 10%, #d633d6 50%, #4b0082 100%); box-shadow: 0 0 50px #d633d6, 0 0 20px #fff; border: 2px solid #fff; animation: fireProjectile 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards; }
        .particle { position: fixed; width: 6px; height: 6px; border-radius: 50%; pointer-events: none; z-index: 9999; animation: explode 0.6s ease-out forwards; }
        @keyframes explode { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; } }
        .fx-hit-flash {
            animation: hitFlash 0.25s ease;
        }
        @keyframes hitFlash {
            0% { filter: brightness(1); box-shadow: 0 0 0 rgba(255,255,255,0); }
            50% { filter: brightness(1.6); box-shadow: 0 0 22px rgba(255,255,255,0.7); }
            100% { filter: brightness(1); box-shadow: 0 0 0 rgba(255,255,255,0); }
        }
        .fx-particle {
            position: fixed;
            width: 0.8vh;
            height: 0.8vh;
            border-radius: 50%;
            pointer-events: none;
            background: radial-gradient(circle, rgba(255,255,255,0.9), rgba(255,255,255,0));
            box-shadow: 0 0 8px rgba(255,255,255,0.7);
            animation: fxParticle 0.6s ease-out forwards;
        }
        @keyframes fxParticle {
            from { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            to { transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(0.2); opacity: 0; }
        }
        .fx-trail {
            position: fixed;
            width: 1.2vh;
            height: 1.2vh;
            border-radius: 50%;
            pointer-events: none;
            background: radial-gradient(circle, rgba(0,255,255,0.85), rgba(0,255,255,0));
            filter: blur(0.2vh);
            animation: fxTrail 0.35s ease-out forwards;
        }
        @keyframes fxTrail {
            from { transform: translate(-50%, -50%) scale(1); opacity: 0.9; }
            to { transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(0.3); opacity: 0; }
        }
        .fx-ring {
            position: fixed;
            width: 14vh;
            height: 14vh;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.6);
            box-shadow: 0 0 25px rgba(255,255,255,0.6);
            pointer-events: none;
            animation: fxRing 0.45s ease-out forwards;
        }
        @keyframes fxRing {
            from { transform: translate(-50%, -50%) scale(0.3); opacity: 0.9; }
            to { transform: translate(-50%, -50%) scale(1.3); opacity: 0; }
        }
        .fx-heart {
            position: fixed;
            font-size: 2vh;
            pointer-events: none;
            animation: fxHeart 1.1s ease-out forwards;
            filter: drop-shadow(0 0 6px rgba(57,255,20,0.6));
        }
        @keyframes fxHeart {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 1; }
            to { transform: translate(-50%, -120%) scale(1.2); opacity: 0; }
        }
        .fx-rune {
            position: fixed;
            font-size: 1.8vh;
            pointer-events: none;
            animation: fxRune 0.9s ease-out forwards;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255,215,0,0.6);
        }
        @keyframes fxRune {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 1; }
            to { transform: translate(-50%, -140%) scale(1.1); opacity: 0; }
        }
        .fx-debuff {
            position: fixed;
            width: 1.2vh;
            height: 1.2vh;
            border-radius: 50%;
            pointer-events: none;
            background: radial-gradient(circle, rgba(179,0,255,0.85), rgba(60,0,80,0));
            animation: fxDebuff 0.7s ease-out forwards;
        }
        @keyframes fxDebuff {
            from { transform: translate(-50%, -50%) scale(0.9); opacity: 1; }
            to { transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(0.1); opacity: 0; }
        }
        .fx-card-overlay {
            position: absolute;
            inset: 0;
            border-radius: 1vh;
            pointer-events: none;
            mix-blend-mode: screen;
        }
        .fx-intercept::before,
        .fx-pacifist::before {
            content: "";
            position: absolute;
            inset: -0.2vh;
            border-radius: 1vh;
            pointer-events: none;
            border: 1px dashed rgba(180, 200, 255, 0.7);
            box-shadow: 0 0 10px rgba(180,200,255,0.35);
        }
        .fx-intercept::after {
            content: "‚õìÔ∏è";
            position: absolute;
            right: 0.4vh;
            top: 0.4vh;
            font-size: 1.5vh;
            filter: drop-shadow(0 0 6px rgba(200,200,255,0.7));
        }
        .fx-pacifist::after {
            content: "üïäÔ∏è";
            position: absolute;
            right: 0.4vh;
            top: 0.4vh;
            font-size: 1.5vh;
            filter: drop-shadow(0 0 6px rgba(200,200,255,0.7));
        }
        .fx-buff { box-shadow: 0 0 14px rgba(57,255,20,0.35) !important; }
        .fx-debuffed { box-shadow: 0 0 16px rgba(179,0,255,0.35) !important; filter: saturate(0.9); }
        .fx-screen-shake {
            animation: screenShakeSoft 0.35s ease;
        }
        @keyframes screenShakeSoft {
            0% { transform: translate(0); }
            20% { transform: translate(-6px, 3px); }
            40% { transform: translate(5px, -4px); }
            60% { transform: translate(-3px, 5px); }
            80% { transform: translate(4px, -2px); }
            100% { transform: translate(0); }
        }
        .fx-ult-impact {
            animation: ultImpact 0.3s ease;
        }
        @keyframes ultImpact {
            0% { filter: blur(0px) brightness(1); }
            40% { filter: blur(2px) brightness(1.25); }
            100% { filter: blur(0px) brightness(1); }
        }
        @keyframes targetPulse { 0% { box-shadow: inset 0 0 10px #ffd700; border-color: #ffd700; } 50% { box-shadow: inset 0 0 30px #ffd700, 0 0 10px #ffd700; border-color: #fff; background: rgba(255, 215, 0, 0.2); } 100% { box-shadow: inset 0 0 10px #ffd700; border-color: #ffd700; } }
        .slot.valid-summon-zone { box-shadow: inset 0 0 20px var(--neon-green), 0 0 16px rgba(57,255,20,0.35); border: 1px dashed var(--neon-green) !important; cursor: pointer !important; z-index: 1000 !important; pointer-events: auto !important; }
        .slot.valid-target-zone { animation: targetPulse 1.2s infinite; border: 2px dashed #ffd700 !important; cursor: crosshair !important; z-index: 1000 !important; pointer-events: auto !important; }
        .flying-card { position: fixed; z-index: 9999; pointer-events: none; transition: top 0.6s ease-in-out, left 0.6s ease-in-out, transform 0.6s ease-in-out, opacity 0.6s; box-shadow: 0 0 30px rgba(255, 255, 255, 0.3); }
        #overlay, #rps-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 2000; backdrop-filter: blur(0px); }
        #overlay.overlay-open, #rps-overlay.overlay-open, #builder-overlay.overlay-open {
            animation: overlayFadeIn 0.25s ease forwards;
        }
        #overlay.overlay-open .modal-card,
        #builder-overlay.overlay-open .modal-card {
            animation: modalPop 0.25s ease forwards;
        }
        @keyframes overlayFadeIn {
            from { opacity: 0; backdrop-filter: blur(0px); }
            to { opacity: 1; backdrop-filter: blur(6px); }
        }
        @keyframes modalPop {
            from { opacity: 0; transform: scale(0.92); filter: blur(6px); }
            to { opacity: 1; transform: scale(1); filter: blur(0); }
        }

        .modal-card { 
            display: flex; 
            flex-direction: row; 
            align-items: center; 
            gap: 2vh; 
            width: auto; 
            max-width: 98vw; 
            background: transparent; 
            border: none; 
            padding: 0; 
            z-index: 2001; 
        }

        .modal-visual-card { 
            width: 65.31vh; 
            height: 85vh; 
            border-radius: 3vh; 
            position: relative; 
            display: flex; 
            flex-direction: column; 
            padding: 0.8vh; 
            box-shadow: 0 0 50px rgba(0,0,0,0.95); 
            overflow: hidden; 
            transform: translateY(-7vh);
        }

        .modal-visual-card.common { background: linear-gradient(to bottom, #444, #222); }
        .modal-visual-card.rare { background: linear-gradient(to bottom, #966700, #4a3400); }
        .modal-visual-card.legendary { background: linear-gradient(to bottom, #FFD700, #FFD700); }
        .modal-visual-card.utility { background: linear-gradient(to bottom, #800080, #3a003a); }
        .modal-visual-card.epic { background: linear-gradient(to bottom, #00FFFF, #00FFFF); }

        .modal-inner { width: 100%; height: 100%; background: #202024; border-radius: 1vh; overflow: hidden; display: flex; flex-direction: column; position: relative; }
        .modal-visual-card.common .modal-inner { border: 1px solid var(--r-common); }
        .modal-visual-card.rare .modal-inner { border: 1px solid var(--r-rare); box-shadow: inset 0 0 15px rgba(255, 170, 0, 0.2); }
        .modal-visual-card.legendary .modal-inner { border: 1px solid var(--r-legendary); box-shadow: inset 0 0 20px rgba(0, 255, 255, 0.3); }
        .modal-visual-card.utility .modal-inner { border: 1px solid var(--r-utility); }

        .modal-art-frame { 
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            z-index: 0; 
            background: #000; 
            display: flex; justify-content: center; align-items: center; 
        }
        .modal-art-img { 
            width: 100%; height: 100%; 
            object-fit: contain; 
            object-position: center; 
            opacity: 0.9; 
        }

        .modal-header { 
            position: relative; 
            z-index: 2; 
            height: 12%; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            color: #fff; text-transform: uppercase; 
            background: linear-gradient(to bottom, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.5) 100%); 
            backdrop-filter: blur(2px);
            text-shadow: 2px 2px 4px #000;
        }
        .modal-visual-card.common .modal-header { color: #00ffff; font-weight: 900; border-bottom: 10px solid rgb(255, 255, 255); }
        .modal-visual-card.rare .modal-header { color: #00ffff; font-weight: 900; border-bottom: 10px solid rgb(255, 255, 255); }
        .modal-visual-card.legendary .modal-header { color: #ffffff; font-weight: 900; border-bottom: 10px solid rgb(255, 255, 255); }
        .modal-visual-card.epic .modal-header { color: #00ffff; font-weight: 900; border-bottom: 10px solid rgb(255, 255, 255); }
        .modal-visual-card.utility .modal-header { color: #00ffff; font-weight: 900; border-bottom: 10px solid rgb(255, 255, 255); }

        .modal-name { font-family: var(--font-title); font-size: 3vh; font-weight: bold; letter-spacing: 1px; margin-top: -5vh;}
        .modal-stars {position: absolute; font-size: 2vh; color: #ffd700; text-shadow: 1px 1px 2px #000; Top: 3.5vh; }

        .modal-text-area { 
            position: absolute; 
            bottom: 0; left: 0; width: 100%; 
            z-index: 2; 
            display: flex; flex-direction: column; 
            padding: 3vh 1.5vh 1.5vh 1.5vh; 
            gap: 0.5vh; 
            justify-content: flex-end;
            background: linear-gradient(to top, #000 10%, rgba(0,0,0,0.9) 60%, transparent 100%); 
        }

        .modal-stats-row { display: flex; justify-content: space-around; padding-bottom: 0.5vh; border-bottom: 1px solid rgba(255,255,255,0.2); }

        .modal-stat { 
            font-size: 3.5vh; 
            font-weight: bold; 
            font-family: var(--font-title); 
            display: flex; 
            align-items: center; 
            gap: 0.5vh; 
            text-shadow: 2px 2px 0 #000; 
        }

        /* Cores Stats Modal */
        .modal-stats-row .modal-stat:nth-child(1) { color: #ffffff !important; }
        .modal-stats-row .modal-stat:nth-child(2) { color: #ff3333 !important; }
        .modal-stats-row .modal-stat:nth-child(3) { color: #006400 !important; }

        .modal-desc-box { 
            background: rgba(0, 0, 0, 0.6); 
            border: 1px solid rgba(255, 255, 255, 0.15); 
            border-radius: 2px; padding: 2vh; 
            display: flex;
            flex-direction: column;
            align-items: flex-start;  /* Garante o alinhamento √† esquerda */
            justify-content: flex-start; /* Move o conte√∫do para o topo da caixa */
            text-align: left;         /* Alinha as linhas de texto √† esquerda */
            padding: 0.5vh;
            backdrop-filter: blur(4px);
        }
        .modal-label { font-size: 1.2vh; color: #aaa; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        .modal-text { 
            font-size: 1.8vh; 
            color: #fff; 
            line-height: 1.1; 
            text-shadow: 1px 1px 2px #000; 
        }
        .modal-subtext {
            position: absolute;
            top: -272%; /* Coloca logo abaixo das estrelas no cabe√ßalho */
            left: 0;
            width: 100%;
            font-size: 1.2vh;
            color: #aaa;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            z-index: 5;
        }

        .modal-actions-panel { width: 25vh; background: rgba(20, 20, 24, 0.9); border: 1px solid #444; border-radius: 12px; padding: 2vh; display: flex; flex-direction: column; justify-content: center; gap: 1.5vh; backdrop-filter: blur(10px); box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .modal-actions-panel h3 { text-align: center; color: #fff; margin-bottom: 1vh; font-family: var(--font-title); text-transform: uppercase; letter-spacing: 1px; }
        .btn { padding: 1.5vh; border: none; border-radius: 6px; font-family: var(--font-title); font-weight: bold; letter-spacing: 1px; cursor: pointer; transition: transform 0.15s ease, filter 0.15s ease, box-shadow 0.15s ease; font-size: var(--font-sm); color: #fff; text-transform: uppercase; width: 100%; box-shadow: 0 8px 18px rgba(0,0,0,0.4), inset 0 0 0 1px rgba(255,255,255,0.08); }
        .btn:hover:not(:disabled) { transform: translateY(-1px) scale(1.02); filter: brightness(1.1); box-shadow: 0 10px 22px rgba(0,0,0,0.5), 0 0 12px rgba(130,87,230,0.25); }
        .btn:active:not(:disabled) { transform: translateY(0) scale(0.98); filter: brightness(0.95); }
        .btn:disabled { filter: grayscale(0.6) brightness(0.7); box-shadow: none; cursor: not-allowed; }
        .btn:hover { filter: brightness(1.2); transform: translateY(-2px); }
        .btn:disabled { background: #333; color: #666; cursor: not-allowed; transform: none; filter: grayscale(1); }
        .btn-atk { background: var(--danger); }
        .btn-skill { background: var(--primary); }
        .btn-ult { background: linear-gradient(45deg, #ffd700, #ffaa00); color: #000; }
        .btn-cancel { background: #444; }
        .btn-summon { background: var(--secondary); }
        .hud-panel { position: absolute; padding: 1vh 2vh; background: rgba(18, 18, 20, 0.9); border: 1px solid #333; border-radius: 4px; color: #fff; font-family: var(--font-title); letter-spacing: 1px; display: flex; flex-direction: column; gap: 0.5vh; z-index: 50; font-size: var(--font-sm); pointer-events: none; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .hud-panel .hud-pulse {
            animation: hudPulse 0.4s ease;
        }
        @keyframes hudPulse {
            0% { transform: scale(1); color: #fff; }
            50% { transform: scale(1.06); color: var(--gold); }
            100% { transform: scale(1); color: #fff; }
        }
        .sfx-toggle {
            margin-top: 0.6vh;
            padding: 0.4vh 0.8vh;
            font-size: 1.1vh;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(0,0,0,0.4);
            color: #fff;
            cursor: pointer;
            pointer-events: auto;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .sfx-toggle.off { opacity: 0.55; filter: grayscale(1); }
        #hud-opponent { top: 2vh; left: 2vh; border-left: 0.5vh solid var(--danger); pointer-events: auto; }
        #hud-player { bottom: 26vh; left: 2vh; border-left: 0.5vh solid var(--secondary); } 

        #turn-controls { position: absolute; right: 175vh; top: 70%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; gap: 1.5vh; z-index: 50; }
        .timer-container { position: relative; width: 14vh; height: 14vh; display: flex; justify-content: center; align-items: center; }
        #timer-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: rotate(-90deg); pointer-events: none; }
        .timer-dot { fill: #333; transition: fill 0.2s; }
        .timer-dot.active { fill: var(--gold); filter: drop-shadow(0 0 2px var(--gold)); }
        #btn-pass { width: 8vh; height: 8vh; border-radius: 50%; background: #e1e1e6; color: #121214; font-family: var(--font-title); font-weight: bold; cursor: pointer; border: 3px solid #333; font-size: 1.8vh; z-index: 10; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        #btn-pass:disabled { background: #333; color: #555; cursor: not-allowed; border-color: #222; }
        #timer { display: none; }

        .floating-text { position: absolute; font-family: var(--font-title); font-size: 6vh; font-weight: 900; color: #000 !important; text-shadow: 0 0 10px #fff, -2px -2px 0 #fff, 2px -2px 0 #fff, -2px 2px 0 #fff, 2px 2px 0 #fff; pointer-events: none; animation: floatUp 1s forwards; z-index: 4000; }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-6vh) scale(1.2); opacity: 0; } }
        .anim-draw { animation: drawFromDeck 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes drawFromDeck { 0% { transform: translate(-40vw, -20vh) rotate(-20deg) scale(0.5); opacity: 0; } 100% { transform: translate(0, 0) rotate(0deg) scale(1); opacity: 1; } }
        .rps-btn { width: 10vh; height: 10vh; font-size: 4vh; cursor: pointer; background: #202024; border: 2px solid #444; border-radius: 50%; margin: 1vh; transition: 0.2s; }
        .rps-btn:hover { background: var(--primary); border-color: #fff; transform: scale(1.1); box-shadow: 0 0 15px var(--primary); }
        #arena-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.92); z-index: 3000; display: none; flex-direction: column; justify-content: center; align-items: center; }
        .arena-content { display: flex; align-items: center; justify-content: space-between; width: 80%; height: 60%; position: relative; }
        .arena-card-slot { width: 35vh; height: 50vh; perspective: 1000px; display: flex; flex-direction: column; align-items: center; }
        .arena-visuals { width: 10vh; display: flex; justify-content: center; align-items: center; position: relative; }
        .arena-ally-glow { box-shadow: 0 0 25px var(--neon-cyan); border-color: var(--neon-cyan) !important; }
        .arena-enemy-glow { box-shadow: 0 0 25px var(--neon-red); border-color: var(--neon-red) !important; }
        .board-projectile { position: fixed; width: 3vh; height: 3vh; background: #fff; border-radius: 50%; box-shadow: 0 0 15px #fff, 0 0 30px var(--primary); z-index: 2500; pointer-events: none; transition: top 0.8s linear, left 0.8s linear, transform 0.2s ease-out, opacity 0.2s; }
        /* --- MELEE SWORD VFX (Board + Arena) --- */

        /* --- MELEE SWORD VFX (Board + Arena) --- */
        .board-projectile.melee-sword{
            width: 12vh;
            height: 2.6vh;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            transform-origin: 18% 50%;
            /* no spin during flight */
            animation: none;
            /* directional 3D tilt; angle injected via --angle */
            transform: translate(-50%, -50%) rotateZ(var(--angle, 0deg)) rotateX(22deg) rotateY(-18deg);
            filter:
                drop-shadow(0 8px 14px rgba(0,0,0,0.55))
                drop-shadow(0 0 10px rgba(0, 255, 255, 0.55))
                drop-shadow(0 0 18px rgba(0, 255, 255, 0.35));
        }
        .board-projectile.melee-sword::before{
            content:"";
            position:absolute;
            left: 2.0vh;
            top: 50%;
            width: 9.2vh;
            height: 0.85vh;
            transform: translateY(-50%);
            background: linear-gradient(90deg,
                rgba(245,255,255,0.98),
                rgba(140,255,255,0.92),
                rgba(245,255,255,0.98)
            );
            border-radius: 0.45vh;
            box-shadow:
                0 0 10px rgba(0,255,255,0.75),
                0 0 18px rgba(0,255,255,0.55),
                0 0 28px rgba(0,255,255,0.35);
        }
        /* Glow ‚Äúaura‚Äù around blade */
        .board-projectile.melee-sword::after{
            content:"";
            position:absolute;
            left: 0;
            top: 50%;
            width: 2.2vh;
            height: 1.25vh;
            transform: translateY(-50%);
            background: linear-gradient(90deg, #1b1b1e, #3a3a46);
            border-radius: 0.55vh;
            box-shadow:
                0 0 8px rgba(0,255,255,0.35),
                0 0 14px rgba(0,255,255,0.22);
        }

        /* Slash phase (after arrival) */
        .board-projectile.melee-sword.slash{
            animation: meleeSwordSlash 190ms ease-in-out 1;
        }
        @keyframes meleeSwordSlash{
            0%   { transform: translate(-50%, -50%) rotateZ(var(--angle, 0deg)) rotateX(22deg) rotateY(-18deg) scale(1); filter: blur(0); }
            45%  { transform: translate(-50%, -50%) rotateZ(calc(var(--angle, 0deg) - 90deg)) rotateX(26deg) rotateY(-10deg) scale(1.06); filter: blur(0.6px); }
            100% { transform: translate(-50%, -50%) rotateZ(var(--angle, 0deg)) rotateX(22deg) rotateY(-18deg) scale(1); filter: blur(0); }
        }

        .melee-slash-line{
            position: fixed;
            width: 14vh;
            height: 0.55vh;
            background: rgba(140,255,255,0.95);
            border-radius: 1vh;
            pointer-events: none;
            z-index: 3600;
            opacity: 0;
            filter:
                drop-shadow(0 0 10px rgba(0,255,255,0.75))
                drop-shadow(0 0 18px rgba(0,255,255,0.45));
            transform: translate(-50%, -50%) rotateZ(var(--slash-angle, -25deg));
            animation: meleeSlashLinePop 210ms ease-out 1;
        }
        @keyframes meleeSlashLinePop{
            0%   { opacity: 0; transform: translate(-50%, -50%) rotateZ(var(--slash-angle, -25deg)) scaleX(0.6); }
            40%  { opacity: 1; transform: translate(-50%, -50%) rotateZ(var(--slash-angle, -25deg)) scaleX(1.05); }
            100% { opacity: 0; transform: translate(-50%, -50%) rotateZ(var(--slash-angle, -25deg)) scaleX(1.15); }
        }
100% { transform: rotateZ(720deg) rotateX(22deg) rotateY(-18deg); }
        }


        .arena-sword-vfx{
            position: fixed;
            width: 24vh;
            height: 4.2vh;
            pointer-events: none;
            z-index: 3500;
            transform-origin: 18% 50%;
            filter:
                drop-shadow(0 12px 18px rgba(0,0,0,0.6))
                drop-shadow(0 0 12px rgba(0,255,255,0.6))
                drop-shadow(0 0 26px rgba(0,255,255,0.35));
        }
        .arena-sword-vfx::before{
            content:"";
            position:absolute;
            left: 4.2vh;
            top: 50%;
            width: 18.5vh;
            height: 1.15vh;
            transform: translateY(-50%);
            background: linear-gradient(90deg,
                rgba(245,255,255,0.98),
                rgba(140,255,255,0.92),
                rgba(245,255,255,0.98)
            );
            border-radius: 0.6vh;
            box-shadow:
                0 0 12px rgba(0,255,255,0.85),
                0 0 22px rgba(0,255,255,0.55),
                0 0 36px rgba(0,255,255,0.35);
        }
        .arena-sword-vfx::after{
            content:"";
            position:absolute;
            left: 0;
            top: 50%;
            width: 3.2vh;
            height: 1.7vh;
            transform: translateY(-50%);
            background: linear-gradient(90deg, #1b1b1e, #3a3a46);
            border-radius: 0.85vh;
            box-shadow:
                0 0 10px rgba(0,255,255,0.35),
                0 0 16px rgba(0,255,255,0.22);
        }

        /* --- Arena VFX Layer (must stay above duel cards) --- */
        #arena-overlay{ position: fixed; }
        #arena-vfx-layer{
            position:absolute;
            inset:0;
            z-index: 99999;
            pointer-events:none;
        }
        /* Ensure arena cards stay below the VFX layer */
        #arena-overlay .arena-content,
        #arena-overlay #arena-log,
        #arena-overlay #arena-ok-btn{
            position: relative;
            z-index: 10;
        }

        /* --- Arena Sword Slash VFX (cyan glowing blade, 2x board sword) --- */
        .arena-sword-slash{
            position: fixed;
            width: 24vh;
            height: 6.0vh;
            pointer-events:none;
            z-index: 100000;
            transform-origin: 22% 70%; /* near the hilt */
            filter:
                drop-shadow(0 14px 20px rgba(0,0,0,0.65))
                drop-shadow(0 0 18px rgba(0,255,255,0.90))
                drop-shadow(0 0 34px rgba(0,255,255,0.55))
                drop-shadow(0 0 60px rgba(0,255,255,0.32));
        }
        .arena-sword-slash::before{
            content:"";
            position:absolute;
            left: 4.2vh;
            top: 50%;
            width: 18.6vh;
            height: 1.55vh;
            transform: translateY(-50%);
            background: linear-gradient(90deg,
                rgba(0,255,255,0.85),
                rgba(240,255,255,0.98),
                rgba(0,255,255,0.90)
            );
            /* sword blade with pointed tip */
            clip-path: polygon(0% 22%, 92% 22%, 100% 50%, 92% 78%, 0% 78%);
            border-radius: 0.7vh;
            box-shadow:
                0 0 16px rgba(0,255,255,1.0),
                0 0 30px rgba(0,255,255,0.65),
                0 0 52px rgba(0,255,255,0.40);
        }
        .arena-sword-slash::after{
            content:"";
            position:absolute;
            left: 0.6vh;
            top: 50%;
            width: 3.6vh;
            height: 2.0vh;
            transform: translateY(-50%);
            background: linear-gradient(90deg, #101013, #3a3a46);
            border-radius: 1.0vh;
            box-shadow:
                0 0 12px rgba(0,255,255,0.40),
                0 0 18px rgba(0,255,255,0.22);
        }
        .arena-sword-slash .arena-sword-guard{
            position:absolute;
            left: 3.1vh;
            top: 50%;
            width: 1.4vh;
            height: 2.8vh;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #2b2b33, #0f0f12);
            border-radius: 0.6vh;
            box-shadow: 0 0 14px rgba(0,255,255,0.22);
        }

        .arena-slice-flash{
            position: fixed;
            width: 10vh;
            height: 0.6vh;
            background: rgba(255,255,255,0.9);
            border-radius: 0.6vh;
            pointer-events: none;
            z-index: 3499;
            filter: blur(0.2vh);
            opacity: 0;
            animation: arenaSliceFlash 260ms ease-out forwards;
        }
        @keyframes arenaSliceFlash{
            0% { transform: scaleX(0.3); opacity: 0; }
            30% { transform: scaleX(1); opacity: 0.95; }
            100% { transform: scaleX(1.3); opacity: 0; }
        }

        @keyframes arenaSlideLeft { from { transform: translateX(-100vw); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes arenaSlideRight { from { transform: translateX(100vw); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        #arena-attacker { animation: arenaSlideLeft 0.5s ease-out; }
        #arena-target { animation: arenaSlideRight 0.5s ease-out; }
        .arena-card-display { width: 100%; height: 100%; background: #1e1e24; border: 3px solid #555; border-radius: 1.5vh; overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 0 50px rgba(0,0,0,0.7); }
        .arena-card-display img { width: 100%; height: 60%; object-fit: cover; }
        .arena-card-info { padding: 1vh; color: #fff; text-align: center; }
        .arena-hp-bar { width: 90%; height: 2vh; background: #333; margin-top: 1vh; border-radius: 1vh; overflow: hidden; border: 1px solid #000; }
        .arena-hp-fill { height: 100%; background: var(--secondary); transition: width 0.2s linear; width: 100%; }
        .effect-overlay { position: absolute; top: 50%; left: 50%; width: 20vh; height: 20vh; pointer-events: none; transform: translate(-50%, -50%); z-index: 3001; opacity: 1; }
        #arena-log { margin-top: 2vh; font-family: 'Courier New', monospace; color: var(--gold); font-size: 2vh; height: 4vh; text-shadow: 1px 1px 0 #000; }
        #arena-ok-btn { margin-top: 2vh; padding: 1.5vh 5vh; font-size: 2.5vh; background: var(--primary); color: #fff; border: none; border-radius: 0.5vh; font-family: var(--font-title); cursor: pointer; box-shadow: 0 0 20px rgba(130, 87, 230, 0.5); transition: 0.2s; }
        #arena-ok-btn:hover { transform: scale(1.1); filter: brightness(1.2); }


/* === Skill VFX: Blue Hadouken (global, board + arena) === */
#global-vfx-layer{
  position:fixed;
  inset:0;
  pointer-events:none;
  z-index:999999; /* above board + HUD */
}
.hadouken{
  position:fixed;
  width:52px;
  height:52px;
  border-radius:999px;
  transform:translate(-50%,-50%);
  opacity:0.98;
  z-index:1000000;
  pointer-events:none;
  background:
    radial-gradient(circle at 35% 35%, rgba(255,255,255,0.95) 0%, rgba(210,250,255,0.95) 18%, rgba(40,220,255,0.95) 42%, rgba(0,140,255,0.75) 66%, rgba(0,90,220,0.0) 78%);
  box-shadow:
    0 0 14px rgba(50,230,255,0.85),
    0 0 28px rgba(0,190,255,0.70),
    0 0 46px rgba(0,120,255,0.45);
  filter: drop-shadow(0 0 10px rgba(70,240,255,0.9)) drop-shadow(0 0 18px rgba(0,190,255,0.7));
}
.hadouken::before{
  content:"";
  position:absolute;
  inset:-8px;
  border-radius:inherit;
  background: radial-gradient(circle at 45% 45%, rgba(120,255,255,0.35), rgba(0,170,255,0.0) 70%);
  filter: blur(1.2px);
  opacity:0.9;
  animation: hadoukenPulse 220ms ease-in-out infinite alternate;
}
.hadouken::after{
  /* subtle spinning energy ring */
  content:"";
  position:absolute;
  inset:-10px;
  border-radius:inherit;
  background:
    conic-gradient(from 0deg, rgba(0,255,255,0.00) 0deg, rgba(0,255,255,0.32) 70deg, rgba(255,255,255,0.12) 120deg, rgba(0,255,255,0.00) 220deg, rgba(0,255,255,0.25) 290deg, rgba(0,255,255,0.00) 360deg);
  filter: blur(2px);
  opacity:0.75;
  animation: hadoukenSpin 320ms linear infinite;
}
@keyframes hadoukenPulse{
  from{ transform:scale(0.98); opacity:0.75; }
  to{ transform:scale(1.06); opacity:1; }
}
@keyframes hadoukenSpin{
  from{ transform:rotate(0deg); }
  to{ transform:rotate(360deg); }
}
.hadouken-trail{
  position:fixed;
  width:10px;
  height:10px;
  border-radius:999px;
  transform:translate(-50%,-50%);
  pointer-events:none;
  z-index:999999;
  background: radial-gradient(circle, rgba(140,255,255,0.75), rgba(0,170,255,0.0) 70%);
  box-shadow: 0 0 10px rgba(0,220,255,0.7);
  opacity:0.65;
  filter: blur(0.6px);
}
.hadouken-impact-flash{
  position:fixed;
  width:120px;
  height:120px;
  border-radius:999px;
  transform:translate(-50%,-50%);
  pointer-events:none;
  z-index:1000001;
  background: radial-gradient(circle, rgba(255,255,255,0.70) 0%, rgba(80,245,255,0.55) 28%, rgba(0,190,255,0.25) 55%, rgba(0,120,255,0.00) 75%);
  box-shadow: 0 0 20px rgba(60,240,255,0.8), 0 0 38px rgba(0,190,255,0.65);
  opacity:0;
}

</style>
</head>
<body>

    <!-- SCREEN 1: MAIN MENU -->
    <div id="main-menu" class="screen-section" style="display: flex;">
        <div class="menu-container">
            <div class="game-logo">ETHERIA</div>
            <button class="menu-btn" onclick="alert('Funcionalidade em desenvolvimento!')">Loja</button>
            <button class="menu-btn" onclick="alert('Funcionalidade em desenvolvimento!')">Invent√°rio</button>
            <button class="menu-btn" disabled title="Em breve">PVP (Bloqueado)</button>
            <button class="menu-btn" onclick="navigateTo('builder')">Jogar vs IA</button>
        </div>
    </div>

    <!-- SCREEN 2: DECK BUILDER -->
    <div id="deck-builder-screen" class="screen-section">
        <div class="builder-header">
            <div class="builder-title">INVENT√ÅRIO DE CARTAS</div>
            <div class="builder-controls">
                <div class="deck-counter">DECK: <span id="builder-count" style="color:var(--danger)">0</span> / 50</div>
                <button class="btn btn-skill" style="padding: 1vh 2vh; font-size: 1.5vh;" onclick="autoFillDeck()">SELECIONAR TODAS</button>
                <button id="btn-start-match" class="btn btn-summon" style="padding: 1vh 2vh; font-size: 1.5vh;" disabled onclick="finishDeckBuilder()">INICIAR PARTIDA</button>
                <button class="btn btn-cancel" style="padding: 1vh 2vh; font-size: 1.5vh;" onclick="navigateTo('menu')">VOLTAR</button>
            </div>
        </div>

        <!-- NEW FILTER BAR -->
        <div class="filter-bar">
            <div class="filter-input-wrapper">
                <span class="filter-icon-search">üîç</span>
                <input type="text" id="filter-search" class="filter-input" placeholder="Buscar Carta..." oninput="filterInventory()">
            </div>

            <div class="filter-group">
                <select id="filter-archetype" class="filter-select" onchange="filterInventory()">
                    <option value="all">Arqu√©tipo: Todos</option>
                </select>
            </div>

            <div class="filter-group">
                <select id="filter-rarity" class="filter-select" onchange="filterInventory()">
                    <option value="all">Raridade: Todas</option>
                </select>
            </div>

            <div class="filter-group">
                <select id="filter-tribe" class="filter-select" onchange="filterInventory()">
                    <option value="all">Tribo: Todas</option>
                </select>
            </div>
        </div>
        <!-- END FILTER BAR -->

        <div id="builder-grid"></div>

        <!-- BUILDER SPECIFIC OVERLAY -->
        <div id="builder-overlay"></div>
    </div>

    <!-- SCREEN 3: GAME VIEW -->
    <div id="game-view" class="screen-section">

        <!-- RPS Intro -->
        <div id="rps-overlay" style="display: none; flex-direction: column;">
            <h1 style="color:white; margin-bottom: 20px; font-family: var(--font-title); font-size: 4vh;">QUEM COME√áA?</h1>
            <div id="rps-choices">
                <button class="rps-btn" onclick="playRPS('rock')">‚úä</button>
                <button class="rps-btn" onclick="playRPS('paper')">‚úã</button>
                <button class="rps-btn" onclick="playRPS('scissors')">‚úåÔ∏è</button>
            </div>
            <div id="rps-result" style="font-family: var(--font-title); font-size: 3vh; margin-top: 2vh; color: var(--gold);"></div>
        </div>

        <!-- Arena Cinematogr√°fica -->
        <div id="arena-overlay">
            <div id="arena-vfx-layer" aria-hidden="true"></div>
            <div class="arena-content">
                <div id="arena-attacker" class="arena-card-slot"></div>
                <div class="arena-visuals">
                    <div id="arena-effect-container" class="effect-overlay"></div>
                </div>
                <div id="arena-target" class="arena-card-slot"></div>
            </div>
            <div id="arena-log">O Batalha Come√ßa!</div>
</div>

        <!-- Card Interaction Overlay (Inspection) -->
        <div id="overlay"></div>
        <div id="dice-overlay" aria-hidden="true">
            <div class="dice-roll">
                <div class="dice-icon">üé≤</div>
                <div class="dice-number">1</div>
            </div>
        </div>
        <div id="suit-overlay" aria-hidden="true"></div>
        <div id="graveyard-overlay" aria-hidden="true"></div>

        <div id="game-container">
            <!-- Opponent Hand -->
            <div class="hand-area opponent-hand" id="opp-hand"></div>

            <!-- Battlefield with Logs -->
            <div id="battlefield">
                <div id="log-player" class="battle-log"></div>
                <div id="info-panel" class="info-panel">
                    <div class="info-panel-placeholder">Clique com o bot√£o direito em uma carta no campo para ver detalhes.</div>
                </div>

                <!-- Painel Esquerdo -->
                <div class="side-panel">
                    <div class="deck deck-visual" id="opp-deck">DECK</div>
                    <div class="deck deck-visual" id="player-deck">DECK</div>
                </div>

                <!-- Grid -->
                <div id="board-grid"></div>

                <!-- Painel Direito -->
                <div class="side-panel">
                    <div class="graveyard" id="opp-gy">Opp GY</div>
                    <div class="graveyard" id="player-gy">Seu GY</div>
                </div>
            </div>

            <!-- HUDs -->
            <div id="hud-opponent" class="hud-panel">
                <span style="color: var(--danger)">OPONENTE (AI)</span>
                <span id="opp-hp-display">HP: 1000</span>
                <span id="opp-def-display">DEF: 20</span>
                <span id="opp-pi-display">‚≠ê PI: 5</span>
            </div>

            <div id="hud-player" class="hud-panel">
                <span style="color: var(--secondary)">VOC√ä</span>
                <span id="player-hp-display">HP: 1000</span>
                <span id="player-def-display">DEF: 20</span>
                <span id="player-pi-display">‚≠ê PI: 5</span>
                <span id="turn-info" style="font-size: var(--font-xs); color:#aaa;">Turno: 0</span>
                <button id="sfx-toggle" class="sfx-toggle off">SOM: OFF</button>
            </div>

            <!-- Turn Controls (Temporizador Circular) -->
            <div id="turn-controls">
                <div id="turn-indicator" style="color:#fff; font-family: var(--font-title); font-size: var(--font-sm);">AGUARDANDO...</div>
                <div class="timer-container">
                    <svg id="timer-svg" viewBox="0 0 100 100"></svg>
                    <button id="btn-pass" onclick="game.passTurn()" disabled>PASSAR</button>
                </div>
                <!-- Elemento legado (escondido) para manter compatibilidade l√≥gica -->
                <div id="timer">60</div>
            </div>

            <!-- Player Hand -->
            <div class="hand-area player-hand" id="player-hand"></div>
        </div>
    </div>

    <script>
        const CARD_DATABASE = [];
        function registerCard(data) { CARD_DATABASE.push(data); }

        registerCard({ dbId: 'L-1', archetype: 'Melee', rarity: 'legendary', name: 'G. da Espada', tribe: 'Guerreiro', atk: 100, def: 30, hp: 400, maxHp: 400, pa: 5, piCost: 5, habName: 'B√™n√ß√£o da Espada', habDesc: 'HAB: Essa carta e todas as cartas do tipo "Guerreiro" ganham 50 de ATK por 3 turnos', ultName: 'F√∫ria do Campe√£o', ultDesc: 'Essa carta ganha +100% ATK por 1 turno', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/x1Y59x6v/G-Guerreiro.png' });
        registerCard({ dbId: 'L-2', archetype: 'Ranged', rarity: 'legendary', name: 'G. do Arco', tribe: 'Arqueiro', atk: 85, def: 20, hp: 300, maxHp: 300, pa: 5, piCost: 5, habName: 'Olho de √Åguia', habDesc: '+20% Cr√≠tico (2 turnos) em Ranged/Suporte aliados', ultName: 'Chuva Perfeita', ultDesc: '100% Cr√≠tico (1 turno) em todos aliados', effectType: 'pierce_and_party_heal', img: 'https://i.postimg.cc/pVzKyQh1/G-ARCO.png' });
        registerCard({ dbId: 'L-3', archetype: 'Tank', rarity: 'legendary', name: 'G. do Sangue', tribe: 'Berserks', atk: 50, def: 40, hp: 500, maxHp: 500, pa: 5, piCost: 5, habName: 'Sangue em F√∫ria', habDesc: '+10 ATK por 30 HP perdidos (4 turnos)', ultName: 'Pacto de Intercepta√ß√£o', ultDesc: 'Intercepta dano de uma carta aliada por (2 turnos)', effectType: 'pierce_and_party_heal', img: 'https://i.postimg.cc/RV11p1vx/G-Berserk.png' });
        registerCard({ dbId: 'L-4', archetype: 'Suporte', rarity: 'legendary', name: 'G. da Cura', tribe: 'Curandeiros', atk: 60, def: 15, hp: 350, maxHp: 350, pa: 5, piCost: 5, habName: 'C√¢ntico Revigorante', habDesc: '+2 PA agora e no pr√≥ximo turno (todos aliados) por 2 turnos', ultName: 'Milagre de Etheria', ultDesc: 'Cura full todos os aliados em campo', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/nzsY36Lh/G-CURA.png' });
        registerCard({ dbId: 'L-5', archetype: 'Melee', rarity: 'legendary', name: 'G. das Bestas', tribe: 'Bestiais', atk: 90, def: 25, hp: 480, maxHp: 480, pa: 5, piCost: 5, habName: 'Marca da Alcateia', habDesc: 'HAB: Ap√≥s usar a habilidade no alvo ele ser√° marcado e sofrer√° 20% a mais da dano e todas as cartas aliadas que atacar recuperam 20% de hp do dano causado por 2 turnos', ultName: 'F√∫ria Bestial', ultDesc: 'Essa carta sacrifica 25% da vida e toda sua defesa para aumentar seu poder de ataque em 75% por 2 turno', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/CMqskTtD/G-BESTIAIS.png' });
        registerCard({ dbId: 'L-6', archetype: 'Tank', rarity: 'legendary', name: 'G. do Escudo', tribe: 'Protetores', atk: 50, def: 45, hp: 600, maxHp: 600, pa: 5, piCost: 5, habName: 'Muralha Protetora', habDesc: 'HAB: Reduz em 10% o dano sofrido por todas as cartas aliadas em campo', ultName: '√âgide Imortal', ultDesc: 'A ultimate dessa carta deixa invulner√°vel qualquer carta aliada, pode ser usada em si mesmo.', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/XvYgCZSG/G-Escudo.png' });
        registerCard({ dbId: 'L-7', archetype: 'Suporte', rarity: 'legendary', name: 'G. do Ouro', tribe: 'Herdeiros', atk: 60, def: 20, hp: 400, maxHp: 400, pa: 5, piCost: 5, habName: 'Tributo Dourado', habDesc: 'HAB: Para cada carta na m√£o do jogador e do seu oponente essa carta aumenta em 10 o poder de ATK da carta aliada, pode ser usado em si mesmo.)', ultName: 'Decreto da Paz', ultDesc: 'Se o alvo for aliado cura 100% da vida e o deixa pacifista, se for inimigo deixa ele em estado pacifista e ele n√£o poder√° causar dano por 1 turno', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/YSMQ151S/G-Ouro.png' });
        registerCard({ dbId: 'L-8', archetype: 'Melee', rarity: 'legendary', name: 'G. da Morte', tribe: 'Esqueletos', atk: 95, def: 15, hp: 400, maxHp: 400, pa: 5, piCost: 5, habName: 'Ecos do Oss√°rio', habDesc: 'HAB: +20 de ATK para cada carta do tipo "Esqueleto" no cemi√©rio e no campo de batalha, al√©m disso 20% do dano sofrido por essa carta √© redistribuido para os Esqueletos em campo por 2 turnos', ultName: 'Ceifa do Al√©m', ultDesc: 'Essa carta ganha todo o poder de ataque somado de todas as cartas do tipo "Esqueletos" no cemit√©rio por 1 turno. ', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/9XKTxRG6/G-Morte.png' });
        registerCard({ dbId: 'L-9', archetype: 'Melee', rarity: 'legendary', name: 'G. da Lan√ßa', tribe: 'Lanceiros', atk: 80, def: 30, hp: 400, maxHp: 400, pa: 5, piCost: 5, habName: 'Postura da Falange', habDesc: 'HAB: +20 ATK por Lanceiro aliado em campo (2 turnos). Ao causar dano em alvo da linha de frente, aplica 30% do dano causado na backline inimiga.', ultName: 'Lan√ßa Implac√°vel', ultDesc: 'ULT: 75% do dano no alvo √© aplicado a todos inimigos.', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/5t4sS7vV/G-Lanca.png' });
        registerCard({ dbId: 'L-10', archetype: 'Tank', rarity: 'legendary', name: 'G. da M√°scara', tribe: 'An√¥nimos', atk: 55, def: 35, hp: 500, maxHp: 400, pa: 5, piCost: 5, habName: 'V√©u da M√°scara', habDesc: 'HAB: -20% dano recebido, +10% dano causado e +2% por 20 de sobrevida (3 turnos). Ganha +20 sobrevida por ataque.', ultName: 'Golpe Oculto', ultDesc: 'ULT: Concede sobrevida (20% HP m√°x) a todos aliados por 2 turnos.', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/vBDghbDY/G-mascara.png' });
        registerCard({ dbId: 'L-11', archetype: 'Tank', rarity: 'legendary', name: 'G. do √Ålcool', tribe: 'Pandistas', atk: 55, def: 45, hp: 550, maxHp: 400, pa: 5, piCost: 5, habName: 'Troca de Posi√ß√£o', habDesc: 'HAB: Troca a posi√ß√£o (frente ‚Üî tr√°s) de uma carta aliada ou inimiga. Custa 1 PA e pode ser usada 2x no turno.', ultName: 'Estado B√™bado', ultDesc: 'ULT: Usa em si mesma para alternar entre B√äBADO (-25% dano recebido) e S√ìBRIO (+25% ATK). Permanece at√© alternar novamente.', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/sgDWnt6d/G-Alcool.png' });
        registerCard({ dbId: 'L-12', archetype: 'Suporte', rarity: 'legendary', name: 'G. da √Årvore', tribe: 'Silvestres', atk: 50, def: 15, hp: 400, maxHp: 400, pa: 5, piCost: 5, habName: 'Brinde B√©lico', habDesc: 'HAB: Infecta alvo por 2 turnos (veneno = 20% do ATK da L-12). Ao atacar infectado, todas cartas infectadas sofrem 50% do dano.', ultName: 'Rugido do Barril', ultDesc: 'ULT: Infecta todos inimigos e cura aliados em 20% do HP m√°x. Um aliado ganha +20 ATK por curado (2 turnos).', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/SKRWKwCm/G-ARVORE.png' });
        registerCard({ dbId: 'L-13', archetype: 'Suporte', rarity: 'legendary', name: 'G. das Criaturas', tribe: 'Invocadores', atk: 60, def: 20, hp: 400, maxHp: 400, pa: 5, piCost: 5, habName: 'Seiva Vital', habDesc: 'HAB: Invoca do cemit√©rio (Comum/Rara/√âpica) para seu campo. M√°x 2 invoca√ß√µes controladas.', ultName: 'Ra√≠zes Ancestrais', ultDesc: 'ULT: Controle mental por 1 turno completo; pode mover ao seu campo e usar habilidade/ultimate. N√£o pode controlar a mesma carta novamente.', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/xCqgWXth/G-invocador.png' });
        registerCard({ dbId: 'L-14', archetype: 'Suporte', rarity: 'legendary', name: 'G. da Tecnologia', tribe: 'Tecmagos', atk: 60, def: 25, hp: 400, maxHp: 400, pa: 5, piCost: 5, habName: 'Engrenagem Arcana', habDesc: 'HAB: Dobra efeitos utilit√°rios aliados por 2 turnos e d√° +2 PA agora +2 PA no pr√≥ximo turno ao alvo.', ultName: 'N√∫cleo Supremo', ultDesc: 'ULT (6 PA): Suspende buffs/debuffs tempor√°rios inimigos por 1 turno, aplica +25% dano recebido por 2 turnos e concede sobrevida 10% aos aliados.', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/zG9fnKKy/G-Tecnologia.png' });
        registerCard({ dbId: 'L-15', archetype: 'Ranged', rarity: 'legendary', name: 'G. da Magia', tribe: 'Magos', atk: 80, def: 15, hp: 400, maxHp: 400, pa: 5, piCost: 5, habName: 'Runa', habDesc: 'HAB (3 PA): Causa dano base de ataque +15% e marca o alvo com Runa (+15% dano recebido) por 3 turnos completos.', ultName: 'Explodir Runas', ultDesc: 'ULT: Drena DEF e rouba ATK de inimigos marcados com Runa. Escala com a quantidade de marcas.', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/T1Dy80Vv/G-mago.png' });
        registerCard({ dbId: 'L-16', archetype: 'Melee', rarity: 'legendary', name: 'G. da Sorte', tribe: 'Trevos', atk: 80, def: 30, hp: 450, maxHp: 400, pa: 5, piCost: 5, habName: 'Sorte do Trevo', habDesc: 'HAB: Rola 1d6 em um aliado. Chance de converter dano em cura + b√¥nus de ATK por 1 turno completo.', ultName: 'Destino Favor√°vel', ultDesc: 'ULT: Escolha um naipe (Espadas/Copas/Ouro/Paus) e aplique seu efeito por 1 turno completo.', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/bJLDHdzX/G-SORTE.png' });
        registerCard({ dbId: 'L-17', archetype: 'Ranged', rarity: 'legendary', name: 'G. da P√≥lvora', tribe: 'Bandidos', atk: 75, def: 20, hp: 400, maxHp: 400, pa: 5, piCost: 5, habName: 'Compra R√°pida', habDesc: 'HAB: Ativa modo de compra. Clique no deck para comprar 1 carta.', ultName: 'For√ßar Compra', ultDesc: 'ULT: Oponente compra 1 carta e voc√™ rouba 2 cartas da m√£o dele.', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/v8N7pSdS/G-Polvora.png' });
        registerCard({ dbId: 'L-18', archetype: 'Ranged', rarity: 'legendary', name: 'G. dos Portais', tribe: 'Vagantes', atk: 85, def: 20, hp: 480, maxHp: 400, pa: 5, piCost: 5, habName: 'Comando de Vanguarda', habDesc: 'HAB: Buff global +20% ATK por 2 turnos; alvo recebe +2 PA agora e +2 PA no pr√≥ximo turno; Melee/Tank podem atacar a linha de tr√°s por 2 turnos.', ultName: 'Triplo Deslocamento', ultDesc: 'ULT: Envie 1 inimigo do campo ao topo do deck, 1 carta da m√£o inimiga ao fundo do deck, e 1 carta do cemit√©rio inimigo ao seu cemit√©rio.', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/QxS9WfXq/G-PORTAL.png' });
        registerCard({ dbId: 'L-19', archetype: 'Suporte', rarity: 'legendary', name: 'G. do Tempo', tribe: 'Cronomantes', atk: 60, def: 25, hp: 450, maxHp: 400, pa: 5, piCost: 5, habName: 'Ritmo Temporal', habDesc: 'Self: +1 PA para aliados agora; no pr√≥ximo turno +2 PA e 10% de roubar 1 PA ao causar dano.', ultName: 'Paradoxo do Tempo', ultDesc: 'Self: pr√≥ximo ataque rouba 1 PA. Time: 40% de roubar 1 PA ao causar dano (1 turno).', effectType: 'temporal_rhythm', img: 'https://i.postimg.cc/VkSqf9z1/G-TEMPO.png' });
        registerCard({ dbId: 'E-1', archetype: 'Suporte', rarity: 'epic', name: 'Carta √âpica', tribe: 'Cronomantes', atk: 60, def: 25, hp: 450, maxHp: 400, pa: 4, piCost: 4, habName: 'Eco Cronom√¢ntico', habDesc: 'Cura Front Row (50% Dano)', ultName: 'Salto Temporal', ultDesc: 'Buff: +150 ATK', effectType: 'heal_front_on_back_hit', img: 'https://i.postimg.cc/8CgPgdtJ/A18-TEMPO.png' });
        registerCard({ dbId: 'R-1', archetype: 'Ranged', rarity: 'rare', name: 'Arqueiro Mestre', tribe: 'Arqueiros', atk: 70, def: 20, hp: 300, maxHp: 300, pa: 3, piCost: 3, habName: 'Tiro Preciso', habDesc: 'Buff: +20 ATK', ultName: 'Disparo Vamp√≠rico', ultDesc: 'Cura 50% Dano', effectType: 'lifesteal', img: 'https://robohash.org/R-1?set=set2&size=300x300' });
        registerCard({ dbId: 'C-1', archetype: 'Melee', rarity: 'common', name: 'Esqueleto Comum', tribe: 'Esqueletos', atk: 40, def: 20, hp: 100, maxHp: 100, pa: 2, piCost: 2, habName: 'Ossos Afiados', habDesc: 'Buff: +10 ATK', ultName: 'Explos√£o √ìssea', ultDesc: 'Dano em √Årea', effectType: 'splash', img: 'https://robohash.org/C-1?set=set2&size=300x300' });
        registerCard({ dbId: 'C-2', archetype: 'Melee', rarity: 'common', name: 'Esqueleto Comum', tribe: 'Esqueletos', atk: 40, def: 20, hp: 100, maxHp: 100, pa: 2, piCost: 2, habName: 'Ossos Afiados', habDesc: 'Buff: +10 ATK', ultName: 'Explos√£o √ìssea', ultDesc: 'Dano em √Årea', effectType: 'splash', img: 'https://robohash.org/C-1?set=set2&size=300x300' });
        registerCard({ dbId: 'C-3', archetype: 'Melee', rarity: 'common', name: 'Esqueleto Comum', tribe: 'Esqueletos', atk: 40, def: 20, hp: 100, maxHp: 100, pa: 2, piCost: 2, habName: 'Ossos Afiados', habDesc: 'Buff: +10 ATK', ultName: 'Explos√£o √ìssea', ultDesc: 'Dano em √Årea', effectType: 'splash', img: 'https://robohash.org/C-1?set=set2&size=300x300' });
        registerCard({ dbId: 'C-4', archetype: 'Melee', rarity: 'common', name: 'Esqueleto Comum', tribe: 'Esqueletos', atk: 40, def: 20, hp: 100, maxHp: 100, pa: 2, piCost: 2, habName: 'Ossos Afiados', habDesc: 'Buff: +10 ATK', ultName: 'Explos√£o √ìssea', ultDesc: 'Dano em √Årea', effectType: 'splash', img: 'https://robohash.org/C-1?set=set2&size=300x300' });
        registerCard({ dbId: 'U-1', archetype: 'Utility', rarity: 'utility', name: 'Po√ß√£o de Energia', tribe: 'Item', atk: 0, def: 0, hp: 0, maxHp: 0, pa: 0, piCost: 1, habName: 'Infus√£o Energ√©tica', habDesc: '+3 PA ao alvo', ultName: 'Sem Ultimate', ultDesc: '-', effectType: 'add_pa', img: 'https://robohash.org/U-1?set=set3&size=300x300' });

        function navigateTo(screen) {
            document.querySelectorAll('.screen-section').forEach(el => el.style.display = 'none');
            if (screen === 'menu') {
                document.getElementById('main-menu').style.display = 'flex';
            } else if (screen === 'builder') {
                document.getElementById('deck-builder-screen').style.display = 'block';
                initDeckBuilder();
            } else if (screen === 'game') {
                document.getElementById('game-view').style.display = 'block';
            }
        }

        let playerDraft = [];
        let draftCounts = {}; 
        const MAX_DECK_SIZE = 50;
        const MIN_DECK_SIZE = 5;
        const MAX_COPIES = { 'legendary': 1, 'rare': 2, 'common': 3, 'utility': 3, 'epic': 1 };

        // --- FILTER LOGIC ---
        function getUniqueValues(key) {
            const values = CARD_DATABASE.map(c => c[key]).filter(v => v);
            return [...new Set(values)].sort();
        }

        function populateFilters() {
            const archSelect = document.getElementById('filter-archetype');
            const raritySelect = document.getElementById('filter-rarity');
            const tribeSelect = document.getElementById('filter-tribe');

            // Helper to populate a select
            const populate = (select, items) => {
                // Keep the first option (All) and clear the rest
                while (select.options.length > 1) {
                    select.remove(1);
                }
                items.forEach(item => {
                    const opt = document.createElement('option');
                    opt.value = item;
                    opt.innerText = item.charAt(0).toUpperCase() + item.slice(1);
                    select.appendChild(opt);
                });
            };

            populate(archSelect, getUniqueValues('archetype'));
            populate(raritySelect, getUniqueValues('rarity'));
            populate(tribeSelect, getUniqueValues('tribe'));
        }

        function filterInventory() {
            const searchText = document.getElementById('filter-search').value.toLowerCase();
            const archValue = document.getElementById('filter-archetype').value;
            const rarityValue = document.getElementById('filter-rarity').value;
            const tribeValue = document.getElementById('filter-tribe').value;

            const filtered = CARD_DATABASE.filter(card => {
                let matchesSearch = true;
                if (searchText.length >= 3) {
                    matchesSearch = card.name.toLowerCase().includes(searchText);
                } else if (searchText.length > 0) {
                    matchesSearch = true; 
                }

                const matchesArch = archValue === 'all' || card.archetype === archValue;
                const matchesRarity = rarityValue === 'all' || card.rarity === rarityValue;
                const matchesTribe = tribeValue === 'all' || card.tribe === tribeValue;

                return matchesSearch && matchesArch && matchesRarity && matchesTribe;
            });

            renderBuilderGrid(filtered);
        }

        function renderBuilderGrid(cardsToRender) {
            const grid = document.getElementById('builder-grid');
            grid.innerHTML = '';

            if (cardsToRender.length === 0) {
                grid.innerHTML = '<div style="color: #666; font-family: var(--font-title); font-size: 2vh; grid-column: 1 / -1; text-align: center; margin-top: 5vh;">Nenhuma carta encontrada.</div>';
                return;
            }

            cardsToRender.forEach(card => {
                const wrapper = document.createElement('div');
                wrapper.className = 'builder-card-slot';
                // wrapper.onclick is REMOVED to prioritize buttons.

                // Qty Badge logic relies on the global draftCounts
                const count = draftCounts[card.dbId] || 0;
                const badge = document.createElement('div');
                badge.className = 'card-quantity-badge';
                badge.id = `qty-${card.dbId}`;
                badge.innerText = count;
                badge.style.display = (count > 0) ? 'flex' : 'none';
                if (count === MAX_COPIES[card.rarity]) badge.style.background = 'var(--gold)';

                const visual = document.createElement('div');
                visual.className = `builder-card-visual`;
                const tempDiv = document.createElement('div');
                tempDiv.className = `card ${card.rarity}`;
                tempDiv.innerHTML = ui.cardTemplate(card);
                fx.bindCardTilt(tempDiv);
                visual.appendChild(tempDiv);

                // --- HOVER ACTIONS LAYER ---
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'builder-hover-actions';
                actionsDiv.innerHTML = `
                    <button class="builder-action-btn btn-b-select">Selecionar</button>
                    <button class="builder-action-btn btn-b-view">Visualizar</button>
                `;

                const btnSelect = actionsDiv.querySelector('.btn-b-select');
                btnSelect.onclick = (e) => { e.stopPropagation(); toggleCardInDraft(card); };

                const btnView = actionsDiv.querySelector('.btn-b-view');
                btnView.onclick = (e) => { e.stopPropagation(); openBuilderCardModal(card); };

                wrapper.appendChild(visual);
                wrapper.appendChild(actionsDiv);
                wrapper.appendChild(badge);
                grid.appendChild(wrapper);
            });
        }
        // --------------------

        // --- NEW: BUILDER MODAL LOGIC ---
        function openBuilderCardModal(card) {
            const overlay = document.getElementById('builder-overlay');

            const stars = '‚≠ê'.repeat(card.piCost);
            const isUtility = card.rarity === 'utility';
            let imgStyle = isUtility ? 'filter: hue-rotate(90deg);' : '';
            const archetypeIconHtml = getArchetypeIcon(card.archetype);

            let statsHtml = '';
            if (!isUtility) {
                statsHtml = `
                    <div class="modal-stats-row">
                        <span class="modal-stat" style="color:var(--danger)">‚öîÔ∏è ${card.atk}</span>
                        <span class="modal-stat" style="color:var(--secondary)">‚ù§Ô∏è ${card.hp}</span>
                        <span class="modal-stat" style="color:var(--blue)">üõ°Ô∏è ${card.def}</span>
                        <span class="modal-stat" style="color:var(--gold)">‚ö° ${card.pa}</span>
                    </div>
                `;
            }

            overlay.innerHTML = `
                <div class="modal-card">
                    <div class="modal-visual-card ${card.rarity}">
                        <div class="modal-inner">
                            <div class="modal-header">
                                <div class="modal-name">${card.name}</div>
                                <div class="modal-stars">${stars}</div>
                            </div>

                            <div class="modal-art-frame">
                                ${archetypeIconHtml}
                                <img src="${card.img}" class="modal-art-img" style="${imgStyle}">
                            </div>

                            <div class="modal-text-area">
                                ${statsHtml}

                                <div class="modal-desc-box">
                                    <div class="modal-label">EFEITO</div>
                                    <div class="modal-text">${card.habDesc}</div>
                                </div>

                                ${card.ultDesc && card.ultDesc !== '-' ? `
                                <div class="modal-desc-box">
                                    <div class="modal-label" style="color:var(--util)">ULTIMATE</div>
                                    <div class="modal-text">${card.ultDesc}</div>
                                </div>` : ''}

                                <div class="modal-subtext">${card.tribe} | ${card.archetype} | ${card.rarity.toUpperCase()}</div>
                            </div>
                        </div>
                    </div>

                    <div class="modal-actions-panel">
                        <h3>INVENT√ÅRIO</h3>
                        <button id="btn-builder-select" class="btn btn-summon">SELECIONAR</button>
                        <button id="btn-builder-close" class="btn btn-cancel">FECHAR</button>
                    </div>
                </div>
            `;

            // Bind Events
            document.getElementById('btn-builder-select').onclick = () => {
                toggleCardInDraft(card);
                closeBuilderCardModal();
            };
            document.getElementById('btn-builder-close').onclick = closeBuilderCardModal;

            // Backdrop Click
            overlay.onclick = (e) => {
                if (e.target === overlay) closeBuilderCardModal();
            };

            overlay.style.display = 'flex';
            overlay.classList.add('overlay-open');
        }

        function closeBuilderCardModal() {
            const overlay = document.getElementById('builder-overlay');
            overlay.style.display = 'none';
            overlay.classList.remove('overlay-open');
            overlay.innerHTML = '';
        }
        // -------------------------------

        function initDeckBuilder() {
            // Initialize filters only once (or check if already populated)
            const archSelect = document.getElementById('filter-archetype');
            if (archSelect.options.length <= 1) {
                populateFilters();
            }

            updateBuilderUI(); // Update texts
            filterInventory(); // Render grid based on current filters (or defaults)
        }

        function toggleCardInDraft(card) {
            const currentCount = draftCounts[card.dbId] || 0;
            const limit = MAX_COPIES[card.rarity];
            if (currentCount < limit && playerDraft.length < MAX_DECK_SIZE) {
                playerDraft.push(card);
                draftCounts[card.dbId] = currentCount + 1;
            } else if (currentCount > 0) {
                if (currentCount === limit) removeCardFromDraft(card);
                else if (playerDraft.length === MAX_DECK_SIZE) {
                    if (currentCount > 0) removeCardFromDraft(card);
                    else alert("Deck cheio!");
                }
            }
            updateBuilderUI();
        }

        function removeCardFromDraft(card) {
            const idx = playerDraft.findIndex(c => c.dbId === card.dbId);
            if (idx > -1) { playerDraft.splice(idx, 1); draftCounts[card.dbId]--; }
        }

        function autoFillDeck() {
            for (let card of CARD_DATABASE) {
                const limit = MAX_COPIES[card.rarity];
                while ((draftCounts[card.dbId] || 0) < limit && playerDraft.length < MAX_DECK_SIZE) {
                    playerDraft.push(card);
                    draftCounts[card.dbId] = (draftCounts[card.dbId] || 0) + 1;
                }
                if (playerDraft.length >= MAX_DECK_SIZE) break;
            }
            updateBuilderUI();
        }

        function updateBuilderUI() {
            const countEl = document.getElementById('builder-count');
            const btn = document.getElementById('btn-start-match');
            const total = playerDraft.length;
            countEl.innerText = total;

            // Update visible badges
            // Note: This only updates badges currently in the DOM (filtered ones). 
            // Hidden cards will have their badges updated next time renderBuilderGrid is called.
            for (let id in draftCounts) {
                const badge = document.getElementById(`qty-${id}`);
                if (badge) {
                    badge.innerText = draftCounts[id];
                    badge.style.display = draftCounts[id] > 0 ? 'flex' : 'none';
                    const cardData = CARD_DATABASE.find(c => c.dbId === id);
                    if (cardData && draftCounts[id] === MAX_COPIES[cardData.rarity]) badge.style.background = 'var(--gold)';
                    else badge.style.background = 'var(--secondary)';
                }
            }

            if (total >= MIN_DECK_SIZE && total <= MAX_DECK_SIZE) {
                countEl.style.color = 'var(--secondary)';
                btn.disabled = false;
                btn.innerText = "INICIAR PARTIDA";
            } else {
                countEl.style.color = 'var(--danger)';
                btn.disabled = true;
                btn.innerText = total < MIN_DECK_SIZE ? `M√çNIMO ${MIN_DECK_SIZE}` : "DECK CHEIO";
            }
        }

        function finishDeckBuilder() {
            game.player.deck = buildDeck(playerDraft, 'P');
            game.initGrid(); 
            ui.updateHUD(); 
            navigateTo('game');
            document.getElementById('rps-overlay').style.display = 'flex';
        }

        let globalUidCounter = 0;
        function generateUid(ownerPrefix = 'C') {
            globalUidCounter += 1;
            return `${ownerPrefix}_${Date.now()}_${globalUidCounter}_${Math.random().toString(36).slice(2, 8)}`;
        }

        function createCardInstance(card, ownerPrefix) {
            return {
                ...card,
                uid: generateUid(ownerPrefix),
                currentHp: card.hp,
                currentAtk: card.atk,
                currentDef: card.def,
                statusEffects: [],
                nextAttackFree: null,
                shield: 0,
                controlledBy: null,
                controlImmune: false,
                isNecroSummon: false,
                necromancerUid: null,
                necroOriginalOwner: null
            };
        }

        function buildDeck(preselectedList = null, ownerPrefix = 'P') {
            const deck = [];
            const shuffle = (arr) => arr.sort(() => Math.random() - 0.5);
            if (preselectedList) {
                preselectedList.forEach(card => {
                    deck.push(createCardInstance(card, ownerPrefix));
                });
                return shuffle(deck);
            }
            const cardsByRarity = {
                legendary: CARD_DATABASE.filter(c => c.rarity === 'legendary'),
                rare: CARD_DATABASE.filter(c => c.rarity === 'rare'),
                common: CARD_DATABASE.filter(c => c.rarity === 'common'),
                utility: CARD_DATABASE.filter(c => c.rarity === 'utility')
            };
            const addCardsToDeck = (pool, maxTotal, maxCopies) => {
                shuffle(pool);
                let count = 0;
                let addedIds = {};
                for (let card of pool) {
                    if (count >= maxTotal) break;
                    const currentCopies = addedIds[card.dbId] || 0;
                    if (currentCopies < maxCopies) {
                        deck.push(createCardInstance(card, ownerPrefix));
                        addedIds[card.dbId] = currentCopies + 1;
                        count++;
                    }
                }
            };
            addCardsToDeck(cardsByRarity.legendary, 5, 1);
            addCardsToDeck(cardsByRarity.rare, 10, 2);
            addCardsToDeck(cardsByRarity.common, 25, 3);
            addCardsToDeck(cardsByRarity.utility, 10, 2);
            return shuffle(deck); 
        }

        /* --- Helper de √çcones de Arqu√©tipo --- */
        const getArchetypeIcon = (type) => {
            // Mapeie aqui os links das suas imagens para cada arqu√©tipo
            const iconImages = {
                'Melee': 'https://i.postimg.cc/vHvn7g1D/icone-espada.png',
                'Ranged': 'https://i.postimg.cc/Hk2tLv4p/Icone-arco.png',
                'Tank': 'https://i.postimg.cc/K8vM0GL0/Icone-escudo.png',
                'Suporte': 'https://i.postimg.cc/527FGhSv/Icone-cura.png',
                'Utility': 'https://i.postimg.cc/N0FRjsjp/Icone-Utilitaria.png'
            };

            const imgSrc = iconImages[type] || 'LINK_DE_ERRO.png';

            return `<div class="archetype-icon">
                        <img src="${imgSrc}" style="width: 100%; height: 100%; object-fit: contain; border-radius: 50%;">
                    </div>`;
        };

        // FX helpers: playSfx, spawnParticles, hitFlash, screenShake, healHearts
        const fx = (() => {
            const state = {
                sfxEnabled: false,
                hoverThrottle: 0,
                handHoverThrottle: 0
            };

            const playSfx = () => {};

            const getCenterFromRect = (rect) => ({
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            });

            const spawnParticles = (type, fromRect, toRect) => {
                if (document.hidden) return;
                const start = fromRect ? getCenterFromRect(fromRect) : null;
                const end = toRect ? getCenterFromRect(toRect) : start;
                const countMap = { attack: 12, skill: 14, ult: 20, summon: 10, heal: 10, buff: 8, debuff: 10 };
                const count = countMap[type] || 8;
                const max = document.hidden ? Math.min(4, count) : count;
                for (let i = 0; i < max; i++) {
                    const p = document.createElement('div');
                    const isTrail = type === 'skill';
                    const isDebuff = type === 'debuff';
                    p.className = isTrail ? 'fx-trail' : (isDebuff ? 'fx-debuff' : 'fx-particle');
                    const base = end || start;
                    if (!base) continue;
                    const rand = (seed) => (Math.random() - 0.5) * seed;
                    const angleSpread = type === 'attack' ? 140 : 180;
                    const angle = (Math.random() * angleSpread - angleSpread / 2) * (Math.PI / 180);
                    const velocity = 10 + Math.random() * (type === 'ult' ? 50 : 30);
                    const tx = Math.cos(angle) * velocity;
                    const ty = Math.sin(angle) * velocity;
                    p.style.left = (base.x + rand(10)) + 'px';
                    p.style.top = (base.y + rand(10)) + 'px';
                    p.style.setProperty('--tx', `${tx}px`);
                    p.style.setProperty('--ty', `${ty}px`);
                    if (type === 'heal') p.style.background = 'radial-gradient(circle, rgba(57,255,20,0.9), rgba(57,255,20,0))';
                    if (type === 'buff') p.style.background = 'radial-gradient(circle, rgba(255,215,0,0.9), rgba(255,215,0,0))';
                    if (type === 'ult') p.style.background = 'radial-gradient(circle, rgba(214,51,214,0.9), rgba(80,0,120,0))';
                    if (type === 'attack') p.style.background = 'radial-gradient(circle, rgba(255,80,80,0.9), rgba(120,0,0,0))';
                    document.body.appendChild(p);
                    setTimeout(() => p.remove(), 700);
                }
                if (type === 'ult' && end) {
                    const ring = document.createElement('div');
                    ring.className = 'fx-ring';
                    ring.style.left = end.x + 'px';
                    ring.style.top = end.y + 'px';
                    document.body.appendChild(ring);
                    setTimeout(() => ring.remove(), 600);
                }
            };

            const hitFlash = (el) => {
                if (!el) return;
                el.classList.remove('fx-hit-flash');
                void el.offsetWidth;
                el.classList.add('fx-hit-flash');
                setTimeout(() => el.classList.remove('fx-hit-flash'), 260);
            };

            const screenShake = (intensity = 1, duration = 350) => {
                if (document.hidden) return;
                const container = document.getElementById('game-container');
                if (!container) return;
                container.classList.add('fx-screen-shake');
                setTimeout(() => container.classList.remove('fx-screen-shake'), duration);
            };

            const healHearts = (targetRect, amount = 3) => {
                if (document.hidden || !targetRect) return;
                const base = getCenterFromRect(targetRect);
                for (let i = 0; i < amount; i++) {
                    const heart = document.createElement('div');
                    heart.className = 'fx-heart';
                    heart.innerText = 'üíö';
                    heart.style.left = (base.x + (Math.random() * 20 - 10)) + 'px';
                    heart.style.top = (base.y + (Math.random() * 10 - 20)) + 'px';
                    document.body.appendChild(heart);
                    setTimeout(() => heart.remove(), 1200);
                }
            };

            const spawnRunes = (targetRect, count = 3) => {
                if (document.hidden || !targetRect) return;
                const base = getCenterFromRect(targetRect);
                const symbols = ['‚¨ÜÔ∏è', '‚ú¶', '‚úß'];
                for (let i = 0; i < count; i++) {
                    const rune = document.createElement('div');
                    rune.className = 'fx-rune';
                    rune.innerText = symbols[Math.floor(Math.random() * symbols.length)];
                    rune.style.left = (base.x + (Math.random() * 24 - 12)) + 'px';
                    rune.style.top = (base.y + (Math.random() * 12 - 10)) + 'px';
                    document.body.appendChild(rune);
                    setTimeout(() => rune.remove(), 1000);
                }
            };

            const applyStatusVisuals = (el, card) => {
                if (!el || !card) return;
                const effects = card.statusEffects || [];
                const hasIntercept = effects.some(e => e.type === 'intercept');
                const hasPacifist = effects.some(e => e.type === 'pacifist');
                const hasBuff = effects.some(e => ['atk_flat', 'atk_mult', 'damage_reduction', 'crit_chance', 'atk_missing_hp', 'def_override', 'damage_immunity', 'hp_drain_pct', 'atk_shield_mult', 'l10_skill_active', 'shield', 'atk_per_tribe', 'l9_spill', 'l9_ult_splash', 'mind_control', 'l16_dice', 'l16_suit_badge'].includes(e.type));
                const hasDebuff = effects.some(e => ['pacifist', 'damage_taken_mult', 'l5_mark', 'infection', 'l15_runa'].includes(e.type));
                el.classList.toggle('fx-intercept', hasIntercept);
                el.classList.toggle('fx-pacifist', hasPacifist);
                el.classList.toggle('fx-buff', hasBuff);
                el.classList.toggle('fx-debuffed', hasDebuff);
            };

            const bindCardTilt = (el) => {
                if (!el || el.dataset.tiltBound) return;
                el.dataset.tiltBound = 'true';
                const onMove = (e) => {
                    if (document.hidden) return;
                    const rect = el.getBoundingClientRect();
                    const x = (e.clientX - rect.left) / rect.width - 0.5;
                    const y = (e.clientY - rect.top) / rect.height - 0.5;
                    const tiltX = (y * -10).toFixed(2);
                    const tiltY = (x * 10).toFixed(2);
                    el.style.setProperty('--tilt-x', `${tiltX}deg`);
                    el.style.setProperty('--tilt-y', `${tiltY}deg`);
                    el.style.setProperty('--glow-x', `${(x + 0.5) * 100}%`);
                    el.style.setProperty('--glow-y', `${(y + 0.5) * 100}%`);
                    el.classList.add('fx-tilt');
                };
                const onLeave = () => {
                    el.classList.remove('fx-tilt');
                    el.style.setProperty('--tilt-x', `0deg`);
                    el.style.setProperty('--tilt-y', `0deg`);
                    el.style.setProperty('--glow-alpha', `0`);
                };
                el.addEventListener('pointermove', onMove);
                el.addEventListener('pointerleave', onLeave);
                el.addEventListener('pointerenter', () => {
                    el.style.setProperty('--glow-alpha', `1`);
                });
                el.addEventListener('pointerdown', () => {
                    el.classList.add('fx-press');
                });
                const clearPress = () => el.classList.remove('fx-press');
                el.addEventListener('pointerup', clearPress);
                el.addEventListener('pointercancel', clearPress);
            };

            const bindButtons = () => {
            };

            const initSfxToggle = () => {
                const btn = document.getElementById('sfx-toggle');
                if (!btn) return;
                state.sfxEnabled = false;
                btn.textContent = 'SOM: OFF';
                btn.classList.add('off');
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.sfxEnabled = false;
                    btn.textContent = 'SOM: OFF';
                    btn.classList.add('off');
                });
            };
            const setEnabled = (enabled) => {
                state.sfxEnabled = !!enabled;
            };
            const initAudioOnFirstUserGesture = (extraUnlock) => {
                if (typeof extraUnlock === 'function') extraUnlock();
            };

            return {
                playSfx,
                spawnParticles,
                hitFlash,
                screenShake,
                healHearts,
                spawnRunes,
                bindCardTilt,
                bindButtons,
                applyStatusVisuals,
                initSfxToggle,
                initAudioOnFirstUserGesture,
                setEnabled
            };
        })();

        class Game {
            constructor() {
                this.activeSide = null; this.roundNumber = 0; this.turnCounter = 0; this.phase = 'start'; this.timer = 60; this.timerInterval = null;
                this.firstPlayerFirstTurnAttackLocked = true;
                this.roundStarter = 'player';
                this.interactionMode = 'none'; this.activeCard = null; this.validSlots = []; 
                this.deckDrawMode = null;
                this.handStealMode = null;
                this.player = { hp: 1000, maxHp: 1000, def: 20, pi: 7, hand: [], deck: [], gy: [], field: {}, teamEffects: [] }; 
                this.opp = { hp: 1000, maxHp: 1000, def: 20, pi: 7, hand: [], deck: buildDeck(null, 'O'), gy: [], field: {}, teamEffects: [] }; 
                this.handPickMode = null;
                this.graveyardSelectMode = null;
            }
            ensureCardState(card) {
                if (!card.statusEffects) card.statusEffects = [];
                if (!card.nextAttackFree) card.nextAttackFree = null;
                if (!card.turnActionUses) card.turnActionUses = { skill: 0, ult: 0 };
                if (card.shield === undefined || card.shield === null) card.shield = 0;
                if (card.controlledBy === undefined) card.controlledBy = null;
                if (card.controlImmune === undefined) card.controlImmune = false;
                if (card.isNecroSummon === undefined) card.isNecroSummon = false;
                if (card.necromancerUid === undefined) card.necromancerUid = null;
                if (card.necroOriginalOwner === undefined) card.necroOriginalOwner = null;
            }
            isL11Drunk(card) {
                if (!card || card.dbId !== 'L-11') return false;
                return (card.statusEffects || []).some(effect => effect.id === `l11_drunk_${card.uid}`);
            }
            getActionCost(card, actionType) {
                if (actionType === 'attack') return 2;
                if (actionType === 'skill') {
                    if (card.dbId === 'L-11') return 1;
                    if (card.dbId === 'L-15') return 3;
                    return 4;
                }
                if (actionType === 'ult') {
                    if (card.dbId === 'L-11') return 2;
                    if (card.dbId === 'L-14') return 6;
                    return 7;
                }
                return 0;
            }
            getActionLimit(card, actionType) {
                if (card.dbId === 'L-11' && (actionType === 'skill' || actionType === 'ult')) return 2;
                return null;
            }
            canUseAction(card, actionType) {
                const limit = this.getActionLimit(card, actionType);
                if (!limit) return true;
                this.ensureCardState(card);
                return (card.turnActionUses?.[actionType] ?? 0) < limit;
            }
            addStatusEffect(card, effect) {
                this.ensureCardState(card);
                if (!effect.meta) effect.meta = {};
                if (!effect.meta.sourceSide && this.activeSide) effect.meta.sourceSide = this.activeSide;
                const wasActive = card.statusEffects.some(e => e.id === effect.id && e.turnsLeft > 0);
                card.statusEffects = card.statusEffects.filter(e => e.id !== effect.id);
                card.statusEffects.push(effect);
                if (effect.type === 'shield') this.syncShieldValue(card);
                if (typeof ui !== 'undefined') ui.updateInfoPanel();
                if (!effect.meta?.silentLog) {
                    this.logEffectApplied(card, effect, wasActive);
                }
            }
            addTeamEffect(entity, effect) {
                if (!entity.teamEffects) entity.teamEffects = [];
                if (!effect.meta) effect.meta = {};
                if (!effect.meta.sourceSide && this.activeSide) effect.meta.sourceSide = this.activeSide;
                entity.teamEffects = entity.teamEffects.filter(e => e.id !== effect.id);
                entity.teamEffects.push(effect);
            }
            getUtilityMultiplierForSide(side) {
                if (!side) return 1;
                const entity = side === 'player' ? this.player : this.opp;
                const active = (entity.teamEffects || []).some(e => e.type === 'l14_util_double' && e.turnsLeft > 0);
                return active ? 2 : 1;
            }
            isUtilityEffect(effect) {
                if (!effect) return false;
                return [
                    'atk_flat',
                    'atk_mult',
                    'crit_chance',
                    'damage_reduction',
                    'damage_taken_mult',
                    'atk_missing_hp',
                    'def_override',
                    'damage_immunity',
                    'hp_drain_pct',
                    'atk_shield_mult',
                    'atk_per_tribe',
                    'pacifist',
                    'l5_mark',
                    'l9_spill',
                    'l9_ult_splash',
                    'infection',
                    'intercept',
                    'damage_redirect_skeletons',
                    'shield',
                    'l16_dice',
                    'l16_suit_badge'
                ].includes(effect.type);
            }
            adjustEffectForUtility(effect, multiplier) {
                if (!effect || multiplier <= 1) return effect;
                const adjusted = { ...effect, meta: { ...effect.meta } };
                switch (adjusted.type) {
                    case 'atk_mult':
                    case 'damage_taken_mult':
                        adjusted.value = 1 + ((adjusted.value - 1) * multiplier);
                        break;
                    case 'crit_chance':
                        adjusted.value = Math.min(1, adjusted.value * multiplier);
                        break;
                    case 'atk_missing_hp':
                        adjusted.meta.bonus = (adjusted.meta.bonus ?? 0) * multiplier;
                        break;
                    case 'atk_per_tribe':
                        adjusted.meta.per = (adjusted.meta.per ?? adjusted.value ?? 0) * multiplier;
                        break;
                    case 'atk_shield_mult':
                        adjusted.value = 1 + ((adjusted.value - 1) * multiplier);
                        if (adjusted.meta.bonusPct !== undefined) adjusted.meta.bonusPct *= multiplier;
                        break;
                    case 'l16_dice':
                        if (adjusted.meta.healChance !== undefined) adjusted.meta.healChance = Math.min(1, adjusted.meta.healChance * multiplier);
                        if (adjusted.meta.atkMult !== undefined) adjusted.meta.atkMult = 1 + ((adjusted.meta.atkMult - 1) * multiplier);
                        break;
                    default:
                        if (typeof adjusted.value === 'number') adjusted.value *= multiplier;
                        break;
                }
                return adjusted;
            }
            isLegendaryOverride(card) {
                return ['L-1', 'L-2', 'L-3', 'L-4'].includes(card.dbId);
            }
            isSupportAction(card, actionType) {
                if (actionType === 'attack') return false;
                if (card.dbId === 'L-1' && actionType === 'skill') return true;
                if (card.dbId === 'L-2' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-3' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-4' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-5' && actionType === 'ult') return true;
                if (card.dbId === 'L-6' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-7' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-8' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-9' && actionType === 'skill') return true;
                if (card.dbId === 'L-10' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-11' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-12' && actionType === 'ult') return true;
                if (card.dbId === 'L-13' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-14' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-15' && actionType === 'ult') return true;
                if (card.dbId === 'L-16' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-17' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-18' && (actionType === 'skill' || actionType === 'ult')) return true;
                if (card.dbId === 'L-19' && (actionType === 'skill' || actionType === 'ult')) return true;
                return false;
            }
            getTargetingMode(card, actionType) {
                if (actionType === 'attack') return 'enemy';
                if (card.dbId === 'L-3' && actionType === 'ult') return 'ally';
                if (card.dbId === 'L-5' && actionType === 'ult') return 'self';
                if (card.dbId === 'L-6' && actionType === 'skill') return 'self';
                if (card.dbId === 'L-6' && actionType === 'ult') return 'ally';
                if (card.dbId === 'L-7' && actionType === 'skill') return 'ally';
                if (card.dbId === 'L-7' && actionType === 'ult') return 'ally_or_enemy';
                if (card.dbId === 'L-8' && actionType === 'skill') return 'self';
                if (card.dbId === 'L-8' && actionType === 'ult') return 'self';
                if (card.dbId === 'L-9' && actionType === 'skill') return 'self';
                if (card.dbId === 'L-10' && (actionType === 'skill' || actionType === 'ult')) return 'self';
                if (card.dbId === 'L-11' && actionType === 'skill') return 'ally_or_enemy';
                if (card.dbId === 'L-11' && actionType === 'ult') return 'self';
                if (card.dbId === 'L-12' && actionType === 'ult') return 'ally';
                if (card.dbId === 'L-13' && actionType === 'skill') return 'graveyard';
                if (card.dbId === 'L-13' && actionType === 'ult') return 'enemy';
                if (card.dbId === 'L-14' && actionType === 'skill') return 'ally';
                if (card.dbId === 'L-14' && actionType === 'ult') return 'self';
                if (card.dbId === 'L-15' && actionType === 'ult') return 'self';
                if (card.dbId === 'L-16' && actionType === 'skill') return 'ally';
                if (card.dbId === 'L-16' && actionType === 'ult') return 'ally';
                if (card.dbId === 'L-17' && (actionType === 'skill' || actionType === 'ult')) return 'self';
                if (card.dbId === 'L-18' && actionType === 'skill') return 'ally';
                if (card.dbId === 'L-18' && actionType === 'ult') return 'enemy';
                if (card.dbId === 'L-19' && (actionType === 'skill' || actionType === 'ult')) return 'self';
                if (this.isSupportAction(card, actionType)) return 'self';
                return 'enemy';
            }
            requiresAllyTarget(card, actionType) {
                return this.getTargetingMode(card, actionType) === 'ally';
            }
            getOwnerEntity(card) {
                return card.owner === 'player' ? this.player : this.opp;
            }
            getCardController(card) {
                return card.controlledBy || card.owner;
            }
            getControllerEntity(card) {
                return this.getCardController(card) === 'player' ? this.player : this.opp;
            }
            syncShieldValue(card) {
                if (!card) return;
                const isSuppressed = this.isTempEffectsSuppressed(card);
                const total = (card.statusEffects || [])
                    .filter(e => {
                        if (e.type !== 'shield' || e.turnsLeft <= 0) return false;
                        if (isSuppressed && !e.meta?.permanent && !e.meta?.ignoreSuppression) return false;
                        return true;
                    })
                    .reduce((sum, e) => {
                        const multiplier = this.getUtilityMultiplierForSide(e.meta?.sourceSide);
                        const value = (e.value || 0) * (multiplier > 1 ? multiplier : 1);
                        return sum + value;
                    }, 0);
                card.shield = Math.max(0, total);
            }
            findCardField(card) {
                const playerKey = Object.keys(this.player.field).find(k => this.player.field[k].uid === card.uid);
                if (playerKey) return { entity: this.player, key: playerKey };
                const oppKey = Object.keys(this.opp.field).find(k => this.opp.field[k].uid === card.uid);
                if (oppKey) return { entity: this.opp, key: oppKey };
                return null;
            }
            getCardByUid(uid) {
                const allCards = [...Object.values(this.player.field), ...Object.values(this.opp.field)];
                return allCards.find(card => card.uid === uid) || null;
            }
            getRuneTargets(controllerSide) {
                const enemyEntity = controllerSide === 'player' ? this.opp : this.player;
                return Object.values(enemyEntity.field).filter(card => this.getActiveEffects(card, 'l15_runa').length > 0);
            }
            logDamageEvent(source, amount, targetName) {
                if (!source || amount <= 0) return;
                this.logAction(`${source.name} causou ${Math.floor(amount)} de dano em ${targetName}.`, this.getCardController(source));
            }
            logHealEvent(source, amount, targetName) {
                if (!source || amount <= 0) return;
                this.logAction(`${source.name} curou ${Math.floor(amount)} de HP em ${targetName}.`, this.getCardController(source));
            }
            logEffectApplied(card, effect, wasActive = false) {
                if (!card || !effect) return;
                const effectName = getEffectLogName(effect);
                const durationText = getEffectLogDurationText(effect);
                const sourceText = getEffectSourceText(effect);
                if (!effectName) return;
                const prefix = wasActive ? `${card.name} renovou` : `${card.name} recebeu`;
                const durationSuffix = durationText ? ` ${durationText}` : '';
                const sourceSuffix = sourceText ? ` (${sourceText})` : '';
                this.logAction(`${prefix} ${effectName}${durationSuffix}.${sourceSuffix}`, effect.meta?.sourceSide || this.activeSide || card.owner);
            }
            logEffectExpired(card, effect) {
                if (!card || !effect) return;
                const effectName = getEffectLogName(effect);
                if (!effectName) return;
                this.logAction(`${effectName} expirou em ${card.name}.`, card.owner);
            }
            startDeckDrawMode(source) {
                this.deckDrawMode = { sourceUid: source?.uid || null };
                ui.updateHUD();
            }
            endDeckDrawMode() {
                this.deckDrawMode = null;
                ui.updateHUD();
            }
            async handleDeckDrawClick() {
                if (!this.deckDrawMode) return;
                if (this.player.deck.length === 0) {
                    this.logAction("Deck vazio.", 'player');
                    this.endDeckDrawMode();
                    return;
                }
                await this.drawCard('player', true);
                this.endDeckDrawMode();
            }
            async ensureOpponentHand(count, opponentSide) {
                const opponent = opponentSide === 'player' ? this.player : this.opp;
                const needed = Math.max(0, count - opponent.hand.length);
                let drawn = 0;
                for (let i = 0; i < needed; i++) {
                    if (opponent.deck.length === 0) break;
                    await this.drawCard(opponentSide, false);
                    drawn += 1;
                }
                return drawn;
            }
            startHandStealMode(source, count = 2) {
                this.handStealMode = { sourceUid: source?.uid || null, remaining: count, stolen: 0 };
                ui.renderHand('opp');
                ui.renderHand('player');
            }
            endHandStealMode() {
                this.handStealMode = null;
                ui.renderHand('opp');
                ui.renderHand('player');
            }
            startHandPickMode({ side = 'opp', onPick = null, onCancel = null } = {}) {
                this.handPickMode = { side, onPick, onCancel };
                ui.renderHand('opp');
                ui.renderHand('player');
            }
            endHandPickMode() {
                this.handPickMode = null;
                ui.renderHand('opp');
                ui.renderHand('player');
            }
            cancelHandPickMode() {
                if (!this.handPickMode) return;
                const { onCancel } = this.handPickMode;
                this.endHandPickMode();
                if (typeof onCancel === 'function') onCancel();
            }
            handleHandPick(uid) {
                if (!this.handPickMode) return;
                const { side, onPick } = this.handPickMode;
                const entity = side === 'player' ? this.player : this.opp;
                const targetIndex = entity.hand.findIndex(card => card.uid === uid);
                if (targetIndex === -1) return;
                const card = entity.hand[targetIndex];
                this.endHandPickMode();
                if (typeof onPick === 'function') onPick(card);
            }
            handleStealCard(uid) {
                if (!this.handStealMode) return;
                const targetIndex = this.opp.hand.findIndex(card => card.uid === uid);
                if (targetIndex === -1) return;
                const card = this.opp.hand.splice(targetIndex, 1)[0];
                card.owner = 'player';
                if (!card.originalOwner) card.originalOwner = 'opp';
                this.player.hand.push(card);
                this.handStealMode.stolen += 1;
                this.handStealMode.remaining -= 1;
                this.logAction(`Jogador roubou 1 carta da m√£o do oponente (${this.handStealMode.stolen}/2).`, 'player');
                if (this.handStealMode.remaining <= 0 || this.opp.hand.length === 0) {
                    if (this.handStealMode.remaining > 0) {
                        this.logAction("N√£o foi poss√≠vel completar 2 roubos por falta de cartas.", 'player');
                    }
                    this.endHandStealMode();
                } else {
                    ui.renderHand('opp');
                    ui.renderHand('player');
                }
            }
            startGraveyardSelectMode({ owner = 'opp', onSelect = null, onCancel = null, allowAny = false } = {}) {
                this.graveyardSelectMode = { owner, onSelect, onCancel, allowAny };
                const gyEl = document.getElementById(owner === 'player' ? 'player-gy' : 'opp-gy');
                if (gyEl) {
                    gyEl.classList.add('graveyard-select-mode');
                    gyEl.onclick = () => {
                        ui.openGraveyardOverlay({
                            owner,
                            mode: 'select',
                            onSelect: (card) => {
                                this.endGraveyardSelectMode();
                                if (typeof onSelect === 'function') onSelect(card);
                            },
                            selectOwner: owner,
                            allowAny
                        });
                    };
                }
            }
            endGraveyardSelectMode() {
                const owner = this.graveyardSelectMode?.owner;
                const gyEl = document.getElementById(owner === 'player' ? 'player-gy' : 'opp-gy');
                if (gyEl) gyEl.classList.remove('graveyard-select-mode');
                this.graveyardSelectMode = null;
                ui.bindGraveyardClicks();
            }
            cancelGraveyardSelectMode() {
                if (!this.graveyardSelectMode) return;
                const { onCancel } = this.graveyardSelectMode;
                this.endGraveyardSelectMode();
                if (typeof onCancel === 'function') onCancel();
            }
            countNecroSummons() {
                const allCards = [...Object.values(this.player.field), ...Object.values(this.opp.field)];
                return allCards.filter(card => card.isNecroSummon).length;
            }
            updateControlledStatusTurns() {
                const allCards = [...Object.values(this.player.field), ...Object.values(this.opp.field)];
                allCards.forEach(card => {
                    if (card.controlledBy && typeof card.controlReleaseTurn === 'number') {
                        const remaining = Math.max(0, card.controlReleaseTurn - this.turnCounter);
                        const effect = card.statusEffects?.find(e => e.type === 'mind_control');
                        if (effect) effect.turnsLeft = Math.max(1, remaining);
                    }
                });
            }
            releaseExpiredControls() {
                const allCards = [...Object.values(this.player.field), ...Object.values(this.opp.field)];
                allCards.forEach(card => {
                    if (card.controlledBy && typeof card.controlReleaseTurn === 'number' && this.turnCounter >= card.controlReleaseTurn) {
                        this.returnControlledCard(card);
                    }
                });
            }
            releaseControlledCards(controllerSide) {
                const allCards = [...Object.values(this.player.field), ...Object.values(this.opp.field)];
                allCards.forEach(card => {
                    if (card.controlledBy === controllerSide) {
                        this.returnControlledCard(card);
                    }
                });
            }
            returnControlledCard(card) {
                if (!card || !card.controlledBy || !card.controlOrigin) return;
                const originOwner = card.controlOrigin.owner;
                const originRow = card.controlOrigin.r;
                const originCol = card.controlOrigin.c;
                const ownerEntity = originOwner === 'player' ? this.player : this.opp;
                const currentField = this.findCardField(card);
                if (currentField) delete currentField.entity.field[currentField.key];

                const tryPlaceInRow = (row) => {
                    for (let c = 0; c < 5; c++) {
                        const key = `${row}-${c}`;
                        if (!ownerEntity.field[key]) {
                            card.r = row;
                            card.c = c;
                            ownerEntity.field[key] = card;
                            return true;
                        }
                    }
                    return false;
                };

                let placed = false;
                const originKey = `${originRow}-${originCol}`;
                if (!ownerEntity.field[originKey]) {
                    card.r = originRow;
                    card.c = originCol;
                    ownerEntity.field[originKey] = card;
                    placed = true;
                }
                if (!placed) {
                    placed = tryPlaceInRow(originRow);
                }
                if (!placed) {
                    const fallbackRow = originOwner === 'player' ? (originRow === 2 ? 3 : 2) : (originRow === 1 ? 0 : 1);
                    placed = tryPlaceInRow(fallbackRow);
                }
                if (!placed) {
                    ownerEntity.gy.push(card);
                    this.logAction(`<strong>${card.name}</strong> retornou ao cemit√©rio.`, originOwner);
                }

                card.controlledBy = null;
                card.controlOrigin = null;
                card.controlMoved = false;
                card.controlReleaseTurn = null;
                card.controlImmune = true;
                if (card.statusEffects) {
                    card.statusEffects = card.statusEffects.filter(e => e.type !== 'mind_control');
                }
                ui.renderField();
                ui.updateHUD();
                ui.updateGraveyardVisuals();
            }
            isBackRowBlocked(source, target) {
                if (!target || typeof target === 'string') return false;
                if (target.owner === source.owner) return false;
                const isMeleeOrTank = source.archetype === 'Melee' || source.archetype === 'Tank';
                if (!isMeleeOrTank) return false;
                const vanguardAccess = this.getActiveEffects(source, 'l18_backrow_access').length > 0;
                if (vanguardAccess) return false;
                const defendingEntity = target.owner === 'player' ? this.player : this.opp;
                const frontRow = target.owner === 'player' ? 2 : 1;
                const backRow = target.owner === 'player' ? 3 : 0;
                const hasFrontRow = Object.values(defendingEntity.field).some(card => card.r === frontRow);
                return hasFrontRow && target.r === backRow;
            }
            effectMatchesCard(effect, card) {
                if (!effect.filters) return true;
                if (effect.filters.tribe && effect.filters.tribe !== card.tribe) return false;
                if (effect.filters.archetype) {
                    if (Array.isArray(effect.filters.archetype)) {
                        if (!effect.filters.archetype.includes(card.archetype)) return false;
                    } else if (effect.filters.archetype !== card.archetype) {
                        return false;
                    }
                }
                if (effect.filters.owner && effect.filters.owner !== card.owner) return false;
                if (effect.filters.targetUid && effect.filters.targetUid !== card.uid) return false;
                return true;
            }
            isTempEffectsSuppressed(card) {
                const owner = this.getOwnerEntity(card);
                return (owner.teamEffects || []).some(e => {
                    if (e.type !== 'suppress_temp_effects' || e.turnsLeft <= 0) return false;
                    if (typeof e.meta?.expiresTurn === 'number') {
                        return this.turnCounter <= e.meta.expiresTurn;
                    }
                    return true;
                });
            }
            getActiveEffects(card, type) {
                this.ensureCardState(card);
                const owner = this.getOwnerEntity(card);
                const isSuppressed = this.isTempEffectsSuppressed(card);
                const filterEffect = (effect) => {
                    if (!effect || effect.turnsLeft <= 0) return false;
                    if (effect.type !== type) return false;
                    if (!this.effectMatchesCard(effect, card)) return false;
                    if (isSuppressed && !effect.meta?.permanent && !effect.meta?.ignoreSuppression) return false;
                    return true;
                };
                const cardEffects = card.statusEffects.filter(filterEffect);
                const teamEffects = (owner.teamEffects || []).filter(filterEffect);
                const allEffects = [...cardEffects, ...teamEffects];
                return allEffects.map(effect => {
                    const multiplier = this.getUtilityMultiplierForSide(effect.meta?.sourceSide);
                    if (multiplier > 1 && this.isUtilityEffect(effect)) {
                        return this.adjustEffectForUtility(effect, multiplier);
                    }
                    return effect;
                });
            }
            getEffectiveAtk(card) {
                this.ensureCardState(card);
                let atk = card.currentAtk;
                const flatBonus = this.getActiveEffects(card, 'atk_flat').reduce((sum, e) => sum + e.value, 0);
                const multBonus = this.getActiveEffects(card, 'atk_mult').reduce((mult, e) => mult * e.value, 1);
                const missingHpEffects = this.getActiveEffects(card, 'atk_missing_hp');
                let missingBonus = 0;
                missingHpEffects.forEach(effect => {
                    const per = effect.meta?.perHp || 30;
                    const bonus = effect.meta?.bonus || 10;
                    const missing = Math.max(0, card.maxHp - card.currentHp);
                    missingBonus += Math.floor(missing / per) * bonus;
                });
                const perTribeEffects = this.getActiveEffects(card, 'atk_per_tribe');
                let tribeBonus = 0;
                perTribeEffects.forEach(effect => {
                    const tribe = effect.meta?.tribe;
                    if (!tribe) return;
                    const ownerEntity = this.getControllerEntity(card);
                    const allies = Object.values(ownerEntity.field).filter(ally => ally.tribe === tribe);
                    tribeBonus += allies.length * (effect.meta?.per ?? effect.value ?? 0);
                });
                atk = (atk + flatBonus + missingBonus + tribeBonus) * multBonus;
                const diceEffects = this.getActiveEffects(card, 'l16_dice');
                diceEffects.forEach(effect => {
                    atk *= effect.meta?.atkMult ?? 1;
                });
                const shieldEffects = this.getActiveEffects(card, 'atk_shield_mult');
                let shieldMult = 1;
                shieldEffects.forEach(effect => {
                    const perShield = effect.meta?.perShield ?? 20;
                    const bonusPct = effect.meta?.bonusPct ?? 0.02;
                    const shield = card.shield || 0;
                    const extra = Math.floor(shield / perShield) * bonusPct;
                    shieldMult *= (effect.value ?? 1) + extra;
                });
                atk *= shieldMult;
                const pacifistPenalty = this.getActiveEffects(card, 'pacifist').length > 0 ? 9999 : 0;
                return Math.max(0, atk - pacifistPenalty);
            }
            getEffectiveDef(card) {
                this.ensureCardState(card);
                const overrides = this.getActiveEffects(card, 'def_override');
                if (overrides.length > 0) return overrides[overrides.length - 1].value;
                return card.currentDef ?? card.def;
            }
            getDamageReduction(card) {
                const reductions = this.getActiveEffects(card, 'damage_reduction').reduce((sum, e) => sum + e.value, 0);
                return Math.min(0.9, Math.max(0, reductions));
            }
            getDamageTakenMultiplier(card) {
                const baseMult = this.getActiveEffects(card, 'damage_taken_mult').reduce((mult, e) => mult * e.value, 1);
                const runeMult = this.getActiveEffects(card, 'l15_runa').reduce((mult, e) => mult * e.value, 1);
                return baseMult * runeMult;
            }
            hasDamageImmunity(card) {
                return this.getActiveEffects(card, 'damage_immunity').length > 0;
            }
            getCritMultiplier(card, actionContext) {
                const totalChance = this.getActiveEffects(card, 'crit_chance').reduce((sum, e) => sum + e.value, 0);
                if (totalChance <= 0) return { isCrit: false, mult: 1 };
                if (totalChance >= 1) return { isCrit: true, mult: 1.3 };
                const isCrit = Math.random() < totalChance;
                return { isCrit, mult: isCrit ? 1.3 : 1 };
            }
            applyDamageToCard(card, damage, options = {}) {
                this.ensureCardState(card);
                const safeDamage = Math.max(0, damage);
                if (safeDamage <= 0) return 0;
                const isFirstPlayerTurnLocked = this.roundNumber === 1 && this.activeSide === this.roundStarter && this.firstPlayerFirstTurnAttackLocked;
                const lockedTargetOwner = this.activeSide === 'player' ? 'opp' : 'player';
                if (isFirstPlayerTurnLocked && card.owner === lockedTargetOwner) return 0;

                const diceEffects = this.getActiveEffects(card, 'l16_dice');
                if (diceEffects.length > 0) {
                    const chance = Math.max(...diceEffects.map(e => e.meta?.healChance ?? 0));
                    if (chance > 0 && Math.random() < chance) {
                        card.currentHp = Math.min(card.maxHp, card.currentHp + safeDamage);
                        const cardEl = document.querySelector(`[data-r="${card.r}"][data-c="${card.c}"]`);
                        ui.showDamage(cardEl, `+${Math.floor(safeDamage)}`, "#39ff14");
                        if (cardEl) {
                            fx.healHearts(cardEl.getBoundingClientRect(), 1);
                            fx.spawnParticles('heal', cardEl.getBoundingClientRect());
                        }
                        return 0;
                    }
                }

                let remainingDamage = safeDamage;
                if (!options.ignoreShield) {
                    const isSuppressed = this.isTempEffectsSuppressed(card);
                    const shieldEffects = (card.statusEffects || []).filter(e => {
                        if (e.type !== 'shield' || e.turnsLeft <= 0 || e.value <= 0) return false;
                        if (isSuppressed && !e.meta?.permanent && !e.meta?.ignoreSuppression) return false;
                        return true;
                    });
                    if (shieldEffects.length > 0 && remainingDamage > 0) {
                        for (const effect of shieldEffects) {
                            if (remainingDamage <= 0) break;
                            const multiplier = this.getUtilityMultiplierForSide(effect.meta?.sourceSide);
                            const effectiveValue = effect.value * (multiplier > 1 ? multiplier : 1);
                            const absorbed = Math.min(effectiveValue, remainingDamage);
                            effect.value = Math.max(0, effect.value - (absorbed / (multiplier > 1 ? multiplier : 1)));
                            remainingDamage -= absorbed;
                        }
                        card.statusEffects = card.statusEffects.filter(e => !(e.type === 'shield' && e.value <= 0));
                        this.syncShieldValue(card);
                    }
                }

                if (remainingDamage > 0) {
                    card.currentHp = Math.max(0, card.currentHp - remainingDamage);
                    const owner = this.getOwnerEntity(card);
                    const leakDamage = Math.max(0, remainingDamage - (owner.def ?? 0));
                    if (leakDamage > 0) {
                        owner.hp = Math.max(0, owner.hp - leakDamage);
                        const hud = card.owner === 'player' ? document.getElementById('hud-player') : document.getElementById('hud-opponent');
                        ui.showDamage(hud, leakDamage);
                    }
                }

                return safeDamage;
            }
            applyStartTurnEffects(entity) {
                // Os efeitos com turnsLeft s√£o reduzidos no in√≠cio do turno do dono.
                if (!entity.teamEffects) entity.teamEffects = [];
                entity.teamEffects.forEach(effect => {
                    if (effect.turnsLeft > 0 && effect.type === 'pa_bonus_start') {
                        Object.values(entity.field).forEach(card => {
                            card.pa = Math.min(10, card.pa + effect.value);
                            ui.showDamage(document.querySelector(`[data-r="${card.r}"][data-c="${card.c}"]`), `+${effect.value} PA`, "#ff00ff");
                        });
                        this.logAction(`PA +${effect.value} para aliados.`, entity === this.player ? 'player' : 'opp');
                    }
                });
                entity.teamEffects.forEach(effect => {
                    if (!effect.meta?.permanent) effect.turnsLeft -= 1;
                });
                entity.teamEffects = entity.teamEffects.filter(effect => effect.turnsLeft > 0);
                Object.values(entity.field).forEach(card => {
                    this.ensureCardState(card);
                    const isSuppressed = this.isTempEffectsSuppressed(card);
                    card.statusEffects.forEach(effect => {
                        if (isSuppressed && !effect.meta?.permanent && !effect.meta?.ignoreSuppression) return;
                        if (effect.turnsLeft > 0 && effect.type === 'pa_bonus_start_card') {
                            card.pa = Math.min(10, card.pa + effect.value);
                            ui.showDamage(document.querySelector(`[data-r="${card.r}"][data-c="${card.c}"]`), `+${effect.value} PA`, "#ff00ff");
                        }
                        if (effect.turnsLeft > 0 && effect.type === 'hp_drain_pct') {
                            // Efeitos de drenagem ocorrem no in√≠cio do turno do dono.
                            const drain = Math.floor(card.currentHp * effect.value);
                            if (drain > 0) {
                                this.applyDamageToCard(card, drain);
                                ui.showDamage(document.querySelector(`[data-r="${card.r}"][data-c="${card.c}"]`), drain, "#ff4444");
                                const sourceName = getEffectSourceCardName(effect) || 'Efeito';
                                this.logAction(`${sourceName} causou ${Math.floor(drain)} de dano em ${card.name}.`, effect.meta?.sourceSide || card.owner);
                                if (card.currentHp <= 0) this.killCard(card);
                            }
                        }
                        if (effect.turnsLeft > 0 && effect.type === 'infection') {
                            const poison = Math.floor(effect.value || 0);
                            if (poison > 0) {
                                this.applyDamageToCard(card, poison);
                                ui.showDamage(document.querySelector(`[data-r="${card.r}"][data-c="${card.c}"]`), poison, "#b300ff");
                                const sourceName = getEffectSourceCardName(effect) || 'Efeito';
                                this.logAction(`${sourceName} causou ${Math.floor(poison)} de dano em ${card.name}.`, effect.meta?.sourceSide || card.owner);
                                if (card.currentHp <= 0) this.killCard(card);
                            }
                        }
                    });
                    const expiring = [];
                    card.statusEffects.forEach(effect => {
                        if (!effect.meta?.permanent) {
                            const wasActive = effect.turnsLeft > 0;
                            effect.turnsLeft -= 1;
                            if (wasActive && effect.turnsLeft <= 0) expiring.push(effect);
                        }
                    });
                    card.statusEffects = card.statusEffects.filter(effect => effect.turnsLeft > 0);
                    expiring.forEach(effect => this.logEffectExpired(card, effect));
                    this.syncShieldValue(card);
                    if (card.nextAttackFree && typeof card.nextAttackFree.turnsLeft === 'number') {
                        card.nextAttackFree.turnsLeft -= 1;
                        if (card.nextAttackFree.turnsLeft <= 0) card.nextAttackFree = null;
                    }
                });
                if (typeof ui !== 'undefined') ui.updateInfoPanel();
            }
            initGrid() {
                const grid = document.getElementById('board-grid');
                grid.innerHTML = '';
                const rowClasses = ['back', 'front', 'front', 'back'];
                for(let r=0; r<4; r++) {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = `row ${rowClasses[r]}`;
                    rowDiv.id = `row-${r}`;
                    for(let c=0; c<5; c++) {
                        const slot = document.createElement('div');
                        slot.className = 'slot';
                        slot.dataset.r = r; slot.dataset.c = c;
                        slot.onclick = () => game.handleGridClick(r, c);
                        rowDiv.appendChild(slot);
                    }
                    grid.appendChild(rowDiv);
                }
                // Inicializar visual do temporizador
                ui.initTimerVisuals();
            }
            logAction(message, side) {
                const logPanel = document.getElementById('log-player');
                if (logPanel) {
                    const entry = document.createElement('div');
                    entry.className = 'log-entry';
                    const color = side === 'player' ? 'var(--neon-green)' : 'var(--neon-red)';
                    entry.style.color = '#e1e1e6'; 
                    const prefix = side === 'player' ? '' : 'IA: ';
                    entry.innerHTML = `<span style="color:${color}">T${this.roundNumber}:</span> ${prefix}${message}`;
                    logPanel.appendChild(entry); 
                    logPanel.scrollTop = logPanel.scrollHeight;
                }
            }
            async drawCard(who, animate=true) {
                const entity = who === 'player' ? this.player : this.opp;
                if (entity.deck.length === 0) return; 
                if(animate) await ui.animateDraw(who);
                const card = entity.deck.pop();
                card.owner = who;
                if (!card.originalOwner) card.originalOwner = who;
                entity.hand.push(card);
                ui.renderHand(who);
                ui.updateHUD(); 
            }
            async startMatch(winner) {
                document.getElementById('turn-indicator').innerText = "DISTRIBUINDO CARTAS...";
                for(let i=0; i<5; i++) {
                    await this.drawCard('player', true);
                    await this.drawCard('opp', false);
                    await new Promise(r => setTimeout(r, 200));
                }
                await new Promise(r => setTimeout(r, 500));
                const firstSide = winner === 'enemy' ? 'enemy' : 'player';
                this.roundStarter = firstSide;
                this.startTurn(firstSide, true);
            }
            startTurn(who, isNewRound = false) {
                clearInterval(this.timerInterval);
                this.turnCounter += 1;
                this.resetInteraction();
                this.activeSide = who;
                this.phase = 'main';
                this.updateControlledStatusTurns();
                this.releaseExpiredControls();
                if (this.roundNumber === 0) {
                    this.roundNumber = 1;
                } else if (isNewRound) {
                    this.roundNumber++;
                }
                document.getElementById('turn-info').innerText = `Turno: ${this.roundNumber}`;
                const isPlayerTurn = who === 'player';
                const sideKey = isPlayerTurn ? 'player' : 'opp';
                const fieldCount = Object.keys(isPlayerTurn ? this.player.field : this.opp.field).length;
                this.timer = 60 + (fieldCount * 10);
                document.getElementById('timer').innerText = this.timer;
                // Atualizar visual do temporizador para cheio
                ui.updateTimerVisuals(this.timer);
                this.player.pi = 7;
                this.opp.pi = 7;
                [this.player, this.opp].forEach(ent => {
                    Object.values(ent.field).forEach(c => {
                        if(c.pa < 10) c.pa = Math.min(10, c.pa + 2);
                        c.hasActed = false; 
                        c.turnActionUses = { skill: 0, ult: 0 };
                    });
                });
                this.applyStartTurnEffects(isPlayerTurn ? this.player : this.opp);
                ui.updateHUD();
                ui.renderField();
                ui.renderHand('player'); 
                document.getElementById('turn-indicator').innerText = isPlayerTurn ? "SEU TURNO" : "TURNO DO OPONENTE";
                document.getElementById('btn-pass').disabled = !isPlayerTurn;
                const drawCount = 2;
                const phaseDraw = async () => {
                    for(let i=0; i<drawCount; i++) {
                        await this.drawCard(sideKey, isPlayerTurn);
                        await new Promise(r => setTimeout(r, 300));
                    }
                    this.startTimer();
                    if (!isPlayerTurn) {
                        setTimeout(() => ai.executeTurn(), 2000);
                    }
                };
                phaseDraw();
            }
            startTimer() {
                clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    this.timer--;
                    document.getElementById('timer').innerText = this.timer;
                    // Atualizar visual dos pontos
                    ui.updateTimerVisuals(this.timer);

                    if (this.timer <= 0) this.passTurn();
                }, 1000);
            }
            passTurn() {
                clearInterval(this.timerInterval);
                this.resetInteraction();
                if (this.deckDrawMode) this.endDeckDrawMode();
                if (this.handStealMode) this.endHandStealMode();
                if (this.handPickMode) this.endHandPickMode();
                if (this.graveyardSelectMode) this.cancelGraveyardSelectMode();
                if (this.roundNumber === 1 && this.activeSide === this.roundStarter && this.firstPlayerFirstTurnAttackLocked) {
                    this.firstPlayerFirstTurnAttackLocked = false;
                }
                const next = this.activeSide === 'player' ? 'enemy' : 'player';
                const isNewRound = next === this.roundStarter;
                this.startTurn(next, isNewRound);
            }
            resetInteraction() {
                this.interactionMode = 'none';
                this.activeCard = null;
                this.validSlots = [];
                ui.clearHighlights();
                document.body.classList.remove('cursor-sword'); 
            }
            handleGridClick(r, c) {
                const key = `${r}-${c}`;
                if (this.interactionMode === 'summon') {
                    if (this.validSlots.includes(key)) {
                        const slotEl = document.querySelector(`.slot[data-r="${r}"][data-c="${c}"]`);
                        ui.runSummonAnimation(this.activeCard, slotEl, r, c);
                        this.resetInteraction();
                    }
                    return;
                }
                if (this.interactionMode === 'target') {
                    if (this.validSlots.includes(key)) {
                        const targetCard = this.opp.field[key] || this.player.field[key]; 
                        if (targetCard) {
                            this.executeAction(this.pendingActionType, this.activeCard, targetCard);
                            this.resetInteraction();
                        }
                    }
                    return;
                }
                if (this.interactionMode === 'utility') {
                    if (this.validSlots.includes(key)) {
                        const targetCard = this.player.field[key] || this.opp.field[key]; 
                        if (targetCard) {
                            this.applyUtility(this.activeCard, targetCard);
                            this.resetInteraction();
                        }
                    }
                    return;
                }
                if (this.interactionMode === 'move') {
                    if (this.validSlots.includes(key)) {
                        this.executeMove(r, c);
                    }
                    return;
                }
                if (this.interactionMode === 'control_move') {
                    if (this.validSlots.includes(key)) {
                        this.executeControlledMove(r, c);
                    }
                    return;
                }
                if (this.interactionMode === 'none') {
                    const card = this.player.field[key] || this.opp.field[key];
                    if (card) ui.openFieldModal(card);
                }
            }
            commitSummon(card, r, c) {
                if (card.rarity === 'utility') return;
                const entity = this.activeSide === 'player' ? this.player : this.opp;
                entity.hand = entity.hand.filter(h => h.uid !== card.uid);
                entity.pi -= card.piCost;
                card.r = r; card.c = c;
                card.currentHp = card.hp;
                card.currentAtk = card.atk;
                card.currentDef = card.def;
                this.ensureCardState(card);
                entity.field[`${r}-${c}`] = card;
                const sideKey = this.activeSide === 'player' ? 'player' : 'opp';
                this.logAction(`Invocou <strong>${card.name}</strong>.`, sideKey);
                ui.renderHand(sideKey);
                ui.renderField();
                ui.updateHUD();
                const slotEl = document.querySelector(`.slot[data-r="${r}"][data-c="${c}"]`);
                if (slotEl) {
                    fx.spawnParticles('summon', slotEl.getBoundingClientRect());
                }
            }
            applyUtility(utilCard, targetCard) {
                const entity = utilCard.owner === 'player' ? this.player : this.opp;
                entity.hand = entity.hand.filter(h => h.uid !== utilCard.uid);
                entity.pi -= utilCard.piCost;
                if (utilCard.effectType === 'add_pa') {
                    const multiplier = this.getUtilityMultiplierForSide(utilCard.owner);
                    const paGain = 3 * multiplier;
                    targetCard.pa = Math.min(10, targetCard.pa + paGain);
                    ui.showDamage(document.querySelector(`[data-r="${targetCard.r}"][data-c="${targetCard.c}"]`), `+${paGain} PA`, "#ff00ff");
                    const tEl = document.querySelector(`[data-r="${targetCard.r}"][data-c="${targetCard.c}"]`);
                    if (tEl) {
                        fx.spawnParticles('buff', tEl.getBoundingClientRect());
                        fx.spawnRunes(tEl.getBoundingClientRect(), 2);
                    }
                }
                entity.gy.push(utilCard);
                this.logAction(`Usou item <strong>${utilCard.name}</strong> em ${targetCard.name}.`, utilCard.owner);
                ui.renderField();
                ui.renderHand(entity === this.player ? 'player' : 'opp');
                ui.updateHUD();
                ui.updateGraveyardVisuals();
            }
            async executeAction(actionType, source, target) {
                const isFirstPlayerTurnLocked = this.roundNumber === 1 && this.activeSide === this.roundStarter && this.firstPlayerFirstTurnAttackLocked;
                const targetMode = this.getTargetingMode(source, actionType);
                const sourceController = this.getCardController(source);
                if (isFirstPlayerTurnLocked) {
                    if (actionType === 'attack' || targetMode !== 'self') return;
                }
                if (source.dbId === 'L-11' && actionType === 'skill' && this.isL11Drunk(source)) {
                    this.logAction("Habilidade bloqueada: L-11 est√° b√™bada.", sourceController);
                    return;
                }
                let cost = this.getActionCost(source, actionType); let multiplier = 1; let isSkill = false; let isUlt = false;
                if (actionType === 'attack') { multiplier = 1; }
                if (actionType === 'skill') { multiplier = 1.2; isSkill = true; }
                if (actionType === 'ult') { multiplier = 2.5; isUlt = true; }
                const isSupport = this.isSupportAction(source, actionType);
                if (targetMode === 'self') target = source;
                const targetController = (target && typeof target !== 'string') ? this.getCardController(target) : null;
                if (targetMode === 'ally' && (!target || targetController !== sourceController)) return;
                if (targetMode === 'enemy' && target && typeof target !== 'string' && targetController === sourceController) return;
                if (targetMode === 'ally_or_enemy' && (!target || typeof target === 'string')) return;
                if ((targetMode === 'enemy' || targetMode === 'ally_or_enemy') && !(source.dbId === 'L-11' && actionType === 'skill') && this.isBackRowBlocked(source, target)) {
                    this.logAction("Alvo inv√°lido: frente inimiga ainda est√° ocupada.", sourceController);
                    return;
                }
                if (source.dbId === 'L-13' && actionType === 'ult' && target && typeof target !== 'string') {
                    if (target.controlImmune || target.controlledBy) {
                        this.logAction("Controle mental falhou: alvo j√° controlado.", sourceController);
                        return;
                    }
                }
                if (!this.canUseAction(source, actionType)) {
                    this.logAction("Limite de usos por turno atingido.", sourceController);
                    return;
                }
                if (source.dbId === 'L-15' && actionType === 'ult') {
                    const runeTargets = this.getRuneTargets(sourceController);
                    if (runeTargets.length === 0) {
                        this.logAction("Ultimate indispon√≠vel: nenhuma Runa em campo", sourceController);
                        return;
                    }
                }
                const canUseFree = actionType === 'attack' && source.nextAttackFree && source.nextAttackFree.turnsLeft > 0;
                if (!canUseFree && source.pa < cost) return;
                if (!canUseFree) source.pa -= cost;
                if (canUseFree) source.nextAttackFree = null;
                if (source.dbId === 'L-11' && (actionType === 'skill' || actionType === 'ult')) {
                    this.ensureCardState(source);
                    source.turnActionUses[actionType] = (source.turnActionUses[actionType] || 0) + 1;
                }
                if (actionType === 'skill' || actionType === 'ult') {
                    const actionName = actionType === 'skill' ? (source.habName || 'Habilidade') : (source.ultName || 'Ultimate');
                    const targetLabel = targetMode === 'self' ? source.name : (target && typeof target !== 'string' ? target.name : 'L√≠der Inimigo');
                    this.logAction(`${source.name} usou ${actionName} em ${targetLabel}.`, sourceController);
                }
                source.hasActed = true; 
                if (isSupport) {
                    await this.executeSupportAction(actionType, source, target || source);
                    if (actionType === 'skill' || actionType === 'ult') {
                        source.nextAttackFree = { turnsLeft: 1 };
                    }
                    ui.renderField();
                    ui.updateHUD();
                    return;
                }
                if (isUlt && source.dbId === 'L-1') {
                    this.addStatusEffect(source, {
                        id: `l1_ult_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'atk_mult',
                        value: 2,
                        turnsLeft: 1,
                        filters: {},
                        meta: {}
                    });
                }
                let rawDmg = this.getEffectiveAtk(source) * multiplier;
                let ignoreDef = false;
                let l15SkillBonus = 1;
                if (isSkill && source.dbId === 'L-15') {
                    rawDmg = this.getEffectiveAtk(source);
                    l15SkillBonus = 1.15;
                }
                if (isSkill && !this.isLegendaryOverride(source)) {
                     if (source.effectType === 'buff_self_atk') source.currentAtk += 30;
                     if (source.effectType === 'lifesteal') source.currentAtk += 20;
                     if (source.effectType === 'splash') source.currentAtk += 10; 
                     if (source.effectType === 'pierce_and_party_heal') ignoreDef = true;
                }
                if (isUlt && source.effectType === 'buff_self_atk' && !this.isLegendaryOverride(source)) source.currentAtk += 150;
                if (isSkill && source.dbId === 'L-5' && typeof target !== 'string') {
                    this.addStatusEffect(target, {
                        id: `l5_mark_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'l5_mark',
                        value: 0,
                        turnsLeft: 2,
                        filters: {},
                        meta: { sourceOwner: sourceController }
                    });
                    this.addStatusEffect(target, {
                        id: `l5_vuln_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'damage_taken_mult',
                        value: 1.2,
                        turnsLeft: 2,
                        filters: {},
                        meta: {}
                    });
                    const targetEl = document.querySelector(`[data-r="${target.r}"][data-c="${target.c}"]`);
                    if (targetEl) {
                        fx.spawnParticles('debuff', targetEl.getBoundingClientRect());
                    }
                }
                let targetDef = 0; let targetName = "";
                if (target === 'player_avatar' || target === 'opp_avatar') {
                    const victim = target === 'player_avatar' ? this.player : this.opp;
                    targetDef = ignoreDef ? 0 : victim.def;
                    targetName = "L√≠der Inimigo";
                } else {
                    this.ensureCardState(target);
                    targetDef = ignoreDef ? 0 : this.getEffectiveDef(target);
                    targetName = target.name;
                }
                let finalDmg = Math.max(0, rawDmg - targetDef);
                const critInfo = this.getCritMultiplier(source, 'damage');
                if (critInfo.isCrit) {
                    finalDmg *= critInfo.mult;
                    this.logAction(`<strong>CR√çTICO!</strong>`, sourceController);
                }
                if (l15SkillBonus !== 1) {
                    finalDmg *= l15SkillBonus;
                }
                const sourceSlot = document.querySelector(`.slot[data-r="${source.r}"][data-c="${source.c}"]`);
                const targetSlot = (target === 'player_avatar')
                    ? document.getElementById('hud-player')
                    : (target === 'opp_avatar')
                        ? document.getElementById('hud-opponent')
                        : (target && typeof target !== 'string')
                            ? document.querySelector(`.slot[data-r="${target.r}"][data-c="${target.c}"]`)
                            : null;
                const sourceRect = sourceSlot ? sourceSlot.getBoundingClientRect() : null;
                const targetRect = targetSlot ? targetSlot.getBoundingClientRect() : null;
                const sfxKey = isUlt ? 'ult' : (isSkill ? 'skill' : 'attack');
                fx.spawnParticles(sfxKey, sourceRect, targetRect);
                await ui.showCinematicDuel(source, target, actionType, finalDmg);
                if (actionType === 'skill') await ui.animateSkillHadoukenBoard(source, target);
                else await ui.animateBoardProjectile(source, target);
                let resolvedTarget = target;
                if (typeof target !== 'string') {
                    const interceptEffect = target.statusEffects?.find(e => e.type === 'intercept' && e.turnsLeft > 0);
                    if (interceptEffect) {
                        const ownerField = target.owner === 'player' ? this.player.field : this.opp.field;
                        const interceptor = Object.values(ownerField).find(c => c.uid === interceptEffect.meta?.sourceUid);
                        if (interceptor) {
                            resolvedTarget = interceptor;
                            this.logAction(`Dano interceptado por <strong>${interceptor.name}</strong>!`, target.owner);
                        } else {
                            target.statusEffects = target.statusEffects.filter(e => e.id !== interceptEffect.id);
                        }
                    }
                }
                const pacifistActive = this.getActiveEffects(source, 'pacifist').length > 0;
                if (pacifistActive) finalDmg = 0;
                if (resolvedTarget === 'player_avatar' || resolvedTarget === 'opp_avatar') {
                    if (isFirstPlayerTurnLocked) return;
                    const victim = resolvedTarget === 'player_avatar' ? this.player : this.opp;
                    victim.hp -= finalDmg;
                    const hudEl = resolvedTarget === 'player_avatar' ? document.getElementById('hud-player') : document.getElementById('hud-opponent');
                    ui.showDamage(hudEl, finalDmg);
                    fx.hitFlash(hudEl);
                    this.logDamageEvent(source, finalDmg, targetName);
                    if (isUlt) {
                        fx.screenShake(1.4, 450);
                        hudEl?.classList.add('fx-ult-impact');
                        setTimeout(() => hudEl?.classList.remove('fx-ult-impact'), 320);
                    }
                } else {
                    const takenMult = this.getDamageTakenMultiplier(resolvedTarget);
                    if (takenMult !== 1) finalDmg *= takenMult;
                    if (this.hasDamageImmunity(resolvedTarget)) finalDmg = 0;
                    const reduction = this.getDamageReduction(resolvedTarget);
                    if (reduction > 0) finalDmg *= (1 - reduction);
                    if (resolvedTarget.dbId === 'L-8' && this.getActiveEffects(resolvedTarget, 'damage_redirect_skeletons').length > 0) {
                        const ownerField = resolvedTarget.owner === 'player' ? this.player.field : this.opp.field;
                        // Redistribui 20% do dano recebido entre Esqueletos aliados (exclui o pr√≥prio L-8).
                        const skeletonAllies = Object.values(ownerField).filter(ally => ally.uid !== resolvedTarget.uid && ally.tribe === 'Esqueletos');
                        if (skeletonAllies.length > 0 && finalDmg > 0) {
                            const redirectTotal = finalDmg * 0.2;
                            const perAlly = redirectTotal / skeletonAllies.length;
                            this.applyDamageToCard(resolvedTarget, finalDmg - redirectTotal);
                            const resolvedEl = document.querySelector(`[data-r="${resolvedTarget.r}"][data-c="${resolvedTarget.c}"]`);
                            ui.showDamage(resolvedEl, finalDmg - redirectTotal);
                            fx.hitFlash(resolvedEl);
                            this.logDamageEvent(source, finalDmg - redirectTotal, resolvedTarget.name);
                            for (const ally of skeletonAllies) {
                                this.applyDamageToCard(ally, perAlly);
                                const allyEl = document.querySelector(`[data-r="${ally.r}"][data-c="${ally.c}"]`);
                                ui.showDamage(allyEl, perAlly, "#b300ff");
                                fx.hitFlash(allyEl);
                                this.logDamageEvent(source, perAlly, ally.name);
                                if (ally.currentHp <= 0) this.killCard(ally);
                            }
                        } else {
                            this.applyDamageToCard(resolvedTarget, finalDmg);
                            const resolvedEl = document.querySelector(`[data-r="${resolvedTarget.r}"][data-c="${resolvedTarget.c}"]`);
                            ui.showDamage(resolvedEl, finalDmg);
                            fx.hitFlash(resolvedEl);
                            this.logDamageEvent(source, finalDmg, resolvedTarget.name);
                        }
                    } else {
                        this.applyDamageToCard(resolvedTarget, finalDmg);
                        const resolvedEl = document.querySelector(`[data-r="${resolvedTarget.r}"][data-c="${resolvedTarget.c}"]`);
                        ui.showDamage(resolvedEl, finalDmg);
                        fx.hitFlash(resolvedEl);
                        this.logDamageEvent(source, finalDmg, resolvedTarget.name);
                    }
                    const effectiveDef = this.getEffectiveDef(resolvedTarget);
                    if (actionType === 'attack' && effectiveDef > source.currentAtk && !ignoreDef) {
                        const reflect = effectiveDef - source.currentAtk;
                        this.applyDamageToCard(source, reflect);
                        const sourceEl = document.querySelector(`[data-r="${source.r}"][data-c="${source.c}"]`);
                        ui.showDamage(sourceEl, reflect, '#fff');
                        fx.hitFlash(sourceEl);
                        this.logDamageEvent(resolvedTarget, reflect, source.name);
                    }
                }
                if (typeof resolvedTarget !== 'string') {
                    const tryStealPa = (card) => {
                        if (!card || typeof card === 'string') return false;
                        if (card.pa <= 0) return false;
                        card.pa = Math.max(0, card.pa - 1);
                        const targetEl = document.querySelector(`[data-r="${card.r}"][data-c="${card.c}"]`);
                        ui.showDamage(targetEl, "-1 PA", "#ff4444");
                        if (targetEl) {
                            fx.spawnParticles('debuff', targetEl.getBoundingClientRect());
                        }
                        return true;
                    };
                    if (finalDmg > 0) {
                        let paStealTriggered = false;
                        if (actionType === 'attack') {
                            const guaranteedSteal = this.getActiveEffects(source, 'next_attack_steal_pa');
                            if (guaranteedSteal.length > 0) {
                                tryStealPa(resolvedTarget);
                                source.statusEffects = source.statusEffects.filter(e => e.type !== 'next_attack_steal_pa');
                                paStealTriggered = true;
                            }
                        }
                        const stealEffects = this.getActiveEffects(source, 'pa_steal_on_damage');
                        if (!paStealTriggered && stealEffects.length > 0) {
                            const maxChance = Math.max(...stealEffects.map(effect => effect.chance ?? effect.value ?? 0));
                            if (maxChance > 0 && Math.random() < maxChance) {
                                tryStealPa(resolvedTarget);
                            }
                        }
                    }
                    if (source.dbId === 'L-12' && isSkill) {
                        const poison = Math.floor(this.getEffectiveAtk(source) * 0.2);
                        this.addStatusEffect(resolvedTarget, {
                            id: `l12_infect_${source.uid}_${resolvedTarget.uid}`,
                            sourceDbId: source.dbId,
                            type: 'infection',
                            value: poison,
                            turnsLeft: 2,
                            filters: {},
                            meta: { sourceUid: source.uid }
                        });
                        const targetEl = document.querySelector(`[data-r="${resolvedTarget.r}"][data-c="${resolvedTarget.c}"]`);
                        ui.showDamage(targetEl, "INFECTADO", "#b300ff");
                        if (targetEl) {
                            fx.spawnParticles('debuff', targetEl.getBoundingClientRect());
                        }
                    }
                    if (source.dbId === 'L-15' && isSkill) {
                        this.addStatusEffect(resolvedTarget, {
                            id: `l15_runa_${resolvedTarget.uid}`,
                            sourceDbId: source.dbId,
                            type: 'l15_runa',
                            value: 1.15,
                            turnsLeft: 3,
                            filters: {},
                            meta: { silentLog: true }
                        });
                        const targetEl = document.querySelector(`[data-r="${resolvedTarget.r}"][data-c="${resolvedTarget.c}"]`);
                        if (targetEl) {
                            fx.spawnParticles('debuff', targetEl.getBoundingClientRect());
                            fx.spawnRunes(targetEl.getBoundingClientRect(), 3);
                        }
                        this.logAction(`${resolvedTarget.name} foi marcado com Runa por 3 turnos.`, sourceController);
                    }
                    if (source.dbId === 'L-12' && this.getActiveEffects(resolvedTarget, 'infection').length > 0 && finalDmg > 0) {
                        const enemyEntity = resolvedTarget.owner === 'player' ? this.player : this.opp;
                        const infected = Object.values(enemyEntity.field).filter(card => this.getActiveEffects(card, 'infection').length > 0);
                        const spreadDamage = finalDmg * 0.5;
                        infected.forEach(card => {
                            this.applyDamageToCard(card, spreadDamage, { isSplash: true });
                            const cardEl = document.querySelector(`[data-r="${card.r}"][data-c="${card.c}"]`);
                            ui.showDamage(cardEl, spreadDamage, "#b300ff");
                            fx.hitFlash(cardEl);
                            this.logDamageEvent(source, spreadDamage, card.name);
                            if (card.currentHp <= 0) this.killCard(card);
                        });
                    }
                    if (source.dbId === 'L-9' && finalDmg > 0 && this.getActiveEffects(source, 'l9_spill').length > 0) {
                        const enemyFrontRow = source.owner === 'player' ? 1 : 2;
                        const enemyBackRow = source.owner === 'player' ? 0 : 3;
                        if (resolvedTarget.owner !== source.owner && resolvedTarget.r === enemyFrontRow) {
                            const enemyEntity = resolvedTarget.owner === 'player' ? this.player : this.opp;
                            const spillDamage = finalDmg * 0.3;
                            Object.values(enemyEntity.field).forEach(enemy => {
                                if (enemy.r === enemyBackRow) {
                                    this.applyDamageToCard(enemy, spillDamage, { skipReflect: true, isSplash: true });
                                    const enemyEl = document.querySelector(`[data-r="${enemy.r}"][data-c="${enemy.c}"]`);
                                    ui.showDamage(enemyEl, spillDamage, "#8ff7ff");
                                    fx.hitFlash(enemyEl);
                                    this.logDamageEvent(source, spillDamage, enemy.name);
                                    if (enemy.currentHp <= 0) this.killCard(enemy);
                                }
                            });
                        }
                    }
                    if (source.dbId === 'L-9' && isUlt && finalDmg > 0) {
                        const enemyEntity = resolvedTarget.owner === 'player' ? this.player : this.opp;
                        const splashDmg = finalDmg * 0.75;
                        Object.values(enemyEntity.field).forEach(enemy => {
                            this.applyDamageToCard(enemy, splashDmg, { skipReflect: true, isSplash: true });
                            const enemyEl = document.querySelector(`[data-r="${enemy.r}"][data-c="${enemy.c}"]`);
                            ui.showDamage(enemyEl, splashDmg, "#33e6ff");
                            fx.hitFlash(enemyEl);
                            this.logDamageEvent(source, splashDmg, enemy.name);
                            if (enemy.currentHp <= 0) this.killCard(enemy);
                        });
                        this.addStatusEffect(source, {
                            id: `l9_ult_${source.uid}_${Date.now()}`,
                            sourceDbId: source.dbId,
                            type: 'l9_ult_splash',
                            value: 0,
                            turnsLeft: 1,
                            filters: {},
                            meta: {}
                        });
                    }
                }
                if (source.dbId === 'L-10' && this.getActiveEffects(source, 'l10_skill_active').length > 0) {
                    this.addStatusEffect(source, {
                        id: `l10_skill_shield_${source.uid}_${Date.now()}`,
                        sourceDbId: source.dbId,
                        type: 'shield',
                        value: 20,
                        turnsLeft: 3,
                        filters: {},
                        meta: {}
                    });
                    this.syncShieldValue(source);
                }
                const healCritInfo = this.getCritMultiplier(source, 'heal');
                if (healCritInfo.isCrit) this.logAction(`<strong>CR√çTICO!</strong>`, sourceController);
                if (isUlt && source.effectType === 'lifesteal' && !this.isLegendaryOverride(source)) {
                    const heal = finalDmg * 0.5 * healCritInfo.mult;
                    source.currentHp = Math.min(source.maxHp, source.currentHp + heal);
                    const srcEl = document.querySelector(`[data-r="${source.r}"][data-c="${source.c}"]`);
                    if (srcEl) {
                        fx.healHearts(srcEl.getBoundingClientRect(), 3);
                        fx.spawnParticles('heal', srcEl.getBoundingClientRect());
                    }
                    this.logHealEvent(source, heal, source.name);
                }
                if (isUlt && source.effectType === 'splash' && typeof target !== 'string' && !this.isLegendaryOverride(source)) {
                    const splashDmg = finalDmg * 0.5;
                    const enemyField = target.owner === 'player' ? this.player.field : this.opp.field;
                    Object.values(enemyField).forEach(enemy => {
                         if(enemy.uid !== target.uid) {
                             this.applyDamageToCard(enemy, splashDmg);
                             this.logDamageEvent(source, splashDmg, enemy.name);
                             if(enemy.currentHp <= 0) this.killCard(enemy);
                         }
                    });
                }
                if (isUlt && source.effectType === 'pierce_and_party_heal' && !this.isLegendaryOverride(source)) {
                     const healAmount = finalDmg * 0.5 * healCritInfo.mult;
                     const allies = source.owner === 'player' ? this.player.field : this.opp.field;
                     Object.values(allies).forEach(ally => {
                         if(ally.currentHp > 0) ally.currentHp = Math.min(ally.maxHp, ally.currentHp + healAmount);
                     });
                     Object.values(allies).forEach(ally => {
                         const allyEl = document.querySelector(`[data-r="${ally.r}"][data-c="${ally.c}"]`);
                         if (allyEl) {
                             fx.healHearts(allyEl.getBoundingClientRect(), 2);
                             fx.spawnParticles('heal', allyEl.getBoundingClientRect());
                         }
                         this.logHealEvent(source, healAmount, ally.name);
                     });
                }
                if (typeof resolvedTarget !== 'string') {
                    const l5Marks = this.getActiveEffects(resolvedTarget, 'l5_mark');
                    const hasL5Mark = l5Marks.some(mark => mark.meta?.sourceOwner === sourceController);
                    if (hasL5Mark && finalDmg > 0) {
                        const heal = finalDmg * 0.2;
                        source.currentHp = Math.min(source.maxHp, source.currentHp + heal);
                        ui.showDamage(document.querySelector(`[data-r="${source.r}"][data-c="${source.c}"]`), `+${Math.floor(heal)}`, "#39ff14");
                        const srcEl = document.querySelector(`[data-r="${source.r}"][data-c="${source.c}"]`);
                        if (srcEl) {
                            fx.healHearts(srcEl.getBoundingClientRect(), 2);
                            fx.spawnParticles('heal', srcEl.getBoundingClientRect());
                        }
                        this.logHealEvent(source, heal, source.name);
                    }
                }
                if (typeof resolvedTarget !== 'string' && resolvedTarget.currentHp <= 0) await this.killCard(resolvedTarget);
                if (source.currentHp <= 0) await this.killCard(source);
                if (actionType === 'skill' || actionType === 'ult') {
                    source.nextAttackFree = { turnsLeft: 1 };
                }
                ui.renderField();
                ui.updateHUD();
                this.checkWin();
            }
            async executeSupportAction(actionType, source, target) {
                const owner = this.getControllerEntity(source);
                const getCardEl = (card) => document.querySelector(`[data-r="${card.r}"][data-c="${card.c}"]`);
                if (source.dbId === 'L-1' && actionType === 'skill') {
                    const allies = Object.values(owner.field);
                    allies.forEach(ally => {
                        if (ally.uid === source.uid || ally.tribe === 'Guerreiro') {
                            this.addStatusEffect(ally, {
                                id: `l1_skill_${source.uid}`,
                                sourceDbId: source.dbId,
                                type: 'atk_flat',
                                value: 50,
                                turnsLeft: 3,
                                filters: {},
                                meta: {}
                            });
                            const allyEl = getCardEl(ally);
                            ui.showDamage(allyEl, "+50 ATK", "#ffd700");
                            if (allyEl) {
                                fx.spawnParticles('buff', allyEl.getBoundingClientRect());
                                fx.spawnRunes(allyEl.getBoundingClientRect(), 2);
                            }
                        }
                    });
                    this.logAction(`Buff aplicado por <strong>${source.name}</strong>.`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-2' && actionType === 'skill') {
                    const allies = Object.values(owner.field);
                    allies.forEach(ally => {
                        if (ally.archetype === 'Ranged' || ally.archetype === 'Suporte') {
                            this.addStatusEffect(ally, {
                                id: `l2_skill_${source.uid}`,
                                sourceDbId: source.dbId,
                                type: 'crit_chance',
                                value: 0.2,
                                turnsLeft: 2,
                                filters: {},
                                meta: {}
                            });
                            const allyEl = getCardEl(ally);
                            ui.showDamage(allyEl, "+20% CRIT", "#ffd700");
                            if (allyEl) {
                                fx.spawnParticles('buff', allyEl.getBoundingClientRect());
                                fx.spawnRunes(allyEl.getBoundingClientRect(), 2);
                            }
                        }
                    });
                    source.nextAttackFree = { turnsLeft: 1 };
                    this.logAction(`Chance de cr√≠tico aumentada!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-2' && actionType === 'ult') {
                    const allies = Object.values(owner.field);
                    allies.forEach(ally => {
                        this.addStatusEffect(ally, {
                            id: `l2_ult_${source.uid}`,
                            sourceDbId: source.dbId,
                            type: 'crit_chance',
                            value: 1,
                            turnsLeft: 1,
                            filters: {},
                            meta: {}
                        });
                        const allyEl = getCardEl(ally);
                        ui.showDamage(allyEl, "CRIT 100%", "#ffd700");
                        if (allyEl) {
                            fx.spawnParticles('buff', allyEl.getBoundingClientRect());
                            fx.spawnRunes(allyEl.getBoundingClientRect(), 2);
                        }
                    });
                    source.nextAttackFree = { turnsLeft: 1 };
                    this.logAction(`Cr√≠tico garantido para o time!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-3' && actionType === 'skill') {
                    this.addStatusEffect(source, {
                        id: `l3_skill_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'atk_missing_hp',
                        value: 0,
                        turnsLeft: 4,
                        filters: {},
                        meta: { perHp: 30, bonus: 10 }
                    });
                    source.nextAttackFree = { turnsLeft: 1 };
                    const srcEl = getCardEl(source);
                    if (srcEl) {
                        fx.spawnParticles('buff', srcEl.getBoundingClientRect());
                        fx.spawnRunes(srcEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`Buff de ATK din√¢mico ativado!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-3' && actionType === 'ult') {
                    this.ensureCardState(target);
                    target.statusEffects = target.statusEffects.filter(e => e.id !== `l3_intercept_${source.uid}`);
                    this.addStatusEffect(target, {
                        id: `l3_intercept_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'intercept',
                        value: 0,
                        turnsLeft: 2,
                        filters: {},
                        meta: { sourceUid: source.uid }
                    });
                    this.addStatusEffect(source, {
                        id: `l3_reduce_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'damage_reduction',
                        value: 0.3,
                        turnsLeft: 2,
                        filters: {},
                        meta: {}
                    });
                    const targetEl = getCardEl(target);
                    ui.showDamage(targetEl, "PROTEGIDA", "#00ffff");
                    if (targetEl) {
                        fx.spawnParticles('buff', targetEl.getBoundingClientRect());
                        fx.spawnRunes(targetEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`Interceptando dano de <strong>${target.name}</strong>!`, this.getCardController(source));
                    source.nextAttackFree = { turnsLeft: 1 };
                    return;
                }
                if (source.dbId === 'L-4' && actionType === 'skill') {
                    const allies = Object.values(owner.field);
                    allies.forEach(ally => {
                        ally.pa = Math.min(10, ally.pa + 2);
                        const allyEl = getCardEl(ally);
                        ui.showDamage(allyEl, "+2 PA", "#ff00ff");
                        if (allyEl) {
                            fx.spawnParticles('buff', allyEl.getBoundingClientRect());
                            fx.spawnRunes(allyEl.getBoundingClientRect(), 2);
                        }
                    });
                    this.addTeamEffect(owner, {
                        id: `l4_next_pa_${source.uid}_${Date.now()}`,
                        sourceDbId: source.dbId,
                        type: 'pa_bonus_start',
                        value: 2,
                        turnsLeft: 1,
                        filters: {},
                        meta: {}
                    });
                    source.nextAttackFree = { turnsLeft: 1 };
                    this.logAction(`PA +2 aplicado!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-4' && actionType === 'ult') {
                    const healCritInfo = this.getCritMultiplier(source, 'heal');
                    if (healCritInfo.isCrit) this.logAction(`<strong>CR√çTICO!</strong>`, this.getCardController(source));
                    Object.values(owner.field).forEach(ally => {
                        const missing = Math.max(0, ally.maxHp - ally.currentHp);
                        const heal = missing * healCritInfo.mult;
                        ally.currentHp = Math.min(ally.maxHp, ally.currentHp + heal);
                        const allyEl = getCardEl(ally);
                        ui.showDamage(allyEl, "Cura total", "#39ff14");
                        if (allyEl) {
                            fx.healHearts(allyEl.getBoundingClientRect(), 3);
                            fx.spawnParticles('heal', allyEl.getBoundingClientRect());
                        }
                        this.logHealEvent(source, heal, ally.name);
                    });
                    source.nextAttackFree = { turnsLeft: 1 };
                    this.logAction(`Cura total aplicada!`, this.getCardController(source));
                }
                if (source.dbId === 'L-5' && actionType === 'ult') {
                    this.addStatusEffect(source, {
                        id: `l5_ult_def_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'def_override',
                        value: 0,
                        turnsLeft: 2,
                        filters: {},
                        meta: {}
                    });
                    this.addStatusEffect(source, {
                        id: `l5_ult_atk_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'atk_mult',
                        value: 1.75,
                        turnsLeft: 2,
                        filters: {},
                        meta: {}
                    });
                    this.addStatusEffect(source, {
                        id: `l5_ult_drain_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'hp_drain_pct',
                        value: 0.25,
                        turnsLeft: 2,
                        filters: {},
                        meta: { timing: 'start_turn_owner' }
                    });
                    const srcEl = getCardEl(source);
                    ui.showDamage(srcEl, "F√∫ria", "#ff4444");
                    if (srcEl) {
                        fx.spawnParticles('buff', srcEl.getBoundingClientRect());
                        fx.spawnRunes(srcEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`<strong>${source.name}</strong> entrou em f√∫ria!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-6' && actionType === 'skill') {
                    const allies = Object.values(owner.field);
                    allies.forEach(ally => {
                        this.addStatusEffect(ally, {
                            id: `l6_skill_${source.uid}`,
                            sourceDbId: source.dbId,
                            type: 'damage_reduction',
                            value: 0.1,
                            turnsLeft: 2,
                            filters: {},
                            meta: {}
                        });
                        const allyEl = getCardEl(ally);
                        ui.showDamage(allyEl, "-10% Dano", "#00ffff");
                        if (allyEl) {
                            fx.spawnParticles('buff', allyEl.getBoundingClientRect());
                            fx.spawnRunes(allyEl.getBoundingClientRect(), 2);
                        }
                    });
                    this.logAction(`Escudos ativados para o time!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-6' && actionType === 'ult') {
                    this.addStatusEffect(target, {
                        id: `l6_ult_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'damage_immunity',
                        value: 1,
                        turnsLeft: 1,
                        filters: {},
                        meta: {}
                    });
                    const targetEl = getCardEl(target);
                    ui.showDamage(targetEl, "IMUNE", "#00ffff");
                    if (targetEl) {
                        fx.spawnParticles('buff', targetEl.getBoundingClientRect());
                        fx.spawnRunes(targetEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`Imunidade total em <strong>${target.name}</strong>!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-7' && actionType === 'skill') {
                    const totalHand = this.player.hand.length + this.opp.hand.length;
                    const bonus = totalHand * 10;
                    this.addStatusEffect(target, {
                        id: `l7_skill_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'atk_flat',
                        value: bonus,
                        turnsLeft: 2,
                        filters: { targetUid: target.uid },
                        meta: { perHand: 10 }
                    });
                    const targetEl = getCardEl(target);
                    ui.showDamage(targetEl, `+${bonus} ATK`, "#ffd700");
                    if (targetEl) {
                        fx.spawnParticles('buff', targetEl.getBoundingClientRect());
                        fx.spawnRunes(targetEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`ATK aumentado em <strong>${target.name}</strong>!`, this.getCardController(source));
                    if (target.uid === source.uid) source.nextAttackFree = { turnsLeft: 1 };
                    return;
                }
                if (source.dbId === 'L-7' && actionType === 'ult') {
                    if (target.owner === source.owner) {
                        const healAmount = Math.max(0, target.maxHp - target.currentHp);
                        target.currentHp = target.maxHp;
                        const targetEl = getCardEl(target);
                        ui.showDamage(targetEl, "Cura total", "#39ff14");
                        if (targetEl) {
                            fx.healHearts(targetEl.getBoundingClientRect(), 3);
                            fx.spawnParticles('heal', targetEl.getBoundingClientRect());
                        }
                        this.logHealEvent(source, healAmount, target.name);
                    }
                    this.addStatusEffect(target, {
                        id: `l7_ult_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'pacifist',
                        value: 1,
                        turnsLeft: target.owner === source.owner ? 1 : 2,
                        filters: {},
                        meta: {}
                    });
                    const targetEl = getCardEl(target);
                    ui.showDamage(targetEl, "PACIFISTA", "#b300ff");
                    if (targetEl) {
                        fx.spawnParticles('debuff', targetEl.getBoundingClientRect());
                    }
                    this.logAction(`Pacifista aplicado em <strong>${target.name}</strong>!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-8' && actionType === 'skill') {
                    const ownerEntity = this.getOwnerEntity(source);
                    // Conta Esqueletos do dono (campo + cemit√©rio) para o b√¥nus de ATK.
                    const skeletonsField = Object.values(ownerEntity.field).filter(card => card.tribe === 'Esqueletos');
                    const skeletonsGy = ownerEntity.gy.filter(card => card.tribe === 'Esqueletos');
                    const bonus = (skeletonsField.length + skeletonsGy.length) * 20;
                    this.addStatusEffect(source, {
                        id: `l8_skill_atk_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'atk_flat',
                        value: bonus,
                        turnsLeft: 2,
                        filters: {},
                        meta: { countField: skeletonsField.length, countGy: skeletonsGy.length }
                    });
                    this.addStatusEffect(source, {
                        id: `l8_skill_redirect_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'damage_redirect_skeletons',
                        value: 0.2,
                        turnsLeft: 1,
                        filters: {},
                        meta: { excludeSelf: true }
                    });
                    const srcEl = getCardEl(source);
                    ui.showDamage(srcEl, `+${bonus} ATK`, "#ffd700");
                    if (srcEl) {
                        fx.spawnParticles('buff', srcEl.getBoundingClientRect());
                        fx.spawnRunes(srcEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`Poder dos Esqueletos ativado!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-8' && actionType === 'ult') {
                    const ownerEntity = this.getOwnerEntity(source);
                    // Soma ATK base das cartas Esqueletos no cemit√©rio do dono.
                    const bonus = ownerEntity.gy.filter(card => card.tribe === 'Esqueletos').reduce((sum, card) => sum + (card.atk || 0), 0);
                    this.addStatusEffect(source, {
                        id: `l8_ult_atk_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'atk_flat',
                        value: bonus,
                        turnsLeft: 1,
                        filters: {},
                        meta: { atkSource: 'graveyard_base' }
                    });
                    const srcEl = getCardEl(source);
                    ui.showDamage(srcEl, `+${bonus} ATK`, "#ffd700");
                    if (srcEl) {
                        fx.spawnParticles('buff', srcEl.getBoundingClientRect());
                        fx.spawnRunes(srcEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`ATK do cemit√©rio absorvido!`, this.getCardController(source));
                }
                if (source.dbId === 'L-9' && actionType === 'skill') {
                    // Conta Lanceiros aliados em campo (apenas aliados do controlador).
                    this.addStatusEffect(source, {
                        id: `l9_skill_atk_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'atk_per_tribe',
                        value: 20,
                        turnsLeft: 2,
                        filters: {},
                        meta: { tribe: 'Lanceiros', per: 20, owner: this.getCardController(source) }
                    });
                    this.addStatusEffect(source, {
                        id: `l9_spill_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'l9_spill',
                        value: 0.3,
                        turnsLeft: 2,
                        filters: {},
                        meta: {}
                    });
                    const srcEl = getCardEl(source);
                    ui.showDamage(srcEl, "Falange", "#00ffff");
                    if (srcEl) {
                        fx.spawnParticles('buff', srcEl.getBoundingClientRect());
                        fx.spawnRunes(srcEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`Postura de falange ativada!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-10' && actionType === 'skill') {
                    this.addStatusEffect(source, {
                        id: `l10_skill_reduction_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'damage_reduction',
                        value: 0.2,
                        turnsLeft: 3,
                        filters: {},
                        meta: {}
                    });
                    this.addStatusEffect(source, {
                        id: `l10_skill_atk_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'atk_shield_mult',
                        value: 1.1,
                        turnsLeft: 3,
                        filters: {},
                        meta: { perShield: 20, bonusPct: 0.02 }
                    });
                    this.addStatusEffect(source, {
                        id: `l10_skill_active_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'l10_skill_active',
                        value: 1,
                        turnsLeft: 3,
                        filters: {},
                        meta: {}
                    });
                    const srcEl = getCardEl(source);
                    ui.showDamage(srcEl, "V√âU ATIVO", "#4da6ff");
                    if (srcEl) {
                        fx.spawnParticles('buff', srcEl.getBoundingClientRect());
                        fx.spawnRunes(srcEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`Sobrevida e resist√™ncia ativadas!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-10' && actionType === 'ult') {
                    const allies = Object.values(owner.field);
                    allies.forEach(ally => {
                        const shieldValue = Math.floor(ally.maxHp * 0.2);
                        this.addStatusEffect(ally, {
                            id: `l10_ult_shield_${source.uid}_${ally.uid}`,
                            sourceDbId: source.dbId,
                            type: 'shield',
                            value: shieldValue,
                            turnsLeft: 2,
                            filters: {},
                            meta: {}
                        });
                        this.syncShieldValue(ally);
                        const allyEl = getCardEl(ally);
                        ui.showDamage(allyEl, `üõ°Ô∏è +${shieldValue}`, "#4da6ff");
                        if (allyEl) {
                            fx.spawnParticles('buff', allyEl.getBoundingClientRect());
                            fx.spawnRunes(allyEl.getBoundingClientRect(), 1);
                        }
                    });
                    this.logAction(`Sobrevida concedida ao time!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-11' && actionType === 'skill') {
                    if (!target || typeof target === 'string') return;
                    const targetEntity = target.owner === 'player' ? this.player : this.opp;
                    const frontRow = target.owner === 'player' ? 2 : 1;
                    const backRow = target.owner === 'player' ? 3 : 0;
                    if (![frontRow, backRow].includes(target.r)) return;
                    const fromKey = `${target.r}-${target.c}`;
                    const toRow = target.r === frontRow ? backRow : frontRow;
                    const toKey = `${toRow}-${target.c}`;
                    const swapCard = targetEntity.field[toKey];
                    if (swapCard) {
                        swapCard.r = target.r;
                        swapCard.c = target.c;
                        targetEntity.field[fromKey] = swapCard;
                    } else {
                        delete targetEntity.field[fromKey];
                    }
                    target.r = toRow;
                    target.c = target.c;
                    targetEntity.field[toKey] = target;
                    const targetEl = getCardEl(target);
                    ui.showDamage(targetEl, "TROCA", "#8ff7ff");
                    if (swapCard) {
                        const swapEl = getCardEl(swapCard);
                        ui.showDamage(swapEl, "TROCA", "#8ff7ff");
                    }
                    if (targetEl) {
                        fx.spawnParticles('buff', targetEl.getBoundingClientRect());
                        fx.spawnRunes(targetEl.getBoundingClientRect(), 1);
                    }
                    this.logAction(`Posi√ß√£o alterada para <strong>${target.name}</strong>.`, this.getCardController(source));
                    ui.renderField();
                    ui.updateHUD();
                    return;
                }
                if (source.dbId === 'L-11' && actionType === 'ult') {
                    const drunkId = `l11_drunk_${source.uid}`;
                    const soberId = `l11_sober_${source.uid}`;
                    this.ensureCardState(source);
                    const hasDrunk = source.statusEffects.some(e => e.id === drunkId);
                    const hasSober = source.statusEffects.some(e => e.id === soberId);
                    source.statusEffects = source.statusEffects.filter(e => e.id !== drunkId && e.id !== soberId);
                    const nextState = hasDrunk ? 'sober' : 'drunk';
                    if (nextState === 'drunk') {
                        this.addStatusEffect(source, {
                            id: drunkId,
                            sourceDbId: source.dbId,
                            type: 'damage_reduction',
                            value: 0.25,
                            turnsLeft: 1,
                            filters: {},
                            meta: { permanent: true }
                        });
                    } else {
                        this.addStatusEffect(source, {
                            id: soberId,
                            sourceDbId: source.dbId,
                            type: 'atk_mult',
                            value: 1.25,
                            turnsLeft: 1,
                            filters: {},
                            meta: { permanent: true }
                        });
                    }
                    const srcEl = getCardEl(source);
                    const label = nextState === 'drunk' ? "B√äBADO" : "S√ìBRIO";
                    ui.showDamage(srcEl, label, "#ffd700");
                    if (srcEl) {
                        fx.spawnParticles('buff', srcEl.getBoundingClientRect());
                        fx.spawnRunes(srcEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`Estado ${nextState === 'drunk' ? 'b√™bado' : 's√≥brio'} ativado!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-12' && actionType === 'ult') {
                    const allies = Object.values(owner.field);
                    const sourceController = this.getCardController(source);
                    const enemies = Object.values(sourceController === 'player' ? this.opp.field : this.player.field);
                    const poisonBase = Math.floor(this.getEffectiveAtk(source) * 0.2);
                    enemies.forEach(enemy => {
                        this.addStatusEffect(enemy, {
                            id: `l12_ult_infect_${source.uid}_${enemy.uid}`,
                            sourceDbId: source.dbId,
                            type: 'infection',
                            value: poisonBase,
                            turnsLeft: 2,
                            filters: {},
                            meta: { sourceUid: source.uid }
                        });
                        const enemyEl = getCardEl(enemy);
                        ui.showDamage(enemyEl, "INFECTADO", "#b300ff");
                        if (enemyEl) fx.spawnParticles('debuff', enemyEl.getBoundingClientRect());
                    });
                    allies.forEach(ally => {
                        const heal = Math.floor(ally.maxHp * 0.2);
                        ally.currentHp = Math.min(ally.maxHp, ally.currentHp + heal);
                        const allyEl = getCardEl(ally);
                        ui.showDamage(allyEl, `+${heal}`, "#39ff14");
                        if (allyEl) {
                            fx.healHearts(allyEl.getBoundingClientRect(), 2);
                            fx.spawnParticles('heal', allyEl.getBoundingClientRect());
                        }
                        this.logHealEvent(source, heal, ally.name);
                    });
                    const buffTarget = target && typeof target !== 'string' ? target : source;
                    const bonus = allies.length * 20;
                    this.addStatusEffect(buffTarget, {
                        id: `l12_ult_buff_${source.uid}_${buffTarget.uid}`,
                        sourceDbId: source.dbId,
                        type: 'atk_flat',
                        value: bonus,
                        turnsLeft: 2,
                        filters: { targetUid: buffTarget.uid },
                        meta: {}
                    });
                    const buffEl = getCardEl(buffTarget);
                    ui.showDamage(buffEl, `+${bonus} ATK`, "#ffd700");
                    if (buffEl) {
                        fx.spawnParticles('buff', buffEl.getBoundingClientRect());
                        fx.spawnRunes(buffEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`Infec√ß√£o em massa e cura aplicada!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-13' && actionType === 'skill') {
                    if (!target || typeof target === 'string') {
                        this.logAction("Nenhuma carta selecionada no cemit√©rio.", this.getCardController(source));
                        return;
                    }
                    if (!['common', 'rare', 'epic'].includes(target.rarity)) {
                        this.logAction("Apenas cartas Comuns, Raras ou √âpicas podem ser invocadas.", this.getCardController(source));
                        return;
                    }
                    if (this.countNecroSummons() >= 2) {
                        this.logAction("Limite de invoca√ß√µes controladas atingido.", this.getCardController(source));
                        return;
                    }
                    const controllerSide = this.getCardController(source);
                    const controllerEntity = controllerSide === 'player' ? this.player : this.opp;
                    const originEntity = target.owner === 'player' ? this.player : this.opp;
                    const originIndex = originEntity.gy.findIndex(card => card.uid === target.uid);
                    if (originIndex === -1) return;

                    const frontRow = controllerSide === 'player' ? 2 : 1;
                    const backRow = controllerSide === 'player' ? 3 : 0;
                    const preferredRow = (target.archetype === 'Melee' || target.archetype === 'Tank') ? frontRow : backRow;
                    const fallbackRow = preferredRow === frontRow ? backRow : frontRow;
                    let placeKey = null;
                    for (let c = 0; c < 5; c++) {
                        const key = `${preferredRow}-${c}`;
                        if (!controllerEntity.field[key]) { placeKey = key; break; }
                    }
                    if (!placeKey) {
                        for (let c = 0; c < 5; c++) {
                            const key = `${fallbackRow}-${c}`;
                            if (!controllerEntity.field[key]) { placeKey = key; break; }
                        }
                    }
                    if (!placeKey) {
                        this.logAction("Sem espa√ßo no campo!", this.getCardController(source));
                        return;
                    }

                    originEntity.gy.splice(originIndex, 1);
                    const baseCard = CARD_DATABASE.find(c => c.dbId === target.dbId) || target;
                    const [rStr, cStr] = placeKey.split('-');
                    const summoned = {
                        ...createCardInstance(baseCard, controllerSide === 'player' ? 'P' : 'O'),
                        owner: controllerSide,
                        r: parseInt(rStr),
                        c: parseInt(cStr),
                        isNecroSummon: true,
                        necromancerUid: source.uid,
                        necroOriginalOwner: target.owner,
                        necroLabel: `Controlado por: ${source.habName}`
                    };
                    this.addStatusEffect(summoned, {
                        id: `l13_necro_${source.uid}_${summoned.uid}`,
                        sourceDbId: source.dbId,
                        type: 'necro_control',
                        value: 0,
                        turnsLeft: 99,
                        filters: {},
                        meta: { label: summoned.necroLabel }
                    });
                    controllerEntity.field[placeKey] = summoned;
                    this.logAction(`Necromancia: ${summoned.name} invocado.`, this.getCardController(source));
                    ui.renderField();
                    ui.updateHUD();
                    ui.updateGraveyardVisuals();
                    return;
                }
                if (source.dbId === 'L-13' && actionType === 'ult') {
                    if (!target || typeof target === 'string') return;
                    target.controlledBy = this.getCardController(source);
                    target.controlOrigin = { owner: target.owner, r: target.r, c: target.c };
                    target.controlMoved = false;
                    target.controlImmune = true;
                    target.controlReleaseTurn = this.turnCounter + 2;
                    this.addStatusEffect(target, {
                        id: `l13_control_${source.uid}_${target.uid}`,
                        sourceDbId: source.dbId,
                        type: 'mind_control',
                        value: 1,
                        turnsLeft: 2,
                        filters: {},
                        meta: { controller: this.getCardController(source) }
                    });
                    const targetEl = getCardEl(target);
                    ui.showDamage(targetEl, "CONTROLADO", "#8ff7ff");
                    if (targetEl) {
                        fx.spawnParticles('buff', targetEl.getBoundingClientRect());
                        fx.spawnRunes(targetEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`Controle mental aplicado!`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-14' && actionType === 'skill') {
                    if (!target || typeof target === 'string') return;
                    const controllerSide = this.getCardController(source);
                    const controllerEntity = controllerSide === 'player' ? this.player : this.opp;
                    const preMultiplier = this.getUtilityMultiplierForSide(controllerSide);
                    this.addTeamEffect(controllerEntity, {
                        id: `l14_util_double_${controllerSide}`,
                        sourceDbId: source.dbId,
                        type: 'l14_util_double',
                        value: 2,
                        turnsLeft: 2,
                        filters: {},
                        meta: { sourceSide: controllerSide }
                    });
                    const paGain = 2 * preMultiplier;
                    target.pa = Math.min(10, target.pa + paGain);
                    this.addStatusEffect(target, {
                        id: `l14_pa_boost_${target.uid}`,
                        sourceDbId: source.dbId,
                        type: 'pa_bonus_start_card',
                        value: paGain,
                        turnsLeft: 1,
                        filters: { targetUid: target.uid },
                        meta: {}
                    });
                    const targetEl = getCardEl(target);
                    ui.showDamage(targetEl, `+${paGain} PA`, "#ff00ff");
                    if (targetEl) {
                        fx.spawnParticles('buff', targetEl.getBoundingClientRect());
                        fx.spawnRunes(targetEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`Dobra utilit√°ria ativada em <strong>${target.name}</strong>.`, controllerSide);
                    return;
                }
                if (source.dbId === 'L-14' && actionType === 'ult') {
                    const controllerSide = this.getCardController(source);
                    const controllerEntity = controllerSide === 'player' ? this.player : this.opp;
                    const enemyEntity = controllerSide === 'player' ? this.opp : this.player;
                    const utilMult = this.getUtilityMultiplierForSide(controllerSide);
                    this.addTeamEffect(enemyEntity, {
                        id: `l14_suppress_${source.uid}_${Date.now()}`,
                        sourceDbId: source.dbId,
                        type: 'suppress_temp_effects',
                        value: 1,
                        turnsLeft: 2,
                        filters: {},
                        meta: { sourceSide: controllerSide, expiresTurn: this.turnCounter + 1 }
                    });
                    Object.values(enemyEntity.field).forEach(enemy => {
                        this.addStatusEffect(enemy, {
                            id: `l14_vuln_${source.uid}_${enemy.uid}`,
                            sourceDbId: source.dbId,
                            type: 'damage_taken_mult',
                            value: 1.25,
                            turnsLeft: 2,
                            filters: {},
                            meta: { ignoreSuppression: true }
                        });
                        const enemyEl = getCardEl(enemy);
                        ui.showDamage(enemyEl, "VULNER√ÅVEL", "#ff4444");
                        if (enemyEl) fx.spawnParticles('debuff', enemyEl.getBoundingClientRect());
                    });
                    Object.values(controllerEntity.field).forEach(ally => {
                        const shieldValue = Math.floor(ally.maxHp * 0.1);
                        const displayShield = Math.floor(shieldValue * utilMult);
                        this.addStatusEffect(ally, {
                            id: `l14_shield_${source.uid}_${ally.uid}`,
                            sourceDbId: source.dbId,
                            type: 'shield',
                            value: shieldValue,
                            turnsLeft: 2,
                            filters: {},
                            meta: {}
                        });
                        this.syncShieldValue(ally);
                        const allyEl = getCardEl(ally);
                        ui.showDamage(allyEl, `üõ°Ô∏è +${displayShield}`, "#4da6ff");
                        if (allyEl) {
                            fx.spawnParticles('buff', allyEl.getBoundingClientRect());
                            fx.spawnRunes(allyEl.getBoundingClientRect(), 1);
                        }
                    });
                    this.logAction(`N√∫cleo Supremo ativado!`, controllerSide);
                    return;
                }
                if (source.dbId === 'L-18' && actionType === 'skill') {
                    if (!target || typeof target === 'string') return;
                    const controllerSide = this.getCardController(source);
                    const controllerEntity = controllerSide === 'player' ? this.player : this.opp;
                    this.addTeamEffect(controllerEntity, {
                        id: `l18_vanguard_atk_${controllerSide}`,
                        sourceDbId: source.dbId,
                        type: 'atk_mult',
                        value: 1.2,
                        turnsLeft: 2,
                        filters: { owner: controllerSide },
                        meta: { sourceSide: controllerSide }
                    });
                    this.addTeamEffect(controllerEntity, {
                        id: `l18_vanguard_back_${controllerSide}`,
                        sourceDbId: source.dbId,
                        type: 'l18_backrow_access',
                        value: 1,
                        turnsLeft: 2,
                        filters: { owner: controllerSide, archetype: ['Melee', 'Tank'] },
                        meta: { sourceSide: controllerSide }
                    });
                    target.pa = Math.min(10, target.pa + 2);
                    this.addStatusEffect(target, {
                        id: `l18_vanguard_pa_${source.uid}_${target.uid}`,
                        sourceDbId: source.dbId,
                        type: 'pa_bonus_start_card',
                        value: 2,
                        turnsLeft: 1,
                        filters: { targetUid: target.uid },
                        meta: { sourceSide: controllerSide }
                    });
                    const targetEl = getCardEl(target);
                    ui.showDamage(targetEl, "+2 PA", "#ff00ff");
                    if (targetEl) {
                        fx.spawnParticles('buff', targetEl.getBoundingClientRect());
                        fx.spawnRunes(targetEl.getBoundingClientRect(), 2);
                    }
                    this.logAction(`Ataque aliado +20% por 2 turnos (Habilidade 'Comando de Vanguarda' da carta L-18).`, controllerSide);
                    this.logAction(`${target.name} +2 PA agora e +2 PA no pr√≥ximo turno.`, controllerSide);
                    this.logAction(`Melee/Tank podem atacar linha de tr√°s por 2 turnos.`, controllerSide);
                    ui.renderField();
                    ui.updateHUD();
                    return;
                }
                if (source.dbId === 'L-18' && actionType === 'ult') {
                    const controllerSide = this.getCardController(source);
                    const controllerEntity = controllerSide === 'player' ? this.player : this.opp;
                    const opponentSide = controllerSide === 'player' ? 'opp' : 'player';
                    const opponentEntity = opponentSide === 'player' ? this.player : this.opp;
                    if (!target || typeof target === 'string') return;
                    const fieldInfo = this.findCardField(target);
                    if (!fieldInfo || target.owner !== opponentSide) return;
                    delete fieldInfo.entity.field[fieldInfo.key];
                    const baseCard = CARD_DATABASE.find(c => c.dbId === target.dbId) || target;
                    target.r = undefined;
                    target.c = undefined;
                    target.currentHp = baseCard.hp;
                    target.currentAtk = baseCard.atk;
                    target.currentDef = baseCard.def;
                    target.maxHp = baseCard.maxHp ?? baseCard.hp;
                    target.statusEffects = [];
                    target.nextAttackFree = null;
                    target.shield = 0;
                    target.controlledBy = null;
                    target.controlOrigin = null;
                    target.controlMoved = false;
                    target.controlReleaseTurn = null;
                    target.controlImmune = false;
                    target.isNecroSummon = false;
                    target.necromancerUid = null;
                    target.necroOriginalOwner = null;
                    target.necroLabel = null;
                    opponentEntity.deck.push(target);
                    this.logAction(`Triplo Deslocamento: ${target.name} enviado ao topo do deck inimigo (efeitos limpos).`, controllerSide);
                    ui.renderField();
                    ui.updateHUD();

                    const step2Pick = async () => {
                        if (opponentEntity.hand.length === 0) {
                            this.logAction("Triplo Deslocamento: m√£o inimiga vazia, passo 2 ignorado.", controllerSide);
                            return null;
                        }
                        if (controllerSide !== 'player') {
                            return opponentEntity.hand[Math.floor(Math.random() * opponentEntity.hand.length)];
                        }
                        return await new Promise(resolve => {
                            this.startHandPickMode({
                                side: opponentSide,
                                onPick: (card) => resolve(card),
                                onCancel: () => resolve(null)
                            });
                        });
                    };

                    const pickedHandCard = await step2Pick();
                    if (pickedHandCard) {
                        opponentEntity.hand = opponentEntity.hand.filter(card => card.uid !== pickedHandCard.uid);
                        opponentEntity.deck.unshift(pickedHandCard);
                        this.logAction(`Triplo Deslocamento: carta da m√£o inimiga enviada ao fundo do deck.`, controllerSide);
                        ui.renderHand(opponentSide);
                        ui.updateHUD();
                    }

                    const step3Pick = async () => {
                        if (opponentEntity.gy.length === 0) {
                            this.logAction("Triplo Deslocamento: cemit√©rio inimigo vazio.", controllerSide);
                            return null;
                        }
                        if (controllerSide !== 'player') {
                            return opponentEntity.gy[Math.floor(Math.random() * opponentEntity.gy.length)];
                        }
                        return await new Promise(resolve => {
                            this.startGraveyardSelectMode({
                                owner: opponentSide,
                                allowAny: true,
                                onSelect: (card) => resolve(card),
                                onCancel: () => resolve(null)
                            });
                        });
                    };

                    const pickedGyCard = await step3Pick();
                    if (pickedGyCard) {
                        opponentEntity.gy = opponentEntity.gy.filter(card => card.uid !== pickedGyCard.uid);
                        pickedGyCard.owner = controllerSide;
                        if (!pickedGyCard.originalOwner) pickedGyCard.originalOwner = opponentSide;
                        controllerEntity.gy.push(pickedGyCard);
                        this.logAction(`Triplo Deslocamento: carta do cemit√©rio inimigo movida para seu cemit√©rio.`, controllerSide);
                        ui.updateGraveyardVisuals();
                    }
                    return;
                }
                if (source.dbId === 'L-16' && actionType === 'skill') {
                    if (!target || typeof target === 'string') return;
                    const roll = Math.floor(Math.random() * 6) + 1;
                    const healChance = roll * 0.1;
                    const atkMult = 1 + (roll * 0.05);
                    this.addStatusEffect(target, {
                        id: `l16_dice_${source.uid}_${target.uid}`,
                        sourceDbId: source.dbId,
                        type: 'l16_dice',
                        value: 0,
                        turnsLeft: 1,
                        filters: { targetUid: target.uid },
                        meta: { roll, healChance, atkMult }
                    });
                    ui.showDiceRoll(roll);
                    const targetEl = getCardEl(target);
                    ui.showDamage(targetEl, `DADO ${roll}`, "#ffd700");
                    if (targetEl) {
                        fx.spawnParticles('buff', targetEl.getBoundingClientRect());
                        fx.spawnRunes(targetEl.getBoundingClientRect(), 1);
                    }
                    this.logAction(`Dado lan√ßado (${roll}) em <strong>${target.name}</strong>.`, this.getCardController(source));
                    return;
                }
                if (source.dbId === 'L-16' && actionType === 'ult') {
                    if (!target || typeof target === 'string') return;
                    const controllerSide = this.getCardController(source);
                    const utilMult = this.getUtilityMultiplierForSide(controllerSide);
                    const suit = await ui.showSuitSelection(controllerSide !== 'player');
                    if (!suit) return;
                    const suitMap = {
                        swords: { label: 'Espadas', icon: '‚öîÔ∏è' },
                        hearts: { label: 'Copas', icon: '‚ù§Ô∏è' },
                        gold: { label: 'Ouro', icon: '‚ô¶Ô∏è' },
                        clubs: { label: 'Paus', icon: '‚ô£Ô∏è' }
                    };
                    const suitMeta = suitMap[suit];
                    this.addStatusEffect(source, {
                        id: `l16_suit_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'l16_suit_badge',
                        value: 0,
                        turnsLeft: 1,
                        filters: {},
                        meta: { label: suitMeta?.label, icon: suitMeta?.icon }
                    });
                    if (suit === 'swords') {
                        const atkBonusPct = Math.round(75 * utilMult);
                        this.addStatusEffect(target, {
                            id: `l16_swords_${source.uid}_${target.uid}`,
                            sourceDbId: source.dbId,
                            type: 'atk_mult',
                            value: 1.75,
                            turnsLeft: 1,
                            filters: { targetUid: target.uid },
                            meta: {}
                        });
                        const targetEl = getCardEl(target);
                        ui.showDamage(targetEl, `+${atkBonusPct}% ATK`, "#ffd700");
                        if (targetEl) {
                            fx.spawnParticles('buff', targetEl.getBoundingClientRect());
                            fx.spawnRunes(targetEl.getBoundingClientRect(), 2);
                        }
                    }
                    if (suit === 'hearts') {
                        const healAmount = Math.floor(target.maxHp * 0.75 * utilMult);
                        target.currentHp = Math.min(target.maxHp, target.currentHp + healAmount);
                        const targetEl = getCardEl(target);
                        ui.showDamage(targetEl, `+${healAmount}`, "#39ff14");
                        if (targetEl) {
                            fx.healHearts(targetEl.getBoundingClientRect(), 2);
                            fx.spawnParticles('heal', targetEl.getBoundingClientRect());
                        }
                    }
                    if (suit === 'gold') {
                        const enemyEntity = controllerSide === 'player' ? this.opp : this.player;
                        const damageMult = 0.85;
                        Object.values(enemyEntity.field).forEach(enemy => {
                            this.removeBuffEffects(enemy);
                            this.addStatusEffect(enemy, {
                                id: `l16_gold_${source.uid}_${enemy.uid}`,
                                sourceDbId: source.dbId,
                                type: 'atk_mult',
                                value: damageMult,
                                turnsLeft: 1,
                                filters: {},
                                meta: {}
                            });
                            const enemyEl = getCardEl(enemy);
                            ui.showDamage(enemyEl, "OURO", "#ffd700");
                            if (enemyEl) fx.spawnParticles('debuff', enemyEl.getBoundingClientRect());
                        });
                    }
                    if (suit === 'clubs') {
                        const ownerEntity = controllerSide === 'player' ? this.player : this.opp;
                        const paGain = 2 * utilMult;
                        Object.values(ownerEntity.field).forEach(ally => {
                            ally.pa = Math.min(10, ally.pa + paGain);
                            const allyEl = getCardEl(ally);
                            ui.showDamage(allyEl, `+${paGain} PA`, "#ff00ff");
                            if (allyEl) {
                                fx.spawnParticles('buff', allyEl.getBoundingClientRect());
                                fx.spawnRunes(allyEl.getBoundingClientRect(), 1);
                            }
                        });
                        this.addTeamEffect(ownerEntity, {
                            id: `l16_clubs_next_${source.uid}_${Date.now()}`,
                            sourceDbId: source.dbId,
                            type: 'pa_bonus_start',
                            value: paGain,
                            turnsLeft: 1,
                            filters: {},
                            meta: { sourceSide: controllerSide }
                        });
                    }
                    this.logAction(`Destino Favor√°vel: ${suitMeta?.label} escolhido.`, controllerSide);
                    return;
                }
                if (source.dbId === 'L-15' && actionType === 'ult') {
                    const controllerSide = this.getCardController(source);
                    const runeTargets = this.getRuneTargets(controllerSide);
                    if (runeTargets.length === 0) {
                        this.logAction("Ultimate indispon√≠vel: nenhuma Runa em campo", controllerSide);
                        return;
                    }
                    const count = runeTargets.length;
                    let defPct = 0.25;
                    let atkPct = 0.25;
                    if (count === 1) { defPct = 1; atkPct = 0.5; }
                    else if (count === 2) { defPct = 0.75; atkPct = 0.35; }
                    else if (count === 3) { defPct = 0.5; atkPct = 0.3; }
                    runeTargets.forEach(targetCard => {
                        const defLoss = Math.floor((targetCard.currentDef || 0) * defPct);
                        const atkLoss = Math.floor((targetCard.currentAtk || 0) * atkPct);
                        targetCard.currentDef = Math.max(0, (targetCard.currentDef || 0) - defLoss);
                        targetCard.currentAtk = Math.max(0, (targetCard.currentAtk || 0) - atkLoss);
                        source.currentAtk = (source.currentAtk || 0) + atkLoss;
                        const targetEl = getCardEl(targetCard);
                        if (targetEl) {
                            fx.spawnParticles('debuff', targetEl.getBoundingClientRect());
                            fx.spawnRunes(targetEl.getBoundingClientRect(), 2);
                        }
                        const sourceEl = getCardEl(source);
                        if (sourceEl) {
                            fx.spawnParticles('buff', sourceEl.getBoundingClientRect());
                            fx.spawnRunes(sourceEl.getBoundingClientRect(), 1);
                        }
                        this.logAction(`Ultimate de L-15 drenou ${atkLoss} de ataque de ${targetCard.name}.`, controllerSide);
                    });
                    ui.renderField();
                    ui.updateHUD();
                    return;
                }
                if (source.dbId === 'L-17' && actionType === 'skill') {
                    const controllerSide = this.getCardController(source);
                    if (controllerSide === 'player') {
                        this.startDeckDrawMode(source);
                    } else {
                        if (this.opp.deck.length === 0) {
                            this.logAction("Deck vazio.", controllerSide);
                        } else {
                            this.drawCard('opp', false);
                        }
                    }
                    return;
                }
                if (source.dbId === 'L-17' && actionType === 'ult') {
                    const controllerSide = this.getCardController(source);
                    const opponentSide = controllerSide === 'player' ? 'opp' : 'player';
                    await this.drawCard(opponentSide, controllerSide === 'player');
                    this.logAction("Oponente comprou 1 carta devido √† Ultimate de L-17.", controllerSide);
                    await this.ensureOpponentHand(2, opponentSide);
                    if (controllerSide === 'player') {
                        const available = this.opp.hand.length;
                        if (available === 0) {
                            this.logAction("N√£o foi poss√≠vel roubar cartas: m√£o vazia.", controllerSide);
                            return;
                        }
                        if (available < 2) {
                            this.logAction("N√£o foi poss√≠vel completar 2 roubos por falta de deck.", controllerSide);
                        }
                        this.startHandStealMode(source, Math.min(2, available));
                    } else {
                        const available = this.player.hand.length;
                        const steals = Math.min(2, available);
                        if (steals < 2) {
                            this.logAction("IA roubou menos de 2 cartas por falta de deck.", controllerSide);
                        }
                        for (let i = 0; i < steals; i++) {
                            const stolen = this.player.hand.shift();
                            if (!stolen) break;
                            stolen.owner = 'opp';
                            if (!stolen.originalOwner) stolen.originalOwner = 'player';
                            this.opp.hand.push(stolen);
                        }
                        ui.renderHand('player');
                        ui.renderHand('opp');
                    }
                    return;
                }
                if (source.dbId === 'L-19' && actionType === 'skill') {
                    const controllerSide = this.getCardController(source);
                    const paGain = 1;
                    Object.values(owner.field).forEach(ally => {
                        ally.pa = Math.min(10, ally.pa + paGain);
                        const allyEl = getCardEl(ally);
                        ui.showDamage(allyEl, `+${paGain} PA`, "#ff00ff");
                        if (allyEl) {
                            fx.spawnParticles('buff', allyEl.getBoundingClientRect());
                            fx.spawnRunes(allyEl.getBoundingClientRect(), 1);
                        }
                    });
                    this.addTeamEffect(owner, {
                        id: `l19_rhythm_pa_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'pa_bonus_start',
                        value: 2,
                        turnsLeft: 1,
                        filters: { owner: controllerSide },
                        meta: { sourceSide: controllerSide }
                    });
                    this.addTeamEffect(owner, {
                        id: `l19_rhythm_steal_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'pa_steal_on_damage',
                        chance: 0.1,
                        turnsLeft: 2,
                        filters: { owner: controllerSide },
                        meta: { sourceSide: controllerSide }
                    });
                    this.logAction(`Ritmo Temporal: +1 PA agora, +2 PA no pr√≥ximo turno e 10% de roubo de PA.`, controllerSide);
                    return;
                }
                if (source.dbId === 'L-19' && actionType === 'ult') {
                    const controllerSide = this.getCardController(source);
                    this.addStatusEffect(source, {
                        id: `l19_next_attack_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'next_attack_steal_pa',
                        value: 1,
                        turnsLeft: 2,
                        filters: {},
                        meta: { sourceSide: controllerSide }
                    });
                    this.addTeamEffect(owner, {
                        id: `l19_ult_steal_${source.uid}`,
                        sourceDbId: source.dbId,
                        type: 'pa_steal_on_damage',
                        chance: 0.4,
                        turnsLeft: 1,
                        filters: { owner: controllerSide },
                        meta: { sourceSide: controllerSide }
                    });
                    const sourceEl = getCardEl(source);
                    ui.showDamage(sourceEl, "ROUBO PA", "#ff00ff");
                    if (sourceEl) {
                        fx.spawnParticles('buff', sourceEl.getBoundingClientRect());
                        fx.spawnRunes(sourceEl.getBoundingClientRect(), 1);
                    }
                    this.logAction(`Paradoxo do Tempo: pr√≥ximo ataque rouba PA e time com 40% de roubo.`, controllerSide);
                    return;
                }
            }
            clearL3Intercepts(source) {
                const owner = this.getOwnerEntity(source);
                Object.values(owner.field).forEach(card => {
                    if (!card.statusEffects) return;
                    card.statusEffects = card.statusEffects.filter(e => !(e.type === 'intercept' && e.meta?.sourceUid === source.uid));
                });
            }
            removeBuffEffects(card) {
                const buffTypes = [
                    'atk_flat',
                    'atk_mult',
                    'damage_reduction',
                    'crit_chance',
                    'atk_missing_hp',
                    'def_override',
                    'damage_immunity',
                    'hp_drain_pct',
                    'atk_shield_mult',
                    'l10_skill_active',
                    'shield',
                    'atk_per_tribe',
                    'l9_spill',
                    'l9_ult_splash',
                    'l16_dice',
                    'l16_suit_badge'
                ];
                card.statusEffects = (card.statusEffects || []).filter(effect => !buffTypes.includes(effect.type));
                this.syncShieldValue(card);
            }
            executeMove(r, c) {
                const activeCard = this.activeCard;
                if (!activeCard) return;

                const oldKey = `${activeCard.r}-${activeCard.c}`;
                const newKey = `${r}-${c}`;

                // Deduct cost
                this.player.pi -= 1;

                // Check if destination is occupied (Swap) or empty (Move)
                if (this.player.field[newKey]) {
                    // SWAP Logic
                    const targetCard = this.player.field[newKey];

                    // Update positions in card objects
                    targetCard.r = activeCard.r;
                    targetCard.c = activeCard.c;
                    activeCard.r = r;
                    activeCard.c = c;

                    // Update keys in map
                    this.player.field[oldKey] = targetCard;
                    this.player.field[newKey] = activeCard;

                    this.logAction(`Trocou <strong>${activeCard.name}</strong> com <strong>${targetCard.name}</strong>.`, 'player');
                } else {
                    // MOVE Logic
                    delete this.player.field[oldKey];
                    activeCard.r = r;
                    activeCard.c = c;
                    this.player.field[newKey] = activeCard;

                    this.logAction(`Moveu <strong>${activeCard.name}</strong>.`, 'player');
                }

                this.resetInteraction();
                ui.renderField();
                ui.updateHUD();
            }
            executeControlledMove(r, c) {
                const activeCard = this.activeCard;
                if (!activeCard) return;
                const newKey = `${r}-${c}`;
                if (this.player.field[newKey]) return;
                const fieldInfo = this.findCardField(activeCard);
                if (fieldInfo) delete fieldInfo.entity.field[fieldInfo.key];
                activeCard.r = r;
                activeCard.c = c;
                this.player.field[newKey] = activeCard;
                activeCard.controlMoved = true;
                this.logAction(`Carta controlada movida.`, 'player');
                this.resetInteraction();
                ui.renderField();
                ui.updateHUD();
            }
            async killCard(card) {
                await ui.animateDeath(card);
                const fieldInfo = this.findCardField(card);
                const owner = card.owner === 'player' ? this.player : this.opp;
                if (card.dbId === 'L-3') {
                    this.clearL3Intercepts(card);
                }
                if (card.dbId === 'L-13') {
                    const summons = [...Object.values(this.player.field), ...Object.values(this.opp.field)]
                        .filter(unit => unit.isNecroSummon && unit.necromancerUid === card.uid);
                    for (const summon of summons) {
                        await this.killCard(summon);
                    }
                }
                if (fieldInfo) {
                    delete fieldInfo.entity.field[fieldInfo.key];
                } else {
                    delete owner.field[`${card.r}-${card.c}`];
                }
                const gyOwner = card.isNecroSummon && card.necroOriginalOwner ? (card.necroOriginalOwner === 'player' ? this.player : this.opp) : owner;
                gyOwner.gy.push(card);
                this.logAction(`<strong>${card.name}</strong> foi derrotado!`, card.owner);
                ui.updateGraveyardVisuals();
            }
            checkWin() {
                if (this.player.hp <= 0) {
                    alert("Voc√™ Perdeu!");
                    location.reload();
                } else if (this.opp.hp <= 0) {
                    alert("Voc√™ Venceu!");
                    location.reload();
                }
            }
        }

        const game = new Game();

        function inferEffectActionType(effect) {
            if (effect?.meta?.sourceActionType) return effect.meta.sourceActionType;
            const id = effect?.id || '';
            if (id.includes('_ult_')) return 'ult';
            if (id.includes('_skill_')) return 'skill';
            if (id.startsWith('l5_mark_') || id.startsWith('l5_vuln_') || id.startsWith('l12_infect_') || id.startsWith('l15_runa_')) return 'skill';
            if (effect?.sourceDbId === 'L-11' && id.startsWith('l11_')) return 'ult';
            if (effect?.sourceDbId === 'L-14') {
                if (id.startsWith('l14_util_') || id.startsWith('l14_pa_')) return 'skill';
                return 'ult';
            }
            return 'skill';
        }

        function getEffectSourceCardName(effect) {
            const card = CARD_DATABASE.find(c => c.dbId === effect?.sourceDbId);
            return card?.name || effect?.meta?.sourceCardName || '';
        }

        function getEffectSourceText(effect) {
            const card = CARD_DATABASE.find(c => c.dbId === effect?.sourceDbId);
            const cardName = effect?.meta?.sourceCardName || card?.name || 'Carta';
            const actionType = inferEffectActionType(effect);
            const abilityName = effect?.meta?.sourceAbilityName
                || (actionType === 'ult' ? card?.ultName : card?.habName)
                || (actionType === 'ult' ? 'Ultimate' : 'Habilidade');
            const label = actionType === 'ult' ? 'Ultimate' : 'Habilidade';
            return `${label} '${abilityName}' da carta '${cardName}'`;
        }

        function getEffectDurationText(effect) {
            if (!effect) return '';
            if (effect.meta?.permanent) return 'Dura√ß√£o: Permanente (at√© alternar)';
            const turnsLeft = effect.turnsLeft ?? 0;
            const label = turnsLeft === 1 ? '1 turno' : `${turnsLeft} turnos`;
            return `Dura√ß√£o: ${label}`;
        }

        function getEffectLogDurationText(effect) {
            if (!effect) return '';
            if (effect.meta?.permanent) return 'por tempo indeterminado';
            const turnsLeft = effect.turnsLeft ?? 0;
            if (turnsLeft === 1) return 'por 1 turno';
            return `por ${turnsLeft} turnos`;
        }

        function getEffectLogName(effect) {
            switch (effect.type) {
                case 'l15_runa':
                    return 'Runa';
                case 'damage_taken_mult':
                    return 'Vulnerabilidade';
                case 'damage_reduction':
                    return 'Redu√ß√£o de dano';
                case 'atk_mult':
                    return 'Aumento de ATK';
                case 'atk_flat':
                    return 'B√¥nus de ATK';
                case 'crit_chance':
                    return 'Chance de cr√≠tico';
                case 'def_override':
                    return 'DEF zerada';
                case 'damage_immunity':
                    return 'Imunidade';
                case 'hp_drain_pct':
                    return 'Drenagem de HP';
                case 'pacifist':
                    return 'Pacifista';
                case 'l5_mark':
                    return 'Marca da Alcateia';
                case 'intercept':
                    return 'Intercepta√ß√£o';
                case 'infection':
                    return 'Infec√ß√£o';
                case 'shield':
                    return 'Sobrevida';
                case 'mind_control':
                    return 'Controle mental';
                case 'l16_dice':
                    return 'Dado da Sorte';
                case 'l16_suit_badge':
                    return 'Naipe Favor√°vel';
                case 'l18_backrow_access':
                    return 'Vanguarda';
                case 'pa_bonus_start':
                    return 'B√¥nus de PA';
                case 'pa_steal_on_damage':
                    return 'Roubo de PA';
                case 'next_attack_steal_pa':
                    return 'Roubo de PA garantido';
                default:
                    return 'Efeito';
            }
        }

        function formatEffectForUI(effect) {
            if (!effect || effect.turnsLeft <= 0) return null;
            let description = 'Efeito ativo';
            switch (effect.type) {
                case 'atk_mult': {
                    const pct = Math.round((effect.value - 1) * 100);
                    description = `Essa carta tem ${pct >= 0 ? '+' : '-'}${Math.abs(pct)}% de ATK.`;
                    break;
                }
                case 'atk_flat':
                    description = `Essa carta ganha +${Math.round(effect.value)} de ATK.`;
                    break;
                case 'crit_chance':
                    description = effect.value >= 1 ? 'Essa carta tem 100% de chance de cr√≠tico.' : `Essa carta tem +${Math.round(effect.value * 100)}% de chance de cr√≠tico.`;
                    break;
                case 'damage_reduction':
                    description = `Essa carta sofre -${Math.round(effect.value * 100)}% de dano recebido.`;
                    break;
                case 'damage_taken_mult': {
                    const pct = Math.round((effect.value - 1) * 100);
                    description = `Essa carta sofre ${pct >= 0 ? '+' : '-'}${Math.abs(pct)}% de dano recebido.`;
                    break;
                }
                case 'l15_runa':
                    description = 'Essa carta sofre +15% de dano (Runa).';
                    break;
                case 'atk_missing_hp':
                    description = `Essa carta ganha +${effect.meta?.bonus ?? 0} de ATK por ${effect.meta?.perHp ?? 30} HP perdidos.`;
                    break;
                case 'def_override':
                    description = 'A defesa desta carta foi reduzida a 0.';
                    break;
                case 'damage_immunity':
                    description = 'Esta carta est√° imune a dano.';
                    break;
                case 'hp_drain_pct':
                    description = `Esta carta sofre drenagem de ${Math.round(effect.value * 100)}% do HP no in√≠cio do turno.`;
                    break;
                case 'pacifist':
                    description = 'Esta carta n√£o pode causar dano (Pacifista).';
                    break;
                case 'l5_mark':
                    description = 'Esta carta est√° marcada e aliados drenam 20% do dano causado.';
                    break;
                case 'intercept':
                    description = 'Esta carta intercepta dano para um aliado.';
                    break;
                case 'damage_redirect_skeletons':
                    description = '20% do dano recebido √© redirecionado para Esqueletos aliados.';
                    break;
                case 'atk_per_tribe':
                    description = `ATK +${effect.meta?.per ?? effect.value ?? 0} por ${effect.meta?.tribe ?? 'aliado'} em campo.`;
                    break;
                case 'l9_spill':
                    description = '30% do dano causado transborda para a backline inimiga.';
                    break;
                case 'l9_ult_splash':
                    description = 'Golpe em cadeia: 75% do dano em √°rea.';
                    break;
                case 'atk_shield_mult':
                    description = '+10% ATK +2% por 20 de sobrevida.';
                    break;
                case 'l10_skill_active':
                    description = 'Sobrevida por ataque ativa.';
                    break;
                case 'shield':
                    description = `Sobrevida atual: ${Math.floor(effect.value || 0)} HP.`;
                    break;
                case 'infection':
                    description = `Infec√ß√£o: ${Math.floor(effect.value || 0)} de dano por turno.`;
                    break;
                case 'mind_control':
                    description = 'Controle mental ativo.';
                    break;
                case 'necro_control':
                    description = effect.meta?.label || 'Controlado por necromancia.';
                    break;
                case 'l16_dice':
                    description = `Essa carta tem ${Math.round((effect.meta?.healChance ?? 0) * 100)}% de chance de converter dano em cura.`;
                    break;
                case 'l16_suit_badge':
                    description = `Naipe ativo: ${effect.meta?.label ?? 'Efeito'}.`;
                    break;
                case 'l18_backrow_access':
                    description = 'Esta carta pode atacar a linha de tr√°s mesmo com frente ocupada.';
                    break;
                case 'pa_bonus_start':
                    description = `No in√≠cio do turno, esta carta recebe +${effect.value} PA.`;
                    break;
                case 'pa_steal_on_damage': {
                    const chance = Math.round((effect.chance ?? effect.value ?? 0) * 100);
                    description = `Esta carta tem ${chance}% de chance de roubar 1 PA ao causar dano.`;
                    break;
                }
                case 'next_attack_steal_pa':
                    description = 'Pr√≥ximo ataque rouba 1 PA do alvo.';
                    break;
                default:
                    description = 'Efeito ativo.';
            }
            const sourceText = getEffectSourceText(effect);
            const durationText = getEffectDurationText(effect);
            return `${description} (${sourceText}) ${durationText}`;
        }

        const ui = {
            hudState: {},
            selectedInfoCardUid: null,
            getInfoPanelCard: () => {
                if (!ui.selectedInfoCardUid) return null;
                const candidates = [...Object.values(game.player.field), ...Object.values(game.opp.field)];
                return candidates.find(card => card.uid === ui.selectedInfoCardUid) || null;
            },
            setInfoPanelCard: (card) => {
                ui.selectedInfoCardUid = card?.uid || null;
                ui.updateInfoPanel();
            },
            updateInfoPanel: () => {
                const panel = document.getElementById('info-panel');
                if (!panel) return;
                const card = ui.getInfoPanelCard();
                if (!card) {
                    ui.selectedInfoCardUid = null;
                    panel.innerHTML = '<div class="info-panel-placeholder">Clique com o bot√£o direito em uma carta no campo para ver detalhes.</div>';
                    return;
                }
                const habName = card.habName || 'Habilidade';
                const ultName = card.ultName || 'Ultimate';
                const habDesc = card.habDesc || 'Sem habilidade.';
                const ultDesc = card.ultDesc && card.ultDesc !== '-' ? card.ultDesc : 'Sem ultimate.';
                const ownerEntity = game.getOwnerEntity(card);
                const effects = [
                    ...(card.statusEffects || []),
                    ...(ownerEntity.teamEffects || [])
                ].filter(effect => effect.turnsLeft > 0 && game.effectMatchesCard(effect, card));
                const effectItems = effects.map(formatEffectForUI).filter(Boolean);
                const effectsHtml = effectItems.length
                    ? effectItems.map(item => `<li class="info-status-item">${item}</li>`).join('')
                    : '<li class="info-status-item">Nenhum efeito ativo.</li>';
                panel.innerHTML = `
                    <div class="info-panel-header">
                        <div class="info-card-preview">
                            <div class="card ${card.rarity}">
                                ${ui.cardTemplate(card)}
                            </div>
                        </div>
                        <div class="info-panel-details">
                            <div>
                                <div class="info-panel-title">HABILIDADE ‚Äî ${habName}</div>
                                <div class="info-panel-text">${habDesc}</div>
                            </div>
                            <div>
                                <div class="info-panel-title ult">ULTIMATE ‚Äî ${ultName}</div>
                                <div class="info-panel-text">${ultDesc}</div>
                            </div>
                        </div>
                    </div>
                    <hr class="info-panel-divider">
                    <div>
                        <div class="info-status-title">Status / Efeitos</div>
                        <ul class="info-status-list">${effectsHtml}</ul>
                    </div>
                `;
                const previewCard = panel.querySelector('.info-card-preview .card');
                if (previewCard) fx.applyStatusVisuals(previewCard, card);
            },
            renderHand: (who) => {
                const div = document.getElementById(who === 'player' ? 'player-hand' : 'opp-hand');
                div.innerHTML = '';
                const hand = who === 'player' ? game.player.hand : game.opp.hand;
                const isStealMode = who === 'opp' && game.handStealMode && game.activeSide === 'player';
                const isHandPickMode = !!(game.handPickMode && game.handPickMode.side === who && game.activeSide === 'player');
                div.classList.toggle('hand-steal-mode', !!(isStealMode || isHandPickMode));
                hand.forEach(card => {
                    const el = document.createElement('div');
                    el.className = `card ${card.rarity}`;
                    el.dataset.uid = card.uid; 
                    if (isStealMode) {
                        el.innerHTML = `<div class="card-inner deck-visual"></div>`;
                        el.onclick = (e) => {
                            e.stopPropagation();
                            game.handleStealCard(card.uid);
                        };
                    } else if (isHandPickMode) {
                        el.innerHTML = `<div class="card-inner deck-visual"></div>`;
                        el.onclick = (e) => {
                            e.stopPropagation();
                            game.handleHandPick(card.uid);
                        };
                    } else if (who === 'player') {
                        el.innerHTML = ui.cardTemplate(card);
                        el.onclick = (e) => {
                            e.stopPropagation(); 
                            ui.openHandModal(card);
                        };
                    } else {
                        el.innerHTML = `<div class="card-inner deck-visual"></div>`;
                    }
                    div.appendChild(el);
                });
            },
            cardTemplate: (card) => {
                const stars = '‚≠ê'.repeat(card.piCost);
                const hpPercent = Math.max(0, (card.currentHp / card.maxHp) * 100);
                const shieldValue = Math.max(0, card.shield || 0);
                const shieldPercent = Math.max(0, Math.min(100, (shieldValue / card.maxHp) * 100));
                const displayAtk = card.r !== undefined ? Math.floor(game.getEffectiveAtk(card)) : Math.floor(card.currentAtk || card.atk);
                const displayDef = card.r !== undefined ? Math.floor(game.getEffectiveDef(card)) : Math.floor(card.currentDef || card.def);
                const diceEffect = (card.statusEffects || []).find(effect => effect.type === 'l16_dice' && effect.turnsLeft > 0);
                const suitEffect = (card.statusEffects || []).find(effect => effect.type === 'l16_suit_badge' && effect.turnsLeft > 0);
                const runeEffect = (card.statusEffects || []).find(effect => effect.type === 'l15_runa' && effect.turnsLeft > 0);
                const badgesHtml = (diceEffect || suitEffect || runeEffect) ? `
                    <div class="card-status-badges">
                        ${diceEffect ? `<div class="card-badge dice">üé≤ ${diceEffect.meta?.roll ?? '?'}</div>` : ''}
                        ${suitEffect ? `<div class="card-badge suit">${suitEffect.meta?.icon ?? '‚ô†Ô∏è'}</div>` : ''}
                        ${runeEffect ? `<div class="card-badge runa">Runa</div>` : ''}
                    </div>
                ` : '';

                const archetypeIconHtml = getArchetypeIcon(card.archetype);

                if(card.rarity === 'utility') {
                     return `
                        <div class="card-inner">
                             <div class="card-top-header">
                                <div class="card-name">${card.name}</div>
                            </div>
                            <div class="card-side-indicators">
                                 <div class="card-stars-vertical">${stars}</div>
                            </div>
                            <div class="card-art-frame">
                                ${archetypeIconHtml}
                                <img src="${card.img}" class="card-img" style="filter: hue-rotate(90deg);">
                            </div>
                            <div class="card-info-box" style="top: 66%; height: 34%;">
                                <div class="card-tribe">ITEM</div>
                                <div class="card-desc">${card.habDesc}</div>
                            </div>
                        </div>
                    `;
                }
                const isOnBoard = card.r !== undefined;
                const headerText = isOnBoard ? card.tribe.toUpperCase() : card.name;
                return `
                    ${badgesHtml}
                    <div class="card-inner">
                        <div class="card-top-header">
                            <div class="card-name">${headerText}</div>
                        </div>
                        <div class="card-side-indicators">
                            <div class="card-stars-vertical">${stars}</div>
                            <div class="card-pa-badge">${card.pa}</div>
                        </div>
                        <div class="card-art-frame">
                            ${archetypeIconHtml}
                            <img src="${card.img}" class="card-img">
                        </div>
                        <div class="card-info-box">
                            <div class="card-tribe">${card.tribe}</div>
                            <div class="card-desc">${card.habDesc}</div>
                        </div>
                        <div class="card-footer-stats">
                            <div class="stat-item stat-atk">
                                <span class="stat-icon">‚öîÔ∏è</span>
                                <span class="stat-value">${displayAtk}</span>
                            </div>
                            <div class="stat-item stat-hp">
                                <span class="stat-icon">‚ù§Ô∏è</span>
                                <span class="stat-value">${Math.floor(card.currentHp)}</span>
                            </div>
                            <div class="stat-item stat-def">
                                <span class="stat-icon">üõ°Ô∏è</span>
                                <span class="stat-value">${displayDef}</span>
                            </div>
                        </div>
                    </div>
                    ${isOnBoard && shieldValue > 0 ? `
                    <div class="shield-indicator"><span class="shield-icon">üõ°Ô∏è</span>${Math.floor(shieldValue)}</div>
                    ` : ''}
                    ${isOnBoard && card.necroLabel ? `
                    <div class="necro-label">${card.necroLabel}</div>
                    ` : ''}
                    ${isOnBoard ? `
                    <div class="external-hp-bar">
                        <div class="external-hp-fill" style="width: ${hpPercent}%;"></div>
                    </div>
                    ${shieldValue > 0 ? `
                    <div class="external-shield-bar">
                        <div class="external-shield-fill" style="width: ${shieldPercent}%;"></div>
                    </div>
                    ` : ''}
                    ` : ''}
                `;
            },
            renderField: () => {
                document.querySelectorAll('.slot').forEach(s => {
                    s.innerHTML = '';
                    s.className = 'slot'; 
                    const r = parseInt(s.dataset.r);
                    const c = parseInt(s.dataset.c);
                    s.onclick = () => game.handleGridClick(r, c);
                });
                [game.player, game.opp].forEach(ent => {
                    Object.values(ent.field).forEach(c => {
                        const slot = document.querySelector(`.slot[data-r="${c.r}"][data-c="${c.c}"]`);
                        if(slot) {
                            const el = document.createElement('div');
                            el.className = `card ${c.rarity}`;
                            el.innerHTML = ui.cardTemplate(c);
                            el.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                ui.setInfoPanelCard(c);
                            });
                            fx.applyStatusVisuals(el, c);
                            slot.appendChild(el);
                        }
                    });
                });
                ui.highlightValidZones();
                ui.updateInfoPanel();
            },
            highlightValidZones: () => {
                const slots = document.querySelectorAll('.slot');
                slots.forEach(s => {
                    const r = parseInt(s.dataset.r);
                    const c = parseInt(s.dataset.c);
                    const key = `${r}-${c}`;
                    let isSummon = (game.interactionMode === 'summon' && game.validSlots.includes(key));
                    let isTarget = ((game.interactionMode === 'target' || game.interactionMode === 'utility') && game.validSlots.includes(key));
                    let isMove = ((game.interactionMode === 'move' || game.interactionMode === 'control_move') && game.validSlots.includes(key));

                    if (isSummon || isMove) {
                        s.classList.add('valid-summon-zone');
                        s.onclick = (e) => { e.stopPropagation(); game.handleGridClick(r, c); };
                    } else if (isTarget) {
                        s.classList.add('valid-target-zone');
                        s.onclick = (e) => { e.stopPropagation(); game.handleGridClick(r, c); };
                    }
                });
            },
            clearHighlights: () => {
                ui.renderField();
                const hud = document.getElementById('hud-opponent');
                hud.style.border = "1px solid #444";
                hud.style.cursor = "default";
                hud.onclick = null;
            },
            updateHUD: () => {
                const pulseIfChanged = (el, key, value) => {
                    if (!el) return;
                    if (ui.hudState[key] !== undefined && ui.hudState[key] !== value) {
                        el.classList.remove('hud-pulse');
                        void el.offsetWidth;
                        el.classList.add('hud-pulse');
                    }
                    ui.hudState[key] = value;
                };
                const playerHp = Math.floor(game.player.hp);
                const oppHp = Math.floor(game.opp.hp);
                const playerDef = game.player.def;
                const oppDef = game.opp.def;
                const playerPi = game.player.pi;
                const oppPi = game.opp.pi;
                const playerHpEl = document.getElementById('player-hp-display');
                const oppHpEl = document.getElementById('opp-hp-display');
                const playerDefEl = document.getElementById('player-def-display');
                const oppDefEl = document.getElementById('opp-def-display');
                const playerPiEl = document.getElementById('player-pi-display');
                const oppPiEl = document.getElementById('opp-pi-display');

                if (playerHpEl) playerHpEl.innerText = `HP: ${playerHp}`;
                if (playerDefEl) playerDefEl.innerText = `DEF: ${playerDef}`;
                if (playerPiEl) playerPiEl.innerHTML = `<span class="hud-star">‚≠ê</span> PI: ${playerPi}`;
                if (oppHpEl) oppHpEl.innerText = `HP: ${oppHp}`;
                if (oppDefEl) oppDefEl.innerText = `DEF: ${oppDef}`;
                if (oppPiEl) oppPiEl.innerHTML = `<span class="hud-star">‚≠ê</span> PI: ${oppPi}`;

                pulseIfChanged(playerHpEl, 'playerHp', playerHp);
                pulseIfChanged(oppHpEl, 'oppHp', oppHp);
                pulseIfChanged(playerDefEl, 'playerDef', playerDef);
                pulseIfChanged(oppDefEl, 'oppDef', oppDef);
                pulseIfChanged(playerPiEl, 'playerPi', playerPi);
                pulseIfChanged(oppPiEl, 'oppPi', oppPi);

                document.getElementById('player-deck').innerText = `DECK\n(${game.player.deck.length})`;
                document.getElementById('opp-deck').innerText = `DECK\n(${game.opp.deck.length})`;
                const playerDeck = document.getElementById('player-deck');
                if (playerDeck) {
                    const drawActive = game.deckDrawMode && game.activeSide === 'player';
                    playerDeck.classList.toggle('deck-draw-mode', !!drawActive);
                    playerDeck.onclick = drawActive ? () => game.handleDeckDrawClick() : null;
                }
            },
            updateGraveyardVisuals: () => {
                const pGy = document.getElementById('player-gy');
                const oGy = document.getElementById('opp-gy');
                if (game.player.gy.length > 0) pGy.classList.add('graveyard-filled');
                else pGy.classList.remove('graveyard-filled');
                if (game.opp.gy.length > 0) oGy.classList.add('graveyard-filled');
                else oGy.classList.remove('graveyard-filled');
            },
            bindGraveyardClicks: () => {
                const playerGy = document.getElementById('player-gy');
                const oppGy = document.getElementById('opp-gy');
                if (playerGy) playerGy.onclick = () => ui.openGraveyardOverlay({ owner: 'player', mode: 'view' });
                if (oppGy) oppGy.onclick = () => ui.openGraveyardOverlay({ owner: 'opp', mode: 'view' });
            },
            openGraveyardOverlay: ({ owner = 'player', mode = 'view', sourceCard = null, onSelect = null, selectOwner = null, allowAny = false, allowCancel = true } = {}) => {
                const overlay = document.getElementById('graveyard-overlay');
                if (!overlay) return;
                const isSelectMode = mode === 'select';
                const selectTitleOwner = selectOwner || owner;
                const title = isSelectMode
                    ? (selectOwner ? `Selecionar Carta do Cemit√©rio ${selectTitleOwner === 'player' ? 'do Jogador' : 'do Oponente'}` : 'Selecionar Carta do Cemit√©rio')
                    : `Cemit√©rio ${owner === 'player' ? 'do Jogador' : 'do Oponente'}`;
                overlay.innerHTML = `
                    <div class="graveyard-modal">
                        <div class="graveyard-modal-header">
                            <div class="graveyard-modal-title">${title}</div>
                            <div class="graveyard-modal-actions">
                                ${isSelectMode && allowCancel ? `<button class="btn btn-cancel" id="gy-cancel-btn">Cancelar</button>` : ''}
                                <button class="btn btn-cancel" id="gy-close-btn">Fechar</button>
                            </div>
                        </div>
                        <div id="gy-content"></div>
                    </div>
                `;
                const content = overlay.querySelector('#gy-content');
                const eligibleFn = allowAny ? () => true : (card) => ['common', 'rare', 'epic'].includes(card.rarity);
                const renderSection = (sectionTitle, cards, ownerKey) => {
                    const section = document.createElement('div');
                    const label = document.createElement('div');
                    label.className = 'graveyard-section-title';
                    label.innerText = sectionTitle;
                    const grid = document.createElement('div');
                    grid.className = 'graveyard-grid';
                    if (cards.length === 0) {
                        const empty = document.createElement('div');
                        empty.style.color = '#777';
                        empty.style.fontSize = '1.6vh';
                        empty.innerText = 'Nenhuma carta no cemit√©rio.';
                        section.appendChild(label);
                        section.appendChild(empty);
                        return section;
                    }
                    cards.forEach(card => {
                        const displayCard = { ...card, currentHp: card.hp, currentAtk: card.atk, currentDef: card.def };
                        delete displayCard.r;
                        delete displayCard.c;
                        const cardEl = document.createElement('div');
                        cardEl.className = `card ${card.rarity}`;
                        cardEl.innerHTML = ui.cardTemplate(displayCard);
                        if (isSelectMode) {
                            const eligible = eligibleFn(card);
                            cardEl.classList.add(eligible ? 'graveyard-card-eligible' : 'graveyard-card-disabled');
                            if (eligible) {
                                cardEl.onclick = () => {
                                    ui.closeGraveyardOverlay(true);
                                    if (typeof onSelect === 'function') onSelect(card);
                                };
                            }
                        }
                        grid.appendChild(cardEl);
                    });
                    section.appendChild(label);
                    section.appendChild(grid);
                    return section;
                };
                if (isSelectMode) {
                    const owners = selectOwner ? [selectOwner] : ['player', 'opp'];
                    owners.forEach(ownerKey => {
                        const titleLabel = ownerKey === 'player' ? 'Seu Cemit√©rio' : 'Cemit√©rio do Oponente';
                        const cards = ownerKey === 'player' ? game.player.gy : game.opp.gy;
                        content.appendChild(renderSection(titleLabel, cards, ownerKey));
                    });
                } else {
                    const gy = owner === 'player' ? game.player.gy : game.opp.gy;
                    const section = renderSection(owner === 'player' ? 'Seu Cemit√©rio' : 'Cemit√©rio do Oponente', gy, owner);
                    content.appendChild(section);
                }
                document.getElementById('game-container').classList.add('blur-background');
                overlay.style.display = 'flex';
                overlay.setAttribute('aria-hidden', 'false');
                const closeBtn = overlay.querySelector('#gy-close-btn');
                const cancelBtn = overlay.querySelector('#gy-cancel-btn');
                if (closeBtn) closeBtn.onclick = () => ui.closeGraveyardOverlay();
                if (cancelBtn) cancelBtn.onclick = () => ui.closeGraveyardOverlay();
            },
            closeGraveyardOverlay: (skipCancel = false) => {
                const overlay = document.getElementById('graveyard-overlay');
                if (!overlay) return;
                overlay.style.display = 'none';
                overlay.setAttribute('aria-hidden', 'true');
                overlay.innerHTML = '';
                document.getElementById('game-container').classList.remove('blur-background');
                if (game.graveyardSelectMode && !skipCancel) {
                    game.cancelGraveyardSelectMode();
                }
            },
            initTimerVisuals: () => {
                const svg = document.getElementById('timer-svg');
                svg.innerHTML = '';
                const totalDots = 60;
                const radius = 42; 
                const centerX = 50;
                const centerY = 50;
                for (let i = 0; i < totalDots; i++) {
                    const angle = (i * 6) * (Math.PI / 180); 
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", x);
                    circle.setAttribute("cy", y);
                    circle.setAttribute("r", "1.5");
                    circle.setAttribute("class", "timer-dot active");
                    circle.setAttribute("id", `timer-dot-${i}`);
                    svg.appendChild(circle);
                }
            },
            updateTimerVisuals: (seconds) => {
                for (let i = 0; i < 60; i++) {
                    const dot = document.getElementById(`timer-dot-${i}`);
                    if (dot) {
                        if (i < seconds) dot.classList.add('active');
                        else dot.classList.remove('active');
                    }
                }
            },
            animateDeath: (card) => {
                return new Promise(resolve => {
                    const slot = document.querySelector(`.slot[data-r="${card.r}"][data-c="${card.c}"] .card`);
                    const gyId = card.owner === 'player' ? 'player-gy' : 'opp-gy';
                    const gyEl = document.getElementById(gyId);
                    if (!slot || !gyEl) { resolve(); return; }
                    const startRect = slot.getBoundingClientRect();
                    const endRect = gyEl.getBoundingClientRect();
                    const clone = slot.cloneNode(true);
                    clone.classList.add('flying-card');
                    clone.style.top = startRect.top + 'px';
                    clone.style.left = startRect.left + 'px';
                    clone.style.width = startRect.width + 'px';
                    clone.style.height = startRect.height + 'px';
                    clone.style.zIndex = 3000;
                    document.body.appendChild(clone);
                    slot.style.opacity = '0'; 
                    clone.offsetWidth;
                    clone.style.top = endRect.top + 'px';
                    clone.style.left = endRect.left + 'px';
                    clone.style.opacity = '0';
                    clone.style.transform = 'scale(0.5)';
                    setTimeout(() => {
                        clone.remove();
                        resolve();
                    }, 600);
                });
            },
            animateDraw: (who) => {
                return new Promise(resolve => {
                    if (who === 'opp') { resolve(); return; } 
                    const deckId = 'player-deck';
                    const handId = 'player-hand';
                    const deckEl = document.getElementById(deckId);
                    const handEl = document.getElementById(handId);
                    if (!deckEl || !handEl) { resolve(); return; }
                    const startRect = deckEl.getBoundingClientRect();
                    const endRect = handEl.getBoundingClientRect();
                    const targetLeft = endRect.left + (endRect.width / 2) - (startRect.width / 2);
                    const targetTop = endRect.top + 20; 
                    const clone = document.createElement('div');
                    clone.className = 'flying-card deck-visual'; 
                    clone.style.width = 'var(--board-card-w)';
                    clone.style.height = 'var(--board-card-h)';
                    clone.style.top = startRect.top + 'px';
                    clone.style.left = startRect.left + 'px';
                    clone.style.position = 'fixed';
                    clone.style.borderRadius = '0.8vh';
                    document.body.appendChild(clone);
                    clone.offsetWidth;
                    clone.style.top = targetTop + 'px';
                    clone.style.left = targetLeft + 'px';
                    clone.style.transform = 'scale(1.2)'; 
                    setTimeout(() => {
                        clone.remove();
                        resolve();
                    }, 600);
                });
            },
            showDiceRoll: (roll) => {
                const overlay = document.getElementById('dice-overlay');
                if (!overlay) return;
                const numberEl = overlay.querySelector('.dice-number');
                if (numberEl) numberEl.textContent = roll;
                overlay.style.display = 'flex';
                overlay.setAttribute('aria-hidden', 'false');
                if (ui.diceTimer) clearTimeout(ui.diceTimer);
                ui.diceTimer = setTimeout(() => {
                    overlay.style.display = 'none';
                    overlay.setAttribute('aria-hidden', 'true');
                }, 800);
            },
            showSuitSelection: (autoPick = false) => {
                return new Promise(resolve => {
                    const overlay = document.getElementById('suit-overlay');
                    if (!overlay) { resolve(null); return; }
                    const suits = [
                        { key: 'swords', label: 'Espadas', icon: '‚öîÔ∏è' },
                        { key: 'hearts', label: 'Copas', icon: '‚ù§Ô∏è' },
                        { key: 'gold', label: 'Ouro', icon: '‚ô¶Ô∏è' },
                        { key: 'clubs', label: 'Paus', icon: '‚ô£Ô∏è' }
                    ].sort(() => Math.random() - 0.5);
                    overlay.innerHTML = `
                        <div class="suit-modal">
                            <div class="suit-title">Escolha um naipe</div>
                            <div class="suit-hand">
                                <div class="suit-hand-icon">üñêÔ∏è</div>
                                ${suits.map(suit => `
                                    <div class="suit-card" data-suit="${suit.key}" aria-label="${suit.label}">üÇ†</div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    overlay.style.display = 'flex';
                    overlay.setAttribute('aria-hidden', 'false');
                    let resolved = false;
                    const finish = (result) => {
                        if (resolved) return;
                        resolved = true;
                        overlay.style.display = 'none';
                        overlay.setAttribute('aria-hidden', 'true');
                        overlay.innerHTML = '';
                        resolve(result);
                    };
                    overlay.querySelectorAll('.suit-card').forEach(cardEl => {
                        cardEl.addEventListener('click', () => {
                            if (resolved) return;
                            const suitKey = cardEl.dataset.suit;
                            const suit = suits.find(s => s.key === suitKey);
                            cardEl.classList.add('revealed');
                            cardEl.textContent = suit?.icon ?? 'üÇ†';
                            setTimeout(() => finish(suitKey), 300);
                        });
                    });
                    if (autoPick) {
                        setTimeout(() => {
                            const cards = Array.from(overlay.querySelectorAll('.suit-card'));
                            const choice = cards[Math.floor(Math.random() * cards.length)];
                            choice?.click();
                        }, 700);
                    }
                });
            },
            openHandModal: (card) => {
                if (game.activeSide !== 'player') return;
                if (game.handStealMode || game.handPickMode || game.graveyardSelectMode) return;
                game.resetInteraction();
                const overlay = document.getElementById('overlay');
                document.getElementById('game-container').classList.add('blur-background');
                let actionBtn = '';
                if(card.rarity === 'utility') {
                     actionBtn = `<button class="btn btn-summon" onclick="ui.initUtility('${card.uid}')">USAR (${card.piCost} PI)</button>`;
                } else {
                     actionBtn = `<button class="btn btn-summon" onclick="ui.initSummon('${card.uid}')">INVOCAR (${card.piCost} PI)</button>`;
                }
                const stars = '‚≠ê'.repeat(card.piCost);
                const isUtility = card.rarity === 'utility';
                let imgStyle = isUtility ? 'filter: hue-rotate(90deg);' : '';
                const archetypeIconHtml = getArchetypeIcon(card.archetype);
                let statsHtml = '';
                if (!isUtility) {
                    statsHtml = `
                        <div class="modal-stats-row">
                            <span class="modal-stat" style="color:var(--danger)">‚öîÔ∏è ${card.atk}</span>
                            <span class="modal-stat" style="color:var(--secondary)">‚ù§Ô∏è ${card.hp}</span>
                            <span class="modal-stat" style="color:var(--blue)">üõ°Ô∏è ${card.def}</span>
                            <span class="modal-stat" style="color:var(--gold)">‚ö° ${card.pa}</span>
                        </div>
                    `;
                }
                overlay.innerHTML = `
                    <div class="modal-card">
                        <div class="modal-visual-card ${card.rarity}">
                            <div class="modal-inner">
                                <div class="modal-header">
                                    <div class="modal-name">${card.name}</div>
                                    <div class="modal-stars">${stars}</div>
                                </div>
                                <div class="modal-art-frame">
                                    ${archetypeIconHtml}
                                    <img src="${card.img}" class="modal-art-img" style="${imgStyle}">
                                </div>
                                <div class="modal-text-area">
                                    ${statsHtml}
                                    <div class="modal-desc-box">
                                        <div class="modal-label">EFEITO</div>
                                        <div class="modal-text">${card.habDesc}</div>
                                    </div>
                                    ${card.ultDesc && card.ultDesc !== '-' ? `
                                    <div class="modal-desc-box">
                                        <div class="modal-label" style="color:var(--util)">ULTIMATE</div>
                                        <div class="modal-text">${card.ultDesc}</div>
                                    </div>` : ''}
                                    <div class="modal-subtext">${card.tribe} | ${card.archetype} | ${card.rarity.toUpperCase()}</div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions-panel">
                            <h3>JOGAR</h3>
                            ${actionBtn}
                            <button class="btn btn-cancel" onclick="ui.closeOverlay()">CANCELAR</button>
                        </div>
                    </div>
                `;
                overlay.style.display = 'flex';
                overlay.classList.add('overlay-open');
            },
            openFieldModal: (card) => {
                const overlay = document.getElementById('overlay');
                document.getElementById('game-container').classList.add('blur-background');
                const isControlledByPlayer = card.controlledBy === 'player';
                const isPlayerCard = card.owner === 'player' || isControlledByPlayer;
                const isMyTurn = game.activeSide === 'player';
                const canControl = isPlayerCard && isMyTurn;
                const isFirstPlayerTurnLocked = game.roundNumber === 1 && game.activeSide === game.roundStarter && game.firstPlayerFirstTurnAttackLocked;
                const hasFreeAttack = card.nextAttackFree && card.nextAttackFree.turnsLeft > 0;
                const skillTargetMode = game.getTargetingMode(card, 'skill');
                const ultTargetMode = game.getTargetingMode(card, 'ult');
                const skillCost = game.getActionCost(card, 'skill');
                const ultCost = game.getActionCost(card, 'ult');
                const canUseSkill = game.canUseAction(card, 'skill');
                const canUseUlt = game.canUseAction(card, 'ult');
                const isDrunk = card.dbId === 'L-11' && game.isL11Drunk(card);
                const runeAvailable = card.dbId !== 'L-15' || game.getRuneTargets(game.getCardController(card)).length > 0;
                const canAtk = canControl && (card.pa >= 2 || hasFreeAttack) && !isFirstPlayerTurnLocked;
                const canSkill = canControl && canUseSkill && (card.pa >= skillCost) && (!isFirstPlayerTurnLocked || skillTargetMode === 'self') && !isDrunk;
                const canUlt = canControl && canUseUlt && (card.pa >= ultCost) && (!isFirstPlayerTurnLocked || ultTargetMode === 'self') && runeAvailable;
                const canMove = card.owner === 'player' && canControl && game.player.pi >= 1;
                const canControlMove = isControlledByPlayer && isMyTurn;

                let warning = "";
                if(isFirstPlayerTurnLocked && canControl) warning = "<p style='color:red; text-align:center; font-size:1.2vh;'>No 1¬∫ turno, apenas buffs em si mesmo.</p>";
                if(!isMyTurn && isPlayerCard) warning = "<p style='color:orange; text-align:center; font-size:1.2vh;'>Aguarde seu turno.</p>";
                if(!isPlayerCard) warning = "<p style='color:red; text-align:center; font-size:1.2vh;'>Carta do Inimigo</p>";
                if (card.dbId === 'L-15' && !runeAvailable && isPlayerCard && !warning) warning = "<p style='color:orange; text-align:center; font-size:1.2vh;'>Ultimate indispon√≠vel: nenhuma Runa em campo.</p>";

                const stars = '‚≠ê'.repeat(card.piCost);
                const archetypeIconHtml = getArchetypeIcon(card.archetype);

                overlay.innerHTML = `
                    <div class="modal-card">
                         <div class="modal-visual-card ${card.rarity}">
                            <div class="modal-inner">
                                <div class="modal-header">
                                    <div class="modal-name">${card.name}</div>
                                    <div class="modal-stars">${stars}</div>
                                </div>
                                <div class="modal-art-frame">
                                    ${archetypeIconHtml}
                                    <img src="${card.img}" class="modal-art-img">
                                </div>
                                <div class="modal-text-area">
                                    <div class="modal-stats-row">
                                        <span class="modal-stat" style="color:var(--danger)">‚öîÔ∏è ${Math.floor(game.getEffectiveAtk(card))}</span>
                                        <span class="modal-stat" style="color:var(--secondary)">‚ù§Ô∏è ${Math.floor(card.currentHp)}</span>
                                        <span class="modal-stat" style="color:var(--blue)">üõ°Ô∏è ${Math.floor(game.getEffectiveDef(card))}</span>
                                        <span class="modal-stat" style="color:var(--gold)">‚ö° ${card.pa}</span>
                                    </div>
                                    <div class="modal-desc-box">
                                        <div class="modal-label">HABILIDADE (${skillCost} PA)</div>
                                        <div class="modal-text">${card.habDesc}</div>
                                    </div>
                                    <div class="modal-desc-box">
                                        <div class="modal-label" style="color:var(--util)">ULTIMATE (${ultCost} PA)</div>
                                        <div class="modal-text">${card.ultDesc}</div>
                                    </div>
                                    <div class="modal-subtext">${card.tribe} | ${card.archetype} | ${card.rarity.toUpperCase()}</div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions-panel">
                            <h3>A√á√ïES</h3>
                            ${warning}
                            ${isFirstPlayerTurnLocked ? '' : `<button class="btn btn-atk" ${canAtk ? '' : 'disabled'} onclick="ui.initAttack('${card.uid}', 'attack')">ATACAR (2 PA)</button>`}
                            <button class="btn btn-skill" ${canSkill ? '' : 'disabled'} onclick="ui.initAttack('${card.uid}', 'skill')">HABILIDADE (${skillCost} PA)</button>
                            <button class="btn btn-ult" ${canUlt ? '' : 'disabled'} onclick="ui.initAttack('${card.uid}', 'ult')">ULTIMATE (${ultCost} PA)</button>
                            <button class="btn btn-skill" id="btn-move" ${canMove ? '' : 'disabled'} onclick="ui.initMove('${card.uid}')">MOVER (1 PI)</button>
                            ${isControlledByPlayer ? `<button class="btn btn-skill" ${canControlMove ? '' : 'disabled'} onclick="ui.initControlledMove('${card.uid}')">MOVER (CONTROLADO)</button>` : ''}
                            <button class="btn btn-cancel" onclick="ui.closeOverlay()">FECHAR</button>
                        </div>
                    </div>
                `;
                overlay.style.display = 'flex';
                overlay.classList.add('overlay-open');
            },
            initMove: (uid) => {
                if (game.handStealMode || game.handPickMode || game.graveyardSelectMode) return;
                ui.closeOverlay();
                const cardKey = Object.keys(game.player.field).find(k => game.player.field[k].uid === uid);
                const card = game.player.field[cardKey];
                if (!card) return;

                game.interactionMode = 'move';
                game.activeCard = card;
                game.validSlots = [];

                // Add all valid player slots (rows 2 and 3) except current one
                const rows = [2, 3];
                rows.forEach(r => {
                    for(let c=0; c<5; c++) {
                        if (r !== card.r || c !== card.c) {
                            game.validSlots.push(`${r}-${c}`);
                        }
                    }
                });

                ui.renderField();
            },
            initControlledMove: (uid) => {
                if (game.handStealMode || game.handPickMode || game.graveyardSelectMode) return;
                ui.closeOverlay();
                const card = game.getCardByUid(uid);
                if (!card || card.controlledBy !== 'player') return;
                game.interactionMode = 'control_move';
                game.activeCard = card;
                game.validSlots = [];
                const rows = [2, 3];
                rows.forEach(r => {
                    for (let c = 0; c < 5; c++) {
                        if (!game.player.field[`${r}-${c}`]) {
                            game.validSlots.push(`${r}-${c}`);
                        }
                    }
                });
                if (game.validSlots.length === 0) {
                    alert("Sem espa√ßo no campo!");
                    game.resetInteraction();
                    return;
                }
                ui.renderField();
            },
            initSummon: (uid) => {
                if (game.handStealMode || game.handPickMode || game.graveyardSelectMode) return;
                ui.closeOverlay();
                const card = game.player.hand.find(c => c.uid === uid);
                if (!card) return;
                if (game.player.pi < card.piCost) { alert("Sem PI suficiente"); return; }
                game.interactionMode = 'summon';
                game.activeCard = card;
                game.validSlots = [];
                const rows = [2, 3]; 
                let hasSpace = false;
                rows.forEach(r => { for(let c=0; c<5; c++) { if(!game.player.field[`${r}-${c}`]) { game.validSlots.push(`${r}-${c}`); hasSpace = true; } } });
                if(!hasSpace) { alert("Sem espa√ßo no campo!"); game.resetInteraction(); return; }
                ui.renderField();
            },
            initUtility: (uid) => {
                if (game.handStealMode || game.handPickMode || game.graveyardSelectMode) return;
                ui.closeOverlay();
                const card = game.player.hand.find(c => c.uid === uid);
                if (!card) return;
                if(game.player.pi < card.piCost) { alert("Sem PI"); return; }
                game.interactionMode = 'utility';
                game.activeCard = card;
                game.validSlots = [];
                document.body.classList.add('cursor-sword');
                Object.values(game.player.field).forEach(c => { game.validSlots.push(`${c.r}-${c.c}`); });
                if (game.validSlots.length === 0) { alert("Precisa de uma unidade aliada no campo!"); game.resetInteraction(); return; }
                ui.renderField();
            },
            initAttack: (uid, type) => {
                if (game.handStealMode || game.handPickMode || game.graveyardSelectMode) return;
                ui.closeOverlay();
                const card = game.getCardByUid(uid);
                if(!card) return;
                if (card.owner !== 'player' && card.controlledBy !== 'player') return;
                if (type === 'ult' && card.dbId === 'L-15' && game.getRuneTargets(game.getCardController(card)).length === 0) {
                    game.logAction("Ultimate indispon√≠vel: nenhuma Runa em campo", game.getCardController(card));
                    return;
                }
                const targetMode = game.getTargetingMode(card, type);
                const isFirstPlayerTurnLocked = game.roundNumber === 1 && game.activeSide === game.roundStarter && game.firstPlayerFirstTurnAttackLocked;
                if (isFirstPlayerTurnLocked && targetMode !== 'self') {
                    return;
                }
                if (targetMode === 'graveyard') {
                    ui.openGraveyardOverlay({
                        mode: 'select',
                        sourceCard: card,
                        onSelect: (selected) => {
                            game.executeAction(type, card, selected);
                        }
                    });
                    return;
                }
                if (targetMode === 'self') {
                    game.executeAction(type, card, card);
                    return;
                }
                if (targetMode === 'ally') {
                    game.interactionMode = 'target';
                    game.activeCard = card;
                    game.pendingActionType = type;
                    game.validSlots = [];
                    document.body.classList.add('cursor-sword');
                    const allies = Object.values(game.player.field);
                    allies.forEach(ally => {
                        game.validSlots.push(`${ally.r}-${ally.c}`);
                    });
                    if (game.validSlots.length === 0) {
                        alert("Precisa de um aliado no campo!");
                        game.resetInteraction();
                        return;
                    }
                    ui.renderField();
                    return;
                }
                if (targetMode === 'ally_or_enemy') {
                    game.interactionMode = 'target';
                    game.activeCard = card;
                    game.pendingActionType = type;
                    game.validSlots = [];
                    document.body.classList.add('cursor-sword');
                    const allies = Object.values(game.player.field);
                    allies.forEach(ally => {
                        game.validSlots.push(`${ally.r}-${ally.c}`);
                    });
                    const enemies = Object.values(game.opp.field).filter(e => e.uid !== card.uid);
                    const hasFrontRow = enemies.some(e => e.r === 1);
                    const hasVanguardAccess = game.getActiveEffects(card, 'l18_backrow_access').length > 0;
                    const isMeleeLocked = !(card.dbId === 'L-11' && type === 'skill') && (card.archetype === 'Melee' || card.archetype === 'Tank') && hasFrontRow && !hasVanguardAccess;
                    enemies.forEach(e => {
                        if (isMeleeLocked) { if (e.r === 1) game.validSlots.push(`${e.r}-${e.c}`); } 
                        else { game.validSlots.push(`${e.r}-${e.c}`); }
                    });
                    if (game.validSlots.length === 0) {
                        alert("Precisa de um alvo no campo!");
                        game.resetInteraction();
                        return;
                    }
                    ui.renderField();
                    return;
                }
                game.interactionMode = 'target';
                game.activeCard = card;
                game.pendingActionType = type;
                game.validSlots = [];
                document.body.classList.add('cursor-sword');
                const enemies = Object.values(game.opp.field).filter(e => e.uid !== card.uid);
                const hasFrontRow = enemies.some(e => e.r === 1);
                const hasVanguardAccess = game.getActiveEffects(card, 'l18_backrow_access').length > 0;
                const isMeleeLocked = (card.archetype === 'Melee' || card.archetype === 'Tank') && hasFrontRow && !hasVanguardAccess;
                enemies.forEach(e => {
                    if (isMeleeLocked) { if (e.r === 1) game.validSlots.push(`${e.r}-${e.c}`); } 
                    else { game.validSlots.push(`${e.r}-${e.c}`); }
                });
                let canAttackAvatar = false;
                if (!hasFrontRow) { canAttackAvatar = true; } 
                else if (card.archetype !== 'Melee' && card.archetype !== 'Tank') { canAttackAvatar = true; }
                const allowAvatarTarget = !(card.dbId === 'L-18' && type === 'ult');
                if (canAttackAvatar && allowAvatarTarget) {
                     const hud = document.getElementById('hud-opponent');
                     hud.style.border = "2px dashed #ffd700"; 
                     hud.style.cursor = "crosshair";
                     hud.onclick = () => {
                         game.executeAction(type, card, 'opp_avatar');
                         hud.style.border = "1px solid #444";
                         hud.style.cursor = "default";
                         hud.onclick = null;
                         game.resetInteraction();
                     };
                }
                ui.renderField();
            },
            runSummonAnimation: (cardData, targetSlot, r, c) => {
                const allHandCards = Array.from(document.querySelectorAll('.player-hand .card'));
                const handCard = allHandCards.find(el => el.dataset.uid === cardData.uid);
                if (handCard) {
                    const startRect = handCard.getBoundingClientRect();
                    const endRect = targetSlot.getBoundingClientRect();
                    const clone = handCard.cloneNode(true);
                    clone.classList.add('flying-card');
                    clone.style.top = startRect.top + 'px';
                    clone.style.left = startRect.left + 'px';
                    clone.style.width = startRect.width + 'px';
                    clone.style.height = startRect.height + 'px';
                    document.body.appendChild(clone);
                    handCard.style.opacity = '0';
                    requestAnimationFrame(() => {
                        clone.style.top = endRect.top + 'px';
                        clone.style.left = endRect.left + 'px';
                        clone.style.width = endRect.width + 'px'; 
                        clone.style.height = endRect.height + 'px';
                        clone.style.transform = "scale(0.8)"; 
                    });
                    setTimeout(() => {
                        clone.remove();
                        fx.spawnParticles('summon', endRect);
                        game.commitSummon(cardData, r, c);
                    }, 600);
                } else {
                    game.commitSummon(cardData, r, c);
                }
            },
            createParticles: (x, y, color) => {
                const particleCount = 10;
                for (let i = 0; i < particleCount; i++) {
                    const p = document.createElement('div');
                    p.className = 'particle';
                    p.style.backgroundColor = color;
                    p.style.left = x + 'px';
                    p.style.top = y + 'px';
                    const angle = Math.random() * Math.PI * 2;
                    const velocity = Math.random() * 80 + 20; 
                    const tx = Math.cos(angle) * velocity;
                    const ty = Math.sin(angle) * velocity;
                    p.style.setProperty('--tx', `${tx}px`);
                    p.style.setProperty('--ty', `${ty}px`);
                    document.body.appendChild(p); 
                    setTimeout(() => p.remove(), 600);
                }
            },
            showDamage: (element, amount, color='red') => {
                if(!element) return;
                const float = document.createElement('div');
                float.className = 'floating-text';
                float.innerText = typeof amount === 'number' ? `-${Math.floor(amount)}` : amount;
                float.style.color = '#000'; 
                const rect = element.getBoundingClientRect();
                float.style.left = rect.left + rect.width/2 + 'px';
                float.style.top = rect.top + 'px';
                document.body.appendChild(float);
                setTimeout(() => float.remove(), 1000);
            },
            closeOverlay: () => {
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('overlay').classList.remove('overlay-open');
                document.getElementById('game-container').classList.remove('blur-background');
            },
            /* --- SFX (Melee Impact) --- */
            initMeleeSfx: () => {},
            unlockAudioForSfx: () => {},
            playMeleeImpactSfx: () => {},
            /* --- Arena VFX (Melee Sword) --- */

            /* --- Arena VFX (Melee Sword) --- */
            spawnArenaMeleeSwordVfx: (attackerEl, targetEl, durationMs, onImpact) => {
                // VFX ONLY: sword travels from CENTER-OF-ART(img) -> CENTER-OF-ART(img) on the Arena overlay,
                // then performs a SWING (cut) on impact. No game logic is altered; onImpact fires exactly at impact time.
                const vfxLayer = document.getElementById('arena-vfx-layer') || document.getElementById('arena-overlay') || document.body;

                // helper: find the artwork img inside a rendered arena card
                const getArenaArtImg = (slotEl) => {
                    if (!slotEl) return null;
                    return (
                        slotEl.querySelector('.arena-card-display > img') ||
                        slotEl.querySelector('img')
                    );
                };

                const getCenterFromImg = (imgEl) => {
                    if (!imgEl) return null;
                    const rect = imgEl.getBoundingClientRect();
                    return {
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height / 2
                    };
                };

                let sword = null;
                let travelAnim = null;
                let swingAnim = null;
                let fadeAnim = null;
                let safetyTimer = null;

                const cleanup = () => {
                    try { if (travelAnim) travelAnim.cancel(); } catch(e) {}
                    try { if (swingAnim) swingAnim.cancel(); } catch(e) {}
                    try { if (fadeAnim) fadeAnim.cancel(); } catch(e) {}
                    try { if (safetyTimer) clearTimeout(safetyTimer); } catch(e) {}
                    try { if (sword) sword.remove(); } catch(e) {}
                    sword = null;
                };

                try {
                    const aImg = getArenaArtImg(attackerEl);
                    const tImg = getArenaArtImg(targetEl);
                    const aC = getCenterFromImg(aImg);
                    const tC = getCenterFromImg(tImg);

                    if (!aC || !tC) {
                        if (typeof onImpact === 'function') onImpact();
                        return;
                    }

                    const startX = aC.x;
                    const startY = aC.y;
                    const endX = tC.x;
                    const endY = tC.y;

                    const dx = endX - startX;
                    const dy = endY - startY;
                    const dirAngle = Math.atan2(dy, dx) * 180 / Math.PI;

                    sword = document.createElement('div');
                    sword.className = 'arena-sword-slash';
                    sword.setAttribute('aria-hidden', 'true');

                    // extra guard element helps it read as a sword, not a line
                    const guard = document.createElement('div');
                    guard.className = 'arena-sword-guard';
                    sword.appendChild(guard);

                    // ensure it sits above EVERYTHING in the arena
                    sword.style.zIndex = '100000';
                    sword.style.pointerEvents = 'none';

                    // Mount into the dedicated arena VFX layer
                    vfxLayer.appendChild(sword);

                    // transform builder: fixed positioning in viewport coords
                    const pos = (x, y, rotDeg, zPop = 0) =>
                        `translate3d(${x}px, ${y}px, ${zPop}px) translate(-50%, -50%) rotateZ(${rotDeg}deg) rotateX(22deg) rotateY(-14deg)`;

                    // Travel phase: move into target center (no "stab" overshoot)
                    const travelRot = dirAngle - 10; // slight offset so it reads as a slash, not a thrust
                    sword.style.transform = pos(startX, startY, travelRot, 0);

                    travelAnim = sword.animate(
                        [
                            { transform: pos(startX, startY, travelRot, 0), opacity: 1 },
                            { transform: pos(endX, endY, travelRot, 0), opacity: 1 }
                        ],
                        {
                            duration: Math.max(220, durationMs || 520),
                            easing: 'cubic-bezier(0.20, 0.85, 0.20, 1.00)',
                            fill: 'forwards'
                        }
                    );

                    travelAnim.onfinish = () => {
                        // Impact timing: fire exactly when the sword reaches the target center.
                        try { if (typeof onImpact === 'function') onImpact(); } catch(e) {}

                        // Swing phase: STOP then rotate around the hilt (CUT, not pierce)
                        const swingFrom = dirAngle - 40;
                        const swingTo = dirAngle + 40;

                        swingAnim = sword.animate(
                            [
                                { transform: pos(endX, endY, swingFrom, 0), filter: 'brightness(1.05)' },
                                { transform: pos(endX, endY, swingTo, 10), filter: 'brightness(1.22)' }
                            ],
                            {
                                duration: 180,
                                easing: 'cubic-bezier(0.10, 0.85, 0.20, 1.00)',
                                fill: 'forwards'
                            }
                        );

                        swingAnim.onfinish = () => {
                            fadeAnim = sword.animate(
                                [{ opacity: 1 }, { opacity: 0 }],
                                { duration: 160, easing: 'ease-out', fill: 'forwards' }
                            );
                            fadeAnim.onfinish = () => cleanup();
                        };
                    };

                    // Safety cleanup (prevents DOM leaks)
                    safetyTimer = setTimeout(() => cleanup(), Math.max(1500, (durationMs || 520) + 1200));
                } catch(e) {
                    try { if (typeof onImpact === 'function') onImpact(); } catch(err) {}
                    cleanup();
                }
            },
            // === Skill VFX (Hadouken) ===
            ensureGlobalVfxLayer: () => {
                let layer = document.getElementById('global-vfx-layer');
                if (!layer) {
                    layer = document.createElement('div');
                    layer.id = 'global-vfx-layer';
                    layer.setAttribute('aria-hidden','true');
                    document.body.appendChild(layer);
                }
                return layer;
            },
            _getCenterFromRect: (rect, offsetY=0) => {
                return { x: rect.left + rect.width/2, y: rect.top + rect.height/2 + offsetY };
            },
            _getElCenter: (el, offsetY=0) => {
                if (!el) return null;
                const r = el.getBoundingClientRect();
                return ui._getCenterFromRect(r, offsetY);
            },
            _emitHadoukenTrail: (layer, x, y) => {
                const t = document.createElement('div');
                t.className = 'hadouken-trail';
                t.style.left = x + 'px';
                t.style.top  = y + 'px';
                layer.appendChild(t);
                // fade out quickly
                t.animate([{opacity:0.65, transform:'translate(-50%,-50%) scale(1.0)'},
                           {opacity:0.0,  transform:'translate(-50%,-50%) scale(1.9)'}],
                          {duration:220, easing:'ease-out', fill:'forwards'});
                setTimeout(() => { try { t.remove(); } catch(e){} }, 260);
            },
            _spawnHadoukenImpact: (layer, x, y) => {
                const flash = document.createElement('div');
                flash.className = 'hadouken-impact-flash';
                flash.style.left = x + 'px';
                flash.style.top  = y + 'px';
                layer.appendChild(flash);
                flash.animate([{opacity:0.0, transform:'translate(-50%,-50%) scale(0.7)'},
                               {opacity:1.0, transform:'translate(-50%,-50%) scale(1.0)'},
                               {opacity:0.0, transform:'translate(-50%,-50%) scale(1.35)'}],
                              {duration:260, easing:'ease-out', fill:'forwards'});
                setTimeout(() => { try { flash.remove(); } catch(e){} }, 320);
            },
            _animateHadouken: (start, end, onImpact, durationMs) => {
                return new Promise((resolve) => {
                    const layer = ui.ensureGlobalVfxLayer();
                    const dur = Math.max(600, Math.min(900, durationMs || 760));
                    const FAILSAFE_MS = 2500;

                    let done = false;
                    let trailTimer = null;
                    let failsafe = null;

                    const cleanup = () => {
                        if (done) return;
                        done = true;
                        try { if (trailTimer) clearInterval(trailTimer); } catch(e){}
                        try { if (failsafe) clearTimeout(failsafe); } catch(e){}
                        resolve();
                    };

                    const had = document.createElement('div');
                    had.className = 'hadouken';
                    had.style.left = start.x + 'px';
                    had.style.top  = start.y + 'px';
                    layer.appendChild(had);

                    // trail sampler
                    trailTimer = setInterval(() => {
                        try {
                            const rect = had.getBoundingClientRect();
                            ui._emitHadoukenTrail(layer, rect.left + rect.width/2, rect.top + rect.height/2);
                        } catch(e){}
                    }, 55);

                    // travel animation (fixed positioning)
                    const anim = had.animate([
                        { transform: 'translate(-50%,-50%) scale(1.0)', left: start.x+'px', top: start.y+'px' },
                        { transform: 'translate(-50%,-50%) scale(1.02)', left: end.x+'px',   top: end.y+'px' }
                    ], { duration: dur, easing: 'linear', fill: 'forwards' });

                    const impact = () => {
                        if (done) return;
                        // Impact visuals (blue/cyan)
                        ui._spawnHadoukenImpact(layer, end.x, end.y);
                        ui.createParticles(end.x, end.y, '#33e6ff');
                        ui.createParticles(end.x, end.y, '#8ff7ff');
                        try { if (typeof onImpact === 'function') onImpact(); } catch(e){}
                        // fade out projectile
                        try {
                            had.animate([{opacity:0.98, transform:'translate(-50%,-50%) scale(1.0)'},
                                         {opacity:0.0,  transform:'translate(-50%,-50%) scale(1.6)'}],
                                        {duration:220, easing:'ease-out', fill:'forwards'});
                        } catch(e){}
                        setTimeout(() => { try { had.remove(); } catch(e){} }, 260);
                        setTimeout(() => cleanup(), 320);
                    };

                    anim.onfinish = impact;
                    anim.oncancel = impact;

                    // failsafe to guarantee resolve even if animations are throttled
                    failsafe = setTimeout(() => {
                        try { anim.cancel(); } catch(e){}
                        try { impact(); } catch(e){}
                    }, FAILSAFE_MS);
                });
            },
            animateSkillHadoukenBoard: (source, target) => {
                // board: use slot center (or HUD center for avatar), with small upward offset
                let sEl, tEl;
                if (source && source.r !== undefined) {
                    sEl = document.querySelector(`.slot[data-r="${source.r}"][data-c="${source.c}"]`);
                }
                if (target === 'player_avatar') tEl = document.getElementById('hud-player');
                else if (target === 'opp_avatar') tEl = document.getElementById('hud-opponent');
                else if (target && target.r !== undefined) tEl = document.querySelector(`.slot[data-r="${target.r}"][data-c="${target.c}"]`);

                const start = ui._getElCenter(sEl, -22);
                const end   = ui._getElCenter(tEl, -22);
                if (!start || !end) return Promise.resolve();

                // optional: light shake on target at impact (if element exists)
                const onImpact = () => {
                    if (tEl) {
                        tEl.classList.remove('anim-shake');
                        void tEl.offsetWidth;
                        tEl.classList.add('anim-shake');
                    }
                };
                return ui._animateHadouken(start, end, onImpact, 760);
            },
            animateSkillHadoukenArena: (onImpact) => {
                // arena: use center of ART (img) for big cards, with upward offset
                const aImg = document.querySelector('#arena-attacker img');
                const tImg = document.querySelector('#arena-target img');
                const start = ui._getElCenter(aImg, -20);
                const end   = ui._getElCenter(tImg, -20);
                if (!start || !end) return Promise.resolve();
                return ui._animateHadouken(start, end, onImpact, 780);
            },



            showCinematicDuel: (source, target, actionType, damageAmount) => {
                return new Promise((resolve) => {
                    // Duel UI/VFX timers must be cleaned to avoid leaks across repeated duels
                    const _timers = [];
                    const _setT = (fn, ms) => { const id = setTimeout(fn, ms); _timers.push(id); return id; };
                    const _clearTimers = () => { _timers.forEach(id => clearTimeout(id)); _timers.length = 0; };


                    // Fail-safe to prevent duel promises from hanging (e.g., background tabs throttling timers/rAF)
                    const FAILSAFE_MS = 4000;
                    let _finished = false;
                    let _failsafeId = null;
                    let _visHandlerBound = false;
const arena = document.getElementById('arena-overlay');
                    const cAttacker = document.getElementById('arena-attacker');
                    const cTarget = document.getElementById('arena-target');
                    const log = document.getElementById('arena-log');
                                        const effectContainer = document.getElementById('arena-effect-container');
                    let tObj = target;
                    if (target === 'player_avatar' || target === 'opp_avatar') {
                        const victim = target === 'player_avatar' ? game.player : game.opp;
                        tObj = {
                            owner: target === 'player_avatar' ? 'player' : 'opp',
                            name: target === 'player_avatar' ? "L√≠der (Voc√™)" : "L√≠der (Oponente)",
                            img: "https://via.placeholder.com/300/444/fff?text=LIDER",
                            currentHp: victim.hp,
                            maxHp: victim.maxHp,
                            currentAtk: 0,
                            currentDef: victim.def,
                            rarity: 'legendary'
                        };
                    }
                    const isPlayerAttacking = (source.controlledBy || source.owner) === 'player';
                    const atkClass = isPlayerAttacking ? 'arena-ally-glow' : 'arena-enemy-glow';
                    const defClass = isPlayerAttacking ? 'arena-enemy-glow' : 'arena-ally-glow';
                    const renderArenaCard = (card, idSuffix, glowClass) => {
                        const hpPerc = (card.currentHp / card.maxHp) * 100;
                        return `
                            <div class="arena-card-display ${card.rarity} ${glowClass}">
                                <img src="${card.img}">
                                <div class="arena-card-info">
                                    <h2>${card.name}</h2>
                                    <div>ATK: ${Math.floor(card.currentAtk)} | DEF: ${Math.floor(card.currentDef)}</div>
                                    <div class="arena-hp-bar">
                                        <div id="hp-bar-${idSuffix}" class="arena-hp-fill" style="width:${hpPerc}%"></div>
                                    </div>
                                    <div style="font-size:1.5vh; margin-top:0.5vh;">${Math.floor(card.currentHp)} / ${card.maxHp} HP</div>
                                </div>
                            </div>
                        `;
                    };
                    cAttacker.innerHTML = renderArenaCard(source, 'atk', atkClass);
                    cTarget.innerHTML = renderArenaCard(tObj, 'def', defClass);
                    cAttacker.style.animation = 'none'; cAttacker.offsetHeight; 
                    cAttacker.style.animation = 'arenaSlideLeft 0.5s ease-out';
                    cTarget.style.animation = 'none'; cTarget.offsetHeight;
                    cTarget.style.animation = 'arenaSlideRight 0.5s ease-out';
                    effectContainer.innerHTML = '';
                    log.innerHTML = `${source.name} prepara ${actionType.toUpperCase()}!`;
                    arena.style.display = 'flex';
                    document.getElementById('game-container').classList.add('blur-background');
                    _setT(() => {
                        let travelTime = 500;
                        const isMelee = (source.archetype === 'Melee' || source.archetype === 'Tank');

                        // SKILL: unified Blue Hadouken VFX for ALL archetypes (no legacy skill projectile)
                        if (actionType === 'skill') {
                            ui.animateSkillHadoukenArena(() => {
                                triggerImpact();
                            });
                        } else if (isMelee) {
                            // Melee/Tank attacks (and non-skill actions): Sword slash VFX synced with impact timing
                            ui.spawnArenaMeleeSwordVfx(cAttacker, cTarget, Math.round(travelTime * 1.25), () => {
                                triggerImpact();
                            });
                        } else {
                            // Non-melee actions keep existing projectile styling (attack/ult)
                            let projClass = 'projectile-basic';
                            if (actionType === 'ult') projClass = 'projectile-ult';
                            const proj = document.createElement('div');
                            proj.className = `projectile-div ${projClass}`;
                            effectContainer.appendChild(proj);
                            _setT(() => {
                                triggerImpact();
                                proj.remove();
                            }, travelTime);
                        }
                    }, 600);
                    function triggerImpact() {
                        cTarget.classList.remove('anim-shake'); 
                        void cTarget.offsetWidth;
                        cTarget.classList.add('anim-shake');
                        if (actionType === 'ult') {
                            arena.classList.add('screen-shake');
                            _setT(() => arena.classList.remove('screen-shake'), 500);
                            fx.screenShake(1.8, 520);
                            arena.classList.add('fx-ult-impact');
                            _setT(() => arena.classList.remove('fx-ult-impact'), 320);
                        }
                        const rect = cTarget.getBoundingClientRect();
                        const cx = rect.left + rect.width/2;
                        const cy = rect.top + rect.height/2;
                        if (actionType === 'skill') {
                            // Blue/cyan energy impact for skill
                            ui._spawnHadoukenImpact(ui.ensureGlobalVfxLayer(), cx, cy);
                            ui.createParticles(cx, cy, '#33e6ff');
                            ui.createParticles(cx, cy, '#8ff7ff');
                            fx.spawnParticles('skill', null, rect);
                        } else {
                            ui.createParticles(cx, cy, '#ff0000');
                            fx.spawnParticles(actionType === 'ult' ? 'ult' : 'attack', null, rect);
                        }
                        log.innerHTML = `Causou <span style="color:red; font-weight:bold;">${Math.floor(damageAmount)}</span> de dano!`;
                        const newHp = Math.max(0, tObj.currentHp - damageAmount);
                        const newPerc = (newHp / tObj.maxHp) * 100;
                        const hpBar = document.getElementById('hp-bar-def');
                        if(hpBar) {
                            hpBar.style.width = `${newPerc}%`;
                            if(newPerc < 30) hpBar.style.background = "#ff4444";
                        }
                        scheduleAutoCloseFromImpact(900);
                    }
                    let _closed = false;
                    const closeArena = (forced) => {
                        if (_closed) return;
                        _closed = true;
                        if (_finished) return;
                        _finished = true;

                        _clearTimers();
                        if (_failsafeId) { clearTimeout(_failsafeId); _failsafeId = null; }

                        if (_visHandlerBound) {
                            try { document.removeEventListener('visibilitychange', _onVisChange); } catch(e) {}
                            _visHandlerBound = false;
                        }

                        // Cleanup VFX layers and content so nothing blocks clicks after closing
                        const vfxLayer = document.getElementById('arena-vfx-layer');
                        if (vfxLayer) vfxLayer.innerHTML = '';
                        if (effectContainer) effectContainer.innerHTML = '';
                        // Also remove any active global skill VFX elements (in case tab was hidden / animation throttled)
                        const _gLayer = document.getElementById('global-vfx-layer');
                        if (_gLayer) {
                            _gLayer.querySelectorAll('.hadouken, .hadouken-trail, .hadouken-impact-flash').forEach(n => { try { n.remove(); } catch(e){} });
                        }
                        cAttacker.innerHTML = '';
                        cTarget.innerHTML = '';
                        log.innerHTML = '';

                        try { arena.classList.remove('screen-shake'); } catch(e) {}

                        arena.style.display = 'none';
                        document.getElementById('game-container').classList.remove('blur-background');
                        resolve();
                    };

                    // Visibility fail-safe: if tab becomes hidden during duel, finalize immediately (do not wait for VFX)
                    const _onVisChange = () => {
                        if (document.hidden) {
                            closeArena(true);
                        }
                    };
                    document.addEventListener('visibilitychange', _onVisChange);
                    _visHandlerBound = true;

                    // Global fail-safe timeout: ensure this promise always resolves even if animations/timers are throttled
                    _failsafeId = setTimeout(() => {
                        closeArena(true);
                    }, FAILSAFE_MS);


                    // Auto-close for BOTH sides (player and AI) ‚Äî no OK button, never blocks clicks
                    let _impactScheduledClose = false;
                    const scheduleAutoCloseFromImpact = (delayMs) => {
                        if (_impactScheduledClose) return;
                        _impactScheduledClose = true;
                        const ms = Math.max(600, Math.min(1200, delayMs || 900));
                        _setT(closeArena, ms);
                    };
                });
            },
            animateBoardProjectile: (source, target) => {
                return new Promise((resolve) => {
                    let sEl, tEl;
                    if (source.r !== undefined) {
                        sEl = document.querySelector(`.slot[data-r="${source.r}"][data-c="${source.c}"]`);
                    } else {
                        resolve(); return;
                    }
                    if (target === 'player_avatar') tEl = document.getElementById('hud-player');
                    else if (target === 'opp_avatar') tEl = document.getElementById('hud-opponent');
                    else tEl = document.querySelector(`.slot[data-r="${target.r}"][data-c="${target.c}"]`);
                    if(!sEl || !tEl) { resolve(); return; }

                    const sRect = sEl.getBoundingClientRect();
                    const tRect = tEl.getBoundingClientRect();

                    const sx = (sRect.left + sRect.width/2);
                    const sy = (sRect.top + sRect.height/2);
                    const tx = (tRect.left + tRect.width/2);
                    const ty = (tRect.top + tRect.height/2);

                    const isMelee = (source.archetype === 'Melee' || source.archetype === 'Tank');
                    const proj = document.createElement('div');
                    proj.className = isMelee ? 'board-projectile melee-sword' : 'board-projectile';

                    // For Melee, inject directional angle so the sword points toward the target (no spin)
                    if (isMelee) {
                        const angle = Math.atan2((ty - sy), (tx - sx)) * 180 / Math.PI;
                        proj.style.setProperty('--angle', angle + 'deg');
                    }

                    proj.style.top = sy + 'px';
                    proj.style.left = sx + 'px';
                    document.body.appendChild(proj);

                    // Force layout so transition applies
                    proj.offsetWidth;

                    if (!isMelee) {
                        // Default projectile (unchanged)
                        proj.style.top = ty + 'px';
                        proj.style.left = tx + 'px';
                        setTimeout(() => {
                            proj.style.transform = "scale(2)";
                            proj.style.opacity = 0;
                            setTimeout(() => {
                                proj.remove();
                                resolve();
                            }, 200);
                        }, 800);
                        return;
                    }

                    // --- Melee VFX: big cyan-glow sword, 25% slower travel, stop, then slash ---
                    const travelMs = Math.round(800 * 1.25); // 25% mais lento
                    proj.style.transition = `top ${travelMs}ms linear, left ${travelMs}ms linear, opacity 160ms ease`;

                    proj.style.top = ty + 'px';
                    proj.style.left = tx + 'px';

                    setTimeout(() => {
                        // Pause briefly, then slash (impact moment)
                        const pauseMs = 70;
                        setTimeout(() => {
                            // Impact SFX (only here to avoid double spam)

                            // Slash line over the target
                            const slash = document.createElement('div');
                            slash.className = 'melee-slash-line';
                            slash.style.left = tx + 'px';
                            slash.style.top = ty + 'px';
                            // Angle a bit offset from travel direction for a slicing feel
                            const slashAngle = (Math.random() * 30 - 15) - 25; // ~[-40..-10]
                            slash.style.setProperty('--slash-angle', slashAngle + 'deg');
                            document.body.appendChild(slash);
                            setTimeout(() => slash.remove(), 240);

                            // Quick slash rotation on the sword
                            proj.classList.add('slash');

                            // Fade out and cleanup
                            setTimeout(() => {
                                proj.style.opacity = 0;
                                setTimeout(() => {
                                    proj.remove();
                                    resolve();
                                }, 180);
                            }, 210);
                        }, pauseMs);
                    }, travelMs);
                });
            }
        };

        fx.bindButtons();
        fx.initSfxToggle();

        const ai = {
            executeTurn: async () => {
                if (game.activeSide !== 'enemy') return;
                const hand = [...game.opp.hand];
                for(let card of hand) {
                    if (card.rarity === 'utility') {
                        if (game.opp.pi >= card.piCost) {
                            const allies = Object.values(game.opp.field);
                            if (allies.length > 0) {
                                const target = allies.sort((a,b) => b.atk - a.atk)[0];
                                game.applyUtility(card, target);
                                await new Promise(r => setTimeout(r, 1000));
                            }
                        }
                        continue; 
                    }
                    if (game.opp.pi >= card.piCost) {
                        let placed = false;
                        const row = card.archetype === 'Melee' ? 1 : 0;
                        for(let c=0; c<5; c++) {
                            if(!game.opp.field[`${row}-${c}`]) {
                                game.commitSummon(card, row, c); 
                                placed = true;
                                break;
                            }
                        }
                        if(placed) await new Promise(r => setTimeout(r, 800));
                    }
                }
                const units = Object.values(game.opp.field).filter(c => game.getCardController(c) === 'enemy');
                const resolveTarget = (unit, action) => {
                    const targetMode = game.getTargetingMode(unit, action);
                    if (targetMode === 'self') return unit;
                    if (targetMode === 'ally') {
                        const allies = Object.values(game.opp.field).filter(c => game.getCardController(c) === 'enemy');
                        if (allies.length === 0) return null;
                        return allies.sort((a,b) => a.currentHp - b.currentHp)[0];
                    }
                    if (targetMode === 'ally_or_enemy') {
                        const enemies = Object.values(game.player.field);
                        if (enemies.length > 0) {
                            return enemies.sort((a,b) => a.currentHp - b.currentHp)[0];
                        }
                        const allies = Object.values(game.opp.field).filter(c => game.getCardController(c) === 'enemy');
                        if (allies.length > 0) {
                            return allies.sort((a,b) => a.currentHp - b.currentHp)[0];
                        }
                        return null;
                    }
                    if (targetMode === 'graveyard') {
                        return null;
                    }
                    const liveTargets = Object.values(game.player.field);
                    if (liveTargets.length === 0) {
                        return action === 'attack' ? 'player_avatar' : null;
                    }
                    const validTargets = liveTargets.filter(t => !game.isBackRowBlocked(unit, t));
                    const pool = validTargets.length > 0 ? validTargets : liveTargets;
                    return pool.sort((a,b) => a.currentHp - b.currentHp)[0];
                };
                for (const unit of units) {
                    const ultCost = game.getActionCost(unit, 'ult');
                    const skillCost = game.getActionCost(unit, 'skill');
                    const canUseUlt = game.canUseAction(unit, 'ult') && unit.pa >= ultCost;
                    const canUseSkill = game.canUseAction(unit, 'skill') && unit.pa >= skillCost;
                    const canAttack = unit.pa >= 2;
                    let action = null;
                    if (canUseUlt) action = 'ult';
                    else if (canUseSkill) action = 'skill';
                    else if (canAttack) action = 'attack';
                    if (!action) continue;
                    let target = resolveTarget(unit, action);
                    if (!target && action !== 'attack') {
                        if (canAttack) {
                            action = 'attack';
                            target = resolveTarget(unit, action);
                        }
                    }
                    if (!target) continue;
                    await game.executeAction(action, unit, target);
                    await new Promise(r => setTimeout(r, 500));
                }
                game.passTurn();
            }
        };

        function playRPS(choice) {
            const opts = ['rock', 'paper', 'scissors'];
            const oppChoice = opts[Math.floor(Math.random() * opts.length)];
            const resDiv = document.getElementById('rps-result');
            let result = ''; 
            if (choice === oppChoice) result = 'draw';
            else if (
                (choice === 'rock' && oppChoice === 'scissors') ||
                (choice === 'paper' && oppChoice === 'rock') ||
                (choice === 'scissors' && oppChoice === 'paper')
            ) result = 'win';
            else result = 'lose';
            resDiv.innerText = `Voc√™: ${choice} vs PC: ${oppChoice}`;
            if(result === 'draw') {
                setTimeout(() => resDiv.innerText = "EMPATE! TENTE NOVAMENTE!", 500);
            } else {
                setTimeout(() => {
                    document.getElementById('rps-overlay').style.display = 'none';
                    game.startMatch(result === 'win' ? 'player' : 'enemy');
                }, 1500);
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (game.handStealMode) {
                    game.endHandStealMode();
                } else if (game.handPickMode) {
                    game.cancelHandPickMode();
                } else if (game.interactionMode === 'target') {
                    const card = game.activeCard;
                    game.resetInteraction();
                    setTimeout(() => ui.openFieldModal(card), 50); 
                } else if (game.interactionMode === 'summon' || game.interactionMode === 'utility') {
                    game.resetInteraction();
                } else if (game.interactionMode === 'move' || game.interactionMode === 'control_move') {
                    const card = game.activeCard;
                    game.resetInteraction();
                    setTimeout(() => ui.openFieldModal(card), 50);
                } else if (document.getElementById('graveyard-overlay').style.display === 'flex') {
                    ui.closeGraveyardOverlay();
                } else if (game.graveyardSelectMode) {
                    game.cancelGraveyardSelectMode();
                } else if (document.getElementById('builder-overlay').style.display === 'flex') {
                    closeBuilderCardModal();
                }
            }
        });

        window.onload = () => {
            navigateTo('menu');
            ui.bindGraveyardClicks();
        };

    </script>
</body>
</html>
